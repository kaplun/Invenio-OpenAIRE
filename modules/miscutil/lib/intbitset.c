/* Generated by Cython 0.11.2 on Fri Jul 24 10:54:10 2009 */

#define PY_SSIZE_T_CLEAN
#include "Python.h"
#include "structmember.h"
#ifndef Py_PYTHON_H
    #error Python headers needed to compile C extensions, please install development version of Python.
#endif
#ifndef PY_LONG_LONG
  #define PY_LONG_LONG LONG_LONG
#endif
#ifndef DL_EXPORT
  #define DL_EXPORT(t) t
#endif
#if PY_VERSION_HEX < 0x02040000
  #define METH_COEXIST 0
  #define PyDict_CheckExact(op) (Py_TYPE(op) == &PyDict_Type)
#endif
#if PY_VERSION_HEX < 0x02050000
  typedef int Py_ssize_t;
  #define PY_SSIZE_T_MAX INT_MAX
  #define PY_SSIZE_T_MIN INT_MIN
  #define PY_FORMAT_SIZE_T ""
  #define PyInt_FromSsize_t(z) PyInt_FromLong(z)
  #define PyInt_AsSsize_t(o)   PyInt_AsLong(o)
  #define PyNumber_Index(o)    PyNumber_Int(o)
  #define PyIndex_Check(o)     PyNumber_Check(o)
#endif
#if PY_VERSION_HEX < 0x02060000
  #define Py_REFCNT(ob) (((PyObject*)(ob))->ob_refcnt)
  #define Py_TYPE(ob)   (((PyObject*)(ob))->ob_type)
  #define Py_SIZE(ob)   (((PyVarObject*)(ob))->ob_size)
  #define PyVarObject_HEAD_INIT(type, size) \
          PyObject_HEAD_INIT(type) size,
  #define PyType_Modified(t)

  typedef struct {
       void *buf;
       PyObject *obj;
       Py_ssize_t len;
       Py_ssize_t itemsize;
       int readonly;
       int ndim;
       char *format;
       Py_ssize_t *shape;
       Py_ssize_t *strides;
       Py_ssize_t *suboffsets;
       void *internal;
  } Py_buffer;

  #define PyBUF_SIMPLE 0
  #define PyBUF_WRITABLE 0x0001
  #define PyBUF_FORMAT 0x0004
  #define PyBUF_ND 0x0008
  #define PyBUF_STRIDES (0x0010 | PyBUF_ND)
  #define PyBUF_C_CONTIGUOUS (0x0020 | PyBUF_STRIDES)
  #define PyBUF_F_CONTIGUOUS (0x0040 | PyBUF_STRIDES)
  #define PyBUF_ANY_CONTIGUOUS (0x0080 | PyBUF_STRIDES)
  #define PyBUF_INDIRECT (0x0100 | PyBUF_STRIDES)

#endif
#if PY_MAJOR_VERSION < 3
  #define __Pyx_BUILTIN_MODULE_NAME "__builtin__"
#else
  #define __Pyx_BUILTIN_MODULE_NAME "builtins"
#endif
#if PY_MAJOR_VERSION >= 3
  #define Py_TPFLAGS_CHECKTYPES 0
  #define Py_TPFLAGS_HAVE_INDEX 0
#endif
#if (PY_VERSION_HEX < 0x02060000) || (PY_MAJOR_VERSION >= 3)
  #define Py_TPFLAGS_HAVE_NEWBUFFER 0
#endif
#if PY_MAJOR_VERSION >= 3
  #define PyBaseString_Type            PyUnicode_Type
  #define PyString_Type                PyBytes_Type
  #define PyString_CheckExact          PyBytes_CheckExact
  #define PyInt_Type                   PyLong_Type
  #define PyInt_Check(op)              PyLong_Check(op)
  #define PyInt_CheckExact(op)         PyLong_CheckExact(op)
  #define PyInt_FromString             PyLong_FromString
  #define PyInt_FromUnicode            PyLong_FromUnicode
  #define PyInt_FromLong               PyLong_FromLong
  #define PyInt_FromSize_t             PyLong_FromSize_t
  #define PyInt_FromSsize_t            PyLong_FromSsize_t
  #define PyInt_AsLong                 PyLong_AsLong
  #define PyInt_AS_LONG                PyLong_AS_LONG
  #define PyInt_AsSsize_t              PyLong_AsSsize_t
  #define PyInt_AsUnsignedLongMask     PyLong_AsUnsignedLongMask
  #define PyInt_AsUnsignedLongLongMask PyLong_AsUnsignedLongLongMask
  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_TrueDivide(x,y)
#else
  #define __Pyx_PyNumber_Divide(x,y)         PyNumber_Divide(x,y)
  #define PyBytes_Type                 PyString_Type
#endif
#if PY_MAJOR_VERSION >= 3
  #define PyMethod_New(func, self, klass) PyInstanceMethod_New(func)
#endif
#if !defined(WIN32) && !defined(MS_WINDOWS)
  #ifndef __stdcall
    #define __stdcall
  #endif
  #ifndef __cdecl
    #define __cdecl
  #endif
  #ifndef __fastcall
    #define __fastcall
  #endif
#else
  #define _USE_MATH_DEFINES
#endif
#if PY_VERSION_HEX < 0x02050000
  #define __Pyx_GetAttrString(o,n)   PyObject_GetAttrString((o),((char *)(n)))
  #define __Pyx_SetAttrString(o,n,a) PyObject_SetAttrString((o),((char *)(n)),(a))
  #define __Pyx_DelAttrString(o,n)   PyObject_DelAttrString((o),((char *)(n)))
#else
  #define __Pyx_GetAttrString(o,n)   PyObject_GetAttrString((o),(n))
  #define __Pyx_SetAttrString(o,n,a) PyObject_SetAttrString((o),(n),(a))
  #define __Pyx_DelAttrString(o,n)   PyObject_DelAttrString((o),(n))
#endif
#if PY_VERSION_HEX < 0x02050000
  #define __Pyx_NAMESTR(n) ((char *)(n))
  #define __Pyx_DOCSTR(n)  ((char *)(n))
#else
  #define __Pyx_NAMESTR(n) (n)
  #define __Pyx_DOCSTR(n)  (n)
#endif
#ifdef __cplusplus
#define __PYX_EXTERN_C extern "C"
#else
#define __PYX_EXTERN_C extern
#endif
#include <math.h>
#define __PYX_HAVE_API__lib__intbitset
#include "intbitset.h"
#define __PYX_USE_C99_COMPLEX defined(_Complex_I)


#ifdef __GNUC__
#define INLINE __inline__
#elif _WIN32
#define INLINE __inline
#else
#define INLINE 
#endif

typedef struct {PyObject **p; char *s; long n; char is_unicode; char intern; char is_identifier;} __Pyx_StringTabEntry; /*proto*/



static int __pyx_skip_dispatch = 0;


/* Type Conversion Predeclarations */

#if PY_MAJOR_VERSION < 3
#define __Pyx_PyBytes_FromString          PyString_FromString
#define __Pyx_PyBytes_FromStringAndSize   PyString_FromStringAndSize
#define __Pyx_PyBytes_AsString            PyString_AsString
#else
#define __Pyx_PyBytes_FromString          PyBytes_FromString
#define __Pyx_PyBytes_FromStringAndSize   PyBytes_FromStringAndSize
#define __Pyx_PyBytes_AsString            PyBytes_AsString
#endif

#define __Pyx_PyBool_FromLong(b) ((b) ? (Py_INCREF(Py_True), Py_True) : (Py_INCREF(Py_False), Py_False))
static INLINE int __Pyx_PyObject_IsTrue(PyObject*);
static INLINE PyObject* __Pyx_PyNumber_Int(PyObject* x);

#if !defined(T_PYSSIZET)
#if PY_VERSION_HEX < 0x02050000
#define T_PYSSIZET T_INT
#elif !defined(T_LONGLONG)
#define T_PYSSIZET \
        ((sizeof(Py_ssize_t) == sizeof(int))  ? T_INT  : \
        ((sizeof(Py_ssize_t) == sizeof(long)) ? T_LONG : -1))
#else
#define T_PYSSIZET \
        ((sizeof(Py_ssize_t) == sizeof(int))          ? T_INT      : \
        ((sizeof(Py_ssize_t) == sizeof(long))         ? T_LONG     : \
        ((sizeof(Py_ssize_t) == sizeof(PY_LONG_LONG)) ? T_LONGLONG : -1)))
#endif
#endif

#if !defined(T_SIZET)
#if !defined(T_ULONGLONG)
#define T_SIZET \
        ((sizeof(size_t) == sizeof(unsigned int))  ? T_UINT  : \
        ((sizeof(size_t) == sizeof(unsigned long)) ? T_ULONG : -1))
#else
#define T_SIZET \
        ((sizeof(size_t) == sizeof(unsigned int))          ? T_UINT      : \
        ((sizeof(size_t) == sizeof(unsigned long))         ? T_ULONG     : \
        ((sizeof(size_t) == sizeof(unsigned PY_LONG_LONG)) ? T_ULONGLONG : -1)))
#endif
#endif

static INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject*);
static INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t);
static INLINE size_t __Pyx_PyInt_AsSize_t(PyObject*);

#define __pyx_PyFloat_AsDouble(x) (PyFloat_CheckExact(x) ? PyFloat_AS_DOUBLE(x) : PyFloat_AsDouble(x))


#ifdef __GNUC__
/* Test for GCC > 2.95 */
#if __GNUC__ > 2 ||               (__GNUC__ == 2 && (__GNUC_MINOR__ > 95)) 
#define likely(x)   __builtin_expect(!!(x), 1)
#define unlikely(x) __builtin_expect(!!(x), 0)
#else /* __GNUC__ > 2 ... */
#define likely(x)   (x)
#define unlikely(x) (x)
#endif /* __GNUC__ > 2 ... */
#else /* __GNUC__ */
#define likely(x)   (x)
#define unlikely(x) (x)
#endif /* __GNUC__ */
    
static PyObject *__pyx_m;
static PyObject *__pyx_b;
static PyObject *__pyx_empty_tuple;
static int __pyx_lineno;
static int __pyx_clineno = 0;
static const char * __pyx_cfilenm= __FILE__;
static const char *__pyx_filename;
static const char **__pyx_f;


#ifdef CYTHON_REFNANNY
typedef struct {
  void (*INCREF)(void*, PyObject*, int);
  void (*DECREF)(void*, PyObject*, int);
  void (*GOTREF)(void*, PyObject*, int);
  void (*GIVEREF)(void*, PyObject*, int);
  void* (*NewContext)(const char*, int, const char*);
  void (*FinishContext)(void**);
} __Pyx_RefnannyAPIStruct;
static __Pyx_RefnannyAPIStruct *__Pyx_Refnanny = NULL;
#define __Pyx_ImportRefcountAPI(name)   (__Pyx_RefnannyAPIStruct *) PyCObject_Import((char *)name, (char *)"RefnannyAPI")
#define __Pyx_INCREF(r) __Pyx_Refnanny->INCREF(__pyx_refchk, (PyObject *)(r), __LINE__)
#define __Pyx_DECREF(r) __Pyx_Refnanny->DECREF(__pyx_refchk, (PyObject *)(r), __LINE__)
#define __Pyx_GOTREF(r) __Pyx_Refnanny->GOTREF(__pyx_refchk, (PyObject *)(r), __LINE__)
#define __Pyx_GIVEREF(r) __Pyx_Refnanny->GIVEREF(__pyx_refchk, (PyObject *)(r), __LINE__)
#define __Pyx_XDECREF(r) if((r) == NULL) ; else __Pyx_DECREF(r)
#define __Pyx_SetupRefcountContext(name)   void* __pyx_refchk = __Pyx_Refnanny->NewContext((name), __LINE__, __FILE__)
#define __Pyx_FinishRefcountContext()   __Pyx_Refnanny->FinishContext(&__pyx_refchk)
#else
#define __Pyx_INCREF(r) Py_INCREF(r)
#define __Pyx_DECREF(r) Py_DECREF(r)
#define __Pyx_GOTREF(r)
#define __Pyx_GIVEREF(r)
#define __Pyx_XDECREF(r) Py_XDECREF(r)
#define __Pyx_SetupRefcountContext(name)
#define __Pyx_FinishRefcountContext()
#endif /* CYTHON_REFNANNY */
#define __Pyx_XGIVEREF(r) if((r) == NULL) ; else __Pyx_GIVEREF(r)
#define __Pyx_XGOTREF(r) if((r) == NULL) ; else __Pyx_GOTREF(r)

static void __Pyx_RaiseDoubleKeywordsError(
    const char* func_name, PyObject* kw_name); /*proto*/

static void __Pyx_RaiseArgtupleInvalid(const char* func_name, int exact,
    Py_ssize_t num_min, Py_ssize_t num_max, Py_ssize_t num_found); /*proto*/

static int __Pyx_ParseOptionalKeywords(PyObject *kwds, PyObject **argnames[],     PyObject *kwds2, PyObject *values[], Py_ssize_t num_pos_args,     const char* function_name); /*proto*/

static int __Pyx_GetException(PyObject **type, PyObject **value, PyObject **tb); /*proto*/


static INLINE PyObject *__Pyx_GetItemInt_Generic(PyObject *o, PyObject* j) {
    PyObject *r;
    if (!j) return NULL;
    r = PyObject_GetItem(o, j);
    Py_DECREF(j);
    return r;
}


#define __Pyx_GetItemInt_List(o, i, size, to_py_func) ((size <= sizeof(Py_ssize_t)) ? \
                                                    __Pyx_GetItemInt_List_Fast(o, i, size <= sizeof(long)) : \
                                                    __Pyx_GetItemInt_Generic(o, to_py_func(i)))

static INLINE PyObject *__Pyx_GetItemInt_List_Fast(PyObject *o, Py_ssize_t i, int fits_long) {
    if (likely(o != Py_None)) {
        if (likely((0 <= i) & (i < PyList_GET_SIZE(o)))) {
            PyObject *r = PyList_GET_ITEM(o, i);
            Py_INCREF(r);
            return r;
        }
        else if ((-PyList_GET_SIZE(o) <= i) & (i < 0)) {
            PyObject *r = PyList_GET_ITEM(o, PyList_GET_SIZE(o) + i);
            Py_INCREF(r);
            return r;
        }
    }
    return __Pyx_GetItemInt_Generic(o, fits_long ? PyInt_FromLong(i) : PyLong_FromLongLong(i));
}

#define __Pyx_GetItemInt_Tuple(o, i, size, to_py_func) ((size <= sizeof(Py_ssize_t)) ? \
                                                    __Pyx_GetItemInt_Tuple_Fast(o, i, size <= sizeof(long)) : \
                                                    __Pyx_GetItemInt_Generic(o, to_py_func(i)))

static INLINE PyObject *__Pyx_GetItemInt_Tuple_Fast(PyObject *o, Py_ssize_t i, int fits_long) {
    if (likely(o != Py_None)) {
        if (likely((0 <= i) & (i < PyTuple_GET_SIZE(o)))) {
            PyObject *r = PyTuple_GET_ITEM(o, i);
            Py_INCREF(r);
            return r;
        }
        else if ((-PyTuple_GET_SIZE(o) <= i) & (i < 0)) {
            PyObject *r = PyTuple_GET_ITEM(o, PyTuple_GET_SIZE(o) + i);
            Py_INCREF(r);
            return r;
        }
    }
    return __Pyx_GetItemInt_Generic(o, fits_long ? PyInt_FromLong(i) : PyLong_FromLongLong(i));
}


#define __Pyx_GetItemInt(o, i, size, to_py_func) ((size <= sizeof(Py_ssize_t)) ? \
                                                    __Pyx_GetItemInt_Fast(o, i, size <= sizeof(long)) : \
                                                    __Pyx_GetItemInt_Generic(o, to_py_func(i)))

static INLINE PyObject *__Pyx_GetItemInt_Fast(PyObject *o, Py_ssize_t i, int fits_long) {
    PyObject *r;
    if (PyList_CheckExact(o) && ((0 <= i) & (i < PyList_GET_SIZE(o)))) {
        r = PyList_GET_ITEM(o, i);
        Py_INCREF(r);
    }
    else if (PyTuple_CheckExact(o) && ((0 <= i) & (i < PyTuple_GET_SIZE(o)))) {
        r = PyTuple_GET_ITEM(o, i);
        Py_INCREF(r);
    }
    else if (Py_TYPE(o)->tp_as_sequence && Py_TYPE(o)->tp_as_sequence->sq_item && (likely(i >= 0))) {
        r = PySequence_GetItem(o, i);
    }
    else {
        r = __Pyx_GetItemInt_Generic(o, fits_long ? PyInt_FromLong(i) : PyLong_FromLongLong(i));
    }
    return r;
}

static int __Pyx_ArgTypeTest(PyObject *obj, PyTypeObject *type, int none_allowed,
    const char *name, int exact); /*proto*/

static INLINE void __Pyx_ExceptionSave(PyObject **type, PyObject **value, PyObject **tb); /*proto*/
static void __Pyx_ExceptionReset(PyObject *type, PyObject *value, PyObject *tb); /*proto*/

static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list); /*proto*/

static PyObject *__Pyx_GetName(PyObject *dict, PyObject *name); /*proto*/

static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb); /*proto*/

static INLINE void __Pyx_ErrRestore(PyObject *type, PyObject *value, PyObject *tb); /*proto*/
static INLINE void __Pyx_ErrFetch(PyObject **type, PyObject **value, PyObject **tb); /*proto*/

static INLINE void __Pyx_RaiseNeedMoreValuesError(Py_ssize_t index);

static INLINE void __Pyx_RaiseTooManyValuesError(void);

static PyObject *__Pyx_UnpackItem(PyObject *, Py_ssize_t index); /*proto*/
static int __Pyx_EndUnpack(PyObject *); /*proto*/

static INLINE PyObject* __Pyx_PyObject_Append(PyObject* L, PyObject* x) {
    if (likely(PyList_CheckExact(L))) {
        if (PyList_Append(L, x) < 0) return NULL;
        Py_INCREF(Py_None);
        return Py_None; /* this is just to have an accurate signature */
    }
    else {
        PyObject *r, *m;
        m = __Pyx_GetAttrString(L, "append");
        if (!m) return NULL;
        r = PyObject_CallFunctionObjArgs(m, x, NULL);
        Py_DECREF(m);
        return r;
    }
}

static INLINE int __Pyx_StrEq(const char *, const char *); /*proto*/

static INLINE unsigned char __Pyx_PyInt_AsUnsignedChar(PyObject *);

static INLINE unsigned short __Pyx_PyInt_AsUnsignedShort(PyObject *);

static INLINE unsigned int __Pyx_PyInt_AsUnsignedInt(PyObject *);

static INLINE char __Pyx_PyInt_AsChar(PyObject *);

static INLINE short __Pyx_PyInt_AsShort(PyObject *);

static INLINE int __Pyx_PyInt_AsInt(PyObject *);

static INLINE signed char __Pyx_PyInt_AsSignedChar(PyObject *);

static INLINE signed short __Pyx_PyInt_AsSignedShort(PyObject *);

static INLINE signed int __Pyx_PyInt_AsSignedInt(PyObject *);

static INLINE unsigned long __Pyx_PyInt_AsUnsignedLong(PyObject *);

static INLINE unsigned PY_LONG_LONG __Pyx_PyInt_AsUnsignedLongLong(PyObject *);

static INLINE long __Pyx_PyInt_AsLong(PyObject *);

static INLINE PY_LONG_LONG __Pyx_PyInt_AsLongLong(PyObject *);

static INLINE signed long __Pyx_PyInt_AsSignedLong(PyObject *);

static INLINE signed PY_LONG_LONG __Pyx_PyInt_AsSignedLongLong(PyObject *);

static void __Pyx_AddTraceback(const char *funcname); /*proto*/

static int __Pyx_InitStrings(__Pyx_StringTabEntry *t); /*proto*/

/* Type declarations */

/* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":741
 *         return self.extract_finite_list()
 * 
 * cdef class intbitset_iterator:             # <<<<<<<<<<<<<<
 *     cdef int last
 *     cdef IntBitSet *bitset
 */

struct __pyx_obj_3lib_9intbitset_intbitset_iterator {
  PyObject_HEAD
  int last;
  IntBitSet *bitset;
  int sanity_checks;
};

/* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":94
 * __maxelem__ = maxelem
 * 
 * cdef class intbitset:             # <<<<<<<<<<<<<<
 *     """
 *     Defines an intbitset data object to hold unordered sets of
 */

struct __pyx_obj_3lib_9intbitset_intbitset {
  PyObject_HEAD
  IntBitSet *bitset;
  int sanity_checks;
};
/* Module declarations from lib.intbitset */

static PyTypeObject *__pyx_ptype_3lib_9intbitset_intbitset = 0;
static PyTypeObject *__pyx_ptype_3lib_9intbitset_intbitset_iterator = 0;
static int __pyx_k_7;
#define __Pyx_MODULE_NAME "lib.intbitset"
int __pyx_module_is_main_lib__intbitset = 0;

/* Implementation of lib.intbitset */
static char __pyx_k_3[] = "$Id$";
static PyObject *__pyx_int_0;
static PyObject *__pyx_int_1;
static PyObject *__pyx_int_10;
static PyObject *__pyx_int_5;
static char __pyx_k___main__[] = "__main__";
static PyObject *__pyx_kp___main__;
static char __pyx_k___cinit__[] = "__cinit__";
static PyObject *__pyx_kp___cinit__;
static char __pyx_k___dealloc__[] = "__dealloc__";
static PyObject *__pyx_kp___dealloc__;
static char __pyx_k___contains__[] = "__contains__";
static PyObject *__pyx_kp___contains__;
static char __pyx_k___cmp__[] = "__cmp__";
static PyObject *__pyx_kp___cmp__;
static char __pyx_k___richcmp__[] = "__richcmp__";
static PyObject *__pyx_kp___richcmp__;
static char __pyx_k___len__[] = "__len__";
static PyObject *__pyx_kp___len__;
static char __pyx_k___hash__[] = "__hash__";
static PyObject *__pyx_kp___hash__;
static char __pyx_k___nonzero__[] = "__nonzero__";
static PyObject *__pyx_kp___nonzero__;
static char __pyx_k___iadd__[] = "__iadd__";
static PyObject *__pyx_kp___iadd__;
static char __pyx_k___isub__[] = "__isub__";
static PyObject *__pyx_kp___isub__;
static char __pyx_k___deepcopy__[] = "__deepcopy__";
static PyObject *__pyx_kp___deepcopy__;
static char __pyx_k___del__[] = "__del__";
static PyObject *__pyx_kp___del__;
static char __pyx_k___and__[] = "__and__";
static PyObject *__pyx_kp___and__;
static char __pyx_k___or__[] = "__or__";
static PyObject *__pyx_kp___or__;
static char __pyx_k___xor__[] = "__xor__";
static PyObject *__pyx_kp___xor__;
static char __pyx_k___sub__[] = "__sub__";
static PyObject *__pyx_kp___sub__;
static char __pyx_k___iand__[] = "__iand__";
static PyObject *__pyx_kp___iand__;
static char __pyx_k___ior__[] = "__ior__";
static PyObject *__pyx_kp___ior__;
static char __pyx_k___ixor__[] = "__ixor__";
static PyObject *__pyx_kp___ixor__;
static char __pyx_k___repr__[] = "__repr__";
static PyObject *__pyx_kp___repr__;
static char __pyx_k___str__[] = "__str__";
static PyObject *__pyx_kp___str__;
static char __pyx_k___iter__[] = "__iter__";
static PyObject *__pyx_kp___iter__;
static char __pyx_k_add[] = "add";
static PyObject *__pyx_kp_add;
static char __pyx_k_clear[] = "clear";
static PyObject *__pyx_kp_clear;
static char __pyx_k_difference[] = "difference";
static PyObject *__pyx_kp_difference;
static char __pyx_k_difference_update[] = "difference_update";
static PyObject *__pyx_kp_difference_update;
static char __pyx_k_discard[] = "discard";
static PyObject *__pyx_kp_discard;
static char __pyx_k_intersection[] = "intersection";
static PyObject *__pyx_kp_intersection;
static char __pyx_k_intersection_update[] = "intersection_update";
static PyObject *__pyx_kp_intersection_update;
static char __pyx_k_union[] = "union";
static PyObject *__pyx_kp_union;
static char __pyx_k_union_update[] = "union_update";
static PyObject *__pyx_kp_union_update;
static char __pyx_k_issubset[] = "issubset";
static PyObject *__pyx_kp_issubset;
static char __pyx_k_issuperset[] = "issuperset";
static PyObject *__pyx_kp_issuperset;
static char __pyx_k_1[] = "symmetric_difference";
static PyObject *__pyx_kp_1;
static char __pyx_k_2[] = "symmetric_difference_update";
static PyObject *__pyx_kp_2;
static char __pyx_k_fastdump[] = "fastdump";
static PyObject *__pyx_kp_fastdump;
static char __pyx_k_fastload[] = "fastload";
static PyObject *__pyx_kp_fastload;
static char __pyx_k_copy[] = "copy";
static PyObject *__pyx_kp_copy;
static char __pyx_k_pop[] = "pop";
static PyObject *__pyx_kp_pop;
static char __pyx_k_remove[] = "remove";
static PyObject *__pyx_kp_remove;
static char __pyx_k_strbits[] = "strbits";
static PyObject *__pyx_kp_strbits;
static char __pyx_k_update_with_signs[] = "update_with_signs";
static PyObject *__pyx_kp_update_with_signs;
static char __pyx_k_get_size[] = "get_size";
static PyObject *__pyx_kp_get_size;
static char __pyx_k_get_allocated[] = "get_allocated";
static PyObject *__pyx_kp_get_allocated;
static char __pyx_k_get_sorted_element[] = "get_sorted_element";
static PyObject *__pyx_kp_get_sorted_element;
static char __pyx_k_to_sorted_list[] = "to_sorted_list";
static PyObject *__pyx_kp_to_sorted_list;
static char __pyx_k_is_infinite[] = "is_infinite";
static PyObject *__pyx_kp_is_infinite;
static char __pyx_k_extract_finite_list[] = "extract_finite_list";
static PyObject *__pyx_kp_extract_finite_list;
static char __pyx_k_get_wordbitsize[] = "get_wordbitsize";
static PyObject *__pyx_kp_get_wordbitsize;
static char __pyx_k_get_wordbytsize[] = "get_wordbytsize";
static PyObject *__pyx_kp_get_wordbytsize;
static char __pyx_k_tolist[] = "tolist";
static PyObject *__pyx_kp_tolist;
static char __pyx_k___next__[] = "__next__";
static PyObject *__pyx_kp___next__;
static char __pyx_k_rhs[] = "rhs";
static PyObject *__pyx_kp_rhs;
static char __pyx_k_preallocate[] = "preallocate";
static PyObject *__pyx_kp_preallocate;
static char __pyx_k_trailing_bits[] = "trailing_bits";
static PyObject *__pyx_kp_trailing_bits;
static char __pyx_k_sanity_checks[] = "sanity_checks";
static PyObject *__pyx_kp_sanity_checks;
static char __pyx_k_no_allocate[] = "no_allocate";
static PyObject *__pyx_kp_no_allocate;
static char __pyx_k_elem[] = "elem";
static PyObject *__pyx_kp_elem;
static char __pyx_k_self[] = "self";
static PyObject *__pyx_kp_self;
static char __pyx_k_op[] = "op";
static PyObject *__pyx_kp_op;
static char __pyx_k_memo[] = "memo";
static PyObject *__pyx_kp_memo;
static char __pyx_k_strdump[] = "strdump";
static PyObject *__pyx_kp_strdump;
static char __pyx_k_index[] = "index";
static PyObject *__pyx_kp_index;
static char __pyx_k_i[] = "i";
static PyObject *__pyx_kp_i;
static char __pyx_k_j[] = "j";
static PyObject *__pyx_kp_j;
static char __pyx_k_up_to[] = "up_to";
static PyObject *__pyx_kp_up_to;
static char __pyx_k_bitset[] = "bitset";
static PyObject *__pyx_kp_bitset;
static char __pyx_k___revision__[] = "__revision__";
static PyObject *__pyx_kp___revision__;
static char __pyx_k___apilevel__[] = "__apilevel__";
static PyObject *__pyx_kp___apilevel__;
static char __pyx_k_zlib[] = "zlib";
static PyObject *__pyx_kp_zlib;
static char __pyx_k_array[] = "array";
static PyObject *__pyx_kp_array;
static char __pyx_k_4[] = "invenio.config";
static PyObject *__pyx_kp_4;
static char __pyx_k_5[] = "CFG_INTBITSET_ENABLE_SANITY_CHECKS";
static PyObject *__pyx_kp_5;
static char __pyx_k_6[] = "intbitset";
static PyObject *__pyx_kp_6;
static char __pyx_k___all__[] = "__all__";
static PyObject *__pyx_kp___all__;
static char __pyx_k___maxelem__[] = "__maxelem__";
static PyObject *__pyx_kp___maxelem__;
static char __pyx_k_8[] = "Error";
static PyObject *__pyx_kp_8;
static char __pyx_k_ValueError[] = "ValueError";
static PyObject *__pyx_kp_ValueError;
static char __pyx_k_tostring[] = "tostring";
static PyObject *__pyx_kp_tostring;
static char __pyx_k_decompress[] = "decompress";
static PyObject *__pyx_kp_decompress;
static char __pyx_k_Exception[] = "Exception";
static PyObject *__pyx_kp_Exception;
static char __pyx_k_12[] = "__iter__";
static PyObject *__pyx_kp_12;
static char __pyx_k_max[] = "max";
static PyObject *__pyx_kp_max;
static char __pyx_k_OverflowError[] = "OverflowError";
static PyObject *__pyx_kp_OverflowError;
static char __pyx_k_TypeError[] = "TypeError";
static PyObject *__pyx_kp_TypeError;
static char __pyx_k_endswith[] = "endswith";
static PyObject *__pyx_kp_endswith;
static char __pyx_k___le__[] = "__le__";
static PyObject *__pyx_kp___le__;
static char __pyx_k___ge__[] = "__ge__";
static PyObject *__pyx_kp___ge__;
static char __pyx_k_compress[] = "compress";
static PyObject *__pyx_kp_compress;
static char __pyx_k_KeyError[] = "KeyError";
static PyObject *__pyx_kp_KeyError;
static char __pyx_k_iteritems[] = "iteritems";
static PyObject *__pyx_kp_iteritems;
static char __pyx_k_AttributeError[] = "AttributeError";
static PyObject *__pyx_kp_AttributeError;
static char __pyx_k_IndexError[] = "IndexError";
static PyObject *__pyx_kp_IndexError;
static char __pyx_k_append[] = "append";
static PyObject *__pyx_kp_append;
static char __pyx_k_StopIteration[] = "StopIteration";
static PyObject *__pyx_kp_StopIteration;
static char __pyx_k_MemoryError[] = "MemoryError";
static PyObject *__pyx_kp_MemoryError;
static PyObject *__pyx_kp_3;
static PyObject *__pyx_builtin_ValueError;
static PyObject *__pyx_builtin_Exception;
static PyObject *__pyx_builtin_max;
static PyObject *__pyx_builtin_OverflowError;
static PyObject *__pyx_builtin_TypeError;
static PyObject *__pyx_builtin_KeyError;
static PyObject *__pyx_builtin_AttributeError;
static PyObject *__pyx_builtin_IndexError;
static PyObject *__pyx_builtin_StopIteration;
static PyObject *__pyx_builtin_MemoryError;
static PyObject *__pyx_kp_9;
static PyObject *__pyx_kp_10;
static PyObject *__pyx_kp_11;
static PyObject *__pyx_kp_13;
static PyObject *__pyx_kp_14;
static PyObject *__pyx_kp_15;
static PyObject *__pyx_kp_16;
static PyObject *__pyx_kp_17;
static PyObject *__pyx_kp_18;
static PyObject *__pyx_kp_19;
static PyObject *__pyx_kp_20;
static PyObject *__pyx_kp_21;
static PyObject *__pyx_kp_22;
static PyObject *__pyx_kp_23;
static char __pyx_k_9[] = "rhs can't be negative";
static char __pyx_k_10[] = "Buffer error!!!";
static char __pyx_k_11[] = "rhs is corrupted: %s";
static char __pyx_k_13[] = "Can't integers bigger than %s";
static char __pyx_k_14[] = "Negative numbers, not allowed";
static char __pyx_k_15[] = "Elements must be <= %s";
static char __pyx_k_16[] = "Negative numbers, not allowed";
static char __pyx_k_17[] = "Elements must be <= %s";
static char __pyx_k_18[] = "Negative numbers, not allowed";
static char __pyx_k_19[] = "Elements must be <= %s";
static char __pyx_k_20[] = "Negative numbers, not allowed";
static char __pyx_k_21[] = "Elements must be <= %s";
static char __pyx_k_22[] = "retrieving integers from rhs is impossible: %s";
static char __pyx_k_23[] = "rhs is of unknown type %s";
static PyObject *__pyx_kp_24;
static PyObject *__pyx_kp_25;
static char __pyx_k_24[] = "Negative numbers, not allowed";
static char __pyx_k_25[] = "Element must be <= %s";
static PyObject *__pyx_kp_26;
static char __pyx_k_26[] = "cannot compare intbitset using cmp()";
static PyObject *__pyx_kp_27;
static PyObject *__pyx_kp_28;
static PyObject *__pyx_kp_29;
static PyObject *__pyx_kp_30;
static PyObject *__pyx_kp_31;
static PyObject *__pyx_kp_32;
static char __pyx_k_27[] = "Negative numbers, not allowed";
static char __pyx_k_28[] = "rhs must be <= %s";
static char __pyx_k_29[] = "Negative numbers, not allowed";
static char __pyx_k_30[] = "Elements must be <= %s";
static char __pyx_k_31[] = "Negative numbers, not allowed";
static char __pyx_k_32[] = "Elements must be <= %s";
static PyObject *__pyx_kp_33;
static PyObject *__pyx_kp_34;
static PyObject *__pyx_kp_35;
static PyObject *__pyx_kp_36;
static char __pyx_k_33[] = "Negative numbers, not allowed";
static char __pyx_k_34[] = "rhs must be <= %s";
static char __pyx_k_35[] = "Negative numbers, not allowed";
static char __pyx_k_36[] = "Elements must be <= %s";
static PyObject *__pyx_kp_37;
static PyObject *__pyx_kp_38;
static char __pyx_k_37[] = "Negative numbers, not allowed";
static char __pyx_k_38[] = "Element must be <= %s";
static PyObject *__pyx_kp_39;
static PyObject *__pyx_kp_40;
static PyObject *__pyx_kp_41;
static PyObject *__pyx_kp_42;
static PyObject *__pyx_kp_43;
static PyObject *__pyx_kp_44;
static PyObject *__pyx_kp_45;
static PyObject *__pyx_kp_46;
static char __pyx_k_39[] = "intbitset([";
static char __pyx_k_40[] = "%i, ";
static char __pyx_k_41[] = ", ";
static char __pyx_k_42[] = "], trailing_bits=True)";
static char __pyx_k_43[] = "intbitset([";
static char __pyx_k_44[] = "%i, ";
static char __pyx_k_45[] = ", ";
static char __pyx_k_46[] = "])";
static PyObject *__pyx_kp_47;
static PyObject *__pyx_kp_48;
static PyObject *__pyx_kp_49;
static PyObject *__pyx_kp_50;
static PyObject *__pyx_kp_51;
static PyObject *__pyx_kp_52;
static PyObject *__pyx_kp_53;
static PyObject *__pyx_kp_54;
static char __pyx_k_47[] = "intbitset([";
static char __pyx_k_48[] = "%i, ";
static char __pyx_k_49[] = "...])";
static char __pyx_k_50[] = "intbitset([";
static char __pyx_k_51[] = "%i, ";
static char __pyx_k_52[] = "..., ";
static char __pyx_k_53[] = "%i, ";
static char __pyx_k_54[] = "])";
static PyObject *__pyx_kp_55;
static char __pyx_k_55[] = "It's impossible to iterate over an infinite set.";
static PyObject *__pyx_kp_56;
static PyObject *__pyx_kp_57;
static char __pyx_k_56[] = "Negative numbers, not allowed";
static char __pyx_k_57[] = "Element must be <= %s";
static PyObject *__pyx_kp_58;
static PyObject *__pyx_kp_59;
static char __pyx_k_58[] = "Negative numbers, not allowed";
static char __pyx_k_59[] = "Element must be <= %s";
static PyObject *__pyx_kp_60;
static char __pyx_k_60[] = "strdump is corrupted";
static PyObject *__pyx_kp_61;
static char __pyx_k_61[] = "pop from an empty intbitset";
static PyObject *__pyx_kp_62;
static PyObject *__pyx_kp_63;
static char __pyx_k_62[] = "Negative numbers, not allowed";
static char __pyx_k_63[] = "Elements must be <= %s";
static PyObject *__pyx_kp_64;
static PyObject *__pyx_kp_65;
static PyObject *__pyx_kp_66;
static PyObject *__pyx_kp_67;
static char __pyx_k_64[] = "It's impossible to print an infinite set.";
static char __pyx_k_65[] = "";
static char __pyx_k_66[] = "0";
static char __pyx_k_67[] = "1";
static PyObject *__pyx_kp_68;
static PyObject *__pyx_kp_69;
static PyObject *__pyx_kp_70;
static char __pyx_k_68[] = "Negative numbers, not allowed";
static char __pyx_k_69[] = "Elements must <= %s";
static char __pyx_k_70[] = "rhs should be a valid dictionary with integers keys and integer values";
static PyObject *__pyx_kp_71;
static PyObject *__pyx_kp_72;
static PyObject *__pyx_kp_73;
static char __pyx_k_71[] = "It's impossible to retrieve a negative item from an infinite set.";
static char __pyx_k_72[] = "Index must be <= %s";
static char __pyx_k_73[] = "intbitset index out of range";
static PyObject *__pyx_kp_74;
static PyObject *__pyx_kp_75;
static char __pyx_k_74[] = "It's impossible to retrieve a sublist using negative indices from an infinite set.";
static char __pyx_k_75[] = "Indexes must be <= %s";
static PyObject *__pyx_kp_76;
static char __pyx_k_76[] = "up_to must be <= %s";
static PyObject *__pyx_kp_77;
static char __pyx_k_77[] = "It's impossible to retrieve a list of an infinite set";
static PyObject *__pyx_kp_78;
static char __pyx_k_78[] = "intbitset corrupted: allocated: %s, size: %s";

/* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":135
 *     cdef bint sanity_checks
 * 
 *     def __cinit__(self, rhs=0, int preallocate=-1, int trailing_bits=0, bint sanity_checks=CFG_INTBITSET_ENABLE_SANITY_CHECKS, int no_allocate=0):             # <<<<<<<<<<<<<<
 *         """
 *         Initialize intbitset.
 */

static int __pyx_pf_3lib_9intbitset_9intbitset___cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_3lib_9intbitset_9intbitset___cinit__[] = "\n        Initialize intbitset.\n        * rhs can be:\n         - int/long for creating allocating empty intbitset that will hold at least\n            rhs elements, before being resized\n         - intbitset for cloning\n         - str for retrieving an intbitset that was dumped into a string\n         - array for retrieving an intbitset that was dumped into a string stored\n            in an array\n         - sequence made of integers for copying all the elements from the\n            sequence. If minsize is specified than it is initially allocated\n            enough space to hold up to minsize integers, otherwise the biggest\n            element of the sequence will be used.\n        * preallocate is a suggested initial upper bound on the numbers that will be\n            stored, by looking at rhs a sequence of number.\n        * trailing_bits is 1, then the set will contain \"all\" the positive integers\n        * no_allocate is used internally and should never be set.\n        after the biggest one added with rhs.\n        ";
static int __pyx_pf_3lib_9intbitset_9intbitset___cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  PyObject *__pyx_v_rhs = 0;
  int __pyx_v_preallocate;
  int __pyx_v_trailing_bits;
  int __pyx_v_sanity_checks;
  int __pyx_v_no_allocate;
  Py_ssize_t __pyx_v_size;
  void *__pyx_v_buf;
  int __pyx_v_elem;
  int __pyx_v_last;
  int __pyx_v_remelem;
  int __pyx_v_tuple_of_tuples;
  PyObject *__pyx_v_msg;
  PyObject *__pyx_v_tmp;
  PyObject *__pyx_v_tmp_tuple;
  int __pyx_r;
  PyObject *__pyx_1 = 0;
  int __pyx_2;
  PyObject *__pyx_3 = 0;
  PyObject *__pyx_4 = 0;
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  int __pyx_t_5;
  int __pyx_t_6;
  PyObject *__pyx_t_7 = NULL;
  Py_ssize_t __pyx_t_8;
  static PyObject **__pyx_pyargnames[] = {&__pyx_kp_rhs,&__pyx_kp_preallocate,&__pyx_kp_trailing_bits,&__pyx_kp_sanity_checks,&__pyx_kp_no_allocate,0};
  __Pyx_SetupRefcountContext("__cinit__");
  if (unlikely(__pyx_kwds)) {
    Py_ssize_t kw_args = PyDict_Size(__pyx_kwds);
    PyObject* values[5] = {0,0,0,0,0};
    values[0] = __pyx_int_0;
    switch (PyTuple_GET_SIZE(__pyx_args)) {
      case  5: values[4] = PyTuple_GET_ITEM(__pyx_args, 4);
      case  4: values[3] = PyTuple_GET_ITEM(__pyx_args, 3);
      case  3: values[2] = PyTuple_GET_ITEM(__pyx_args, 2);
      case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      case  0: break;
      default: goto __pyx_L5_argtuple_error;
    }
    switch (PyTuple_GET_SIZE(__pyx_args)) {
      case  0:
      if (kw_args > 1) {
        PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_kp_rhs);
        if (unlikely(value)) { values[0] = value; kw_args--; }
      }
      case  1:
      if (kw_args > 1) {
        PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_kp_preallocate);
        if (unlikely(value)) { values[1] = value; kw_args--; }
      }
      case  2:
      if (kw_args > 1) {
        PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_kp_trailing_bits);
        if (unlikely(value)) { values[2] = value; kw_args--; }
      }
      case  3:
      if (kw_args > 1) {
        PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_kp_sanity_checks);
        if (unlikely(value)) { values[3] = value; kw_args--; }
      }
      case  4:
      if (kw_args > 1) {
        PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_kp_no_allocate);
        if (unlikely(value)) { values[4] = value; kw_args--; }
      }
    }
    if (unlikely(kw_args > 0)) {
      if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, PyTuple_GET_SIZE(__pyx_args), "__cinit__") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 135; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    }
    __pyx_v_rhs = values[0];
    if (values[1]) {
      __pyx_v_preallocate = __Pyx_PyInt_AsInt(values[1]); if (unlikely((__pyx_v_preallocate == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 135; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_preallocate = -1;
    }
    if (values[2]) {
      __pyx_v_trailing_bits = __Pyx_PyInt_AsInt(values[2]); if (unlikely((__pyx_v_trailing_bits == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 135; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_trailing_bits = 0;
    }
    if (values[3]) {
      __pyx_v_sanity_checks = __Pyx_PyObject_IsTrue(values[3]); if (unlikely((__pyx_v_sanity_checks == (int)-1))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 135; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_sanity_checks = __pyx_k_7;
    }
    if (values[4]) {
      __pyx_v_no_allocate = __Pyx_PyInt_AsInt(values[4]); if (unlikely((__pyx_v_no_allocate == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 135; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_no_allocate = 0;
    }
  } else {
    __pyx_v_rhs = __pyx_int_0;
    __pyx_v_preallocate = -1;
    __pyx_v_trailing_bits = 0;
    __pyx_v_sanity_checks = __pyx_k_7;
    __pyx_v_no_allocate = 0;
    switch (PyTuple_GET_SIZE(__pyx_args)) {
      case  5: __pyx_v_no_allocate = __Pyx_PyInt_AsInt(PyTuple_GET_ITEM(__pyx_args, 4)); if (unlikely((__pyx_v_no_allocate == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 135; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      case  4: __pyx_v_sanity_checks = __Pyx_PyObject_IsTrue(PyTuple_GET_ITEM(__pyx_args, 3)); if (unlikely((__pyx_v_sanity_checks == (int)-1))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 135; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      case  3: __pyx_v_trailing_bits = __Pyx_PyInt_AsInt(PyTuple_GET_ITEM(__pyx_args, 2)); if (unlikely((__pyx_v_trailing_bits == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 135; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      case  2: __pyx_v_preallocate = __Pyx_PyInt_AsInt(PyTuple_GET_ITEM(__pyx_args, 1)); if (unlikely((__pyx_v_preallocate == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 135; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      case  1: __pyx_v_rhs = PyTuple_GET_ITEM(__pyx_args, 0);
      case  0: break;
      default: goto __pyx_L5_argtuple_error;
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__cinit__", 0, 0, 5, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 135; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("lib.intbitset.intbitset.__cinit__");
  return -1;
  __pyx_L4_argument_unpacking_done:;
  __Pyx_INCREF(__pyx_v_rhs);
  __pyx_v_msg = Py_None; __Pyx_INCREF(Py_None);
  __pyx_v_tmp = Py_None; __Pyx_INCREF(Py_None);
  __pyx_v_tmp_tuple = Py_None; __Pyx_INCREF(Py_None);

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":162
 *         cdef int remelem
 *         cdef bint tuple_of_tuples
 *         self.sanity_checks = sanity_checks             # <<<<<<<<<<<<<<
 *         msg = "Error"
 *         self.bitset = NULL
 */
  ((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->sanity_checks = __pyx_v_sanity_checks;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":163
 *         cdef bint tuple_of_tuples
 *         self.sanity_checks = sanity_checks
 *         msg = "Error"             # <<<<<<<<<<<<<<
 *         self.bitset = NULL
 *         if no_allocate:
 */
  __Pyx_INCREF(__pyx_kp_8);
  __Pyx_DECREF(__pyx_v_msg);
  __pyx_v_msg = __pyx_kp_8;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":164
 *         self.sanity_checks = sanity_checks
 *         msg = "Error"
 *         self.bitset = NULL             # <<<<<<<<<<<<<<
 *         if no_allocate:
 *             self.bitset = intBitSetCreateNoAllocate()
 */
  ((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset = NULL;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":165
 *         msg = "Error"
 *         self.bitset = NULL
 *         if no_allocate:             # <<<<<<<<<<<<<<
 *             self.bitset = intBitSetCreateNoAllocate()
 *             return
 */
  __pyx_t_1 = __pyx_v_no_allocate;
  if (__pyx_t_1) {

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":166
 *         self.bitset = NULL
 *         if no_allocate:
 *             self.bitset = intBitSetCreateNoAllocate()             # <<<<<<<<<<<<<<
 *             return
 *         if type(rhs) in (int, long):
 */
    ((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset = intBitSetCreateNoAllocate();

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":167
 *         if no_allocate:
 *             self.bitset = intBitSetCreateNoAllocate()
 *             return             # <<<<<<<<<<<<<<
 *         if type(rhs) in (int, long):
 *             if rhs < 0:
 */
    __pyx_r = 0;
    goto __pyx_L0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":168
 *             self.bitset = intBitSetCreateNoAllocate()
 *             return
 *         if type(rhs) in (int, long):             # <<<<<<<<<<<<<<
 *             if rhs < 0:
 *                 raise ValueError("rhs can't be negative")
 */
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 168; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(((PyObject *)__pyx_t_2));
  __Pyx_INCREF(__pyx_v_rhs);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rhs);
  __Pyx_GIVEREF(__pyx_v_rhs);
  __pyx_t_3 = PyObject_Call(((PyObject *)((PyObject*)&PyType_Type)), ((PyObject *)__pyx_t_2), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 168; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
  __pyx_t_2 = PyObject_RichCompare(__pyx_t_3, ((PyObject *)((PyObject*)&PyInt_Type)), Py_EQ); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 168; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely((__pyx_t_4 == (int)-1))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 168; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (!((int)__pyx_t_4)) {
    __pyx_t_2 = PyObject_RichCompare(__pyx_t_3, ((PyObject *)((PyObject*)&PyLong_Type)), Py_EQ); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 168; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_5 = __Pyx_PyObject_IsTrue(__pyx_t_2); if (unlikely((__pyx_t_5 == (int)-1))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 168; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_6 = ((int)__pyx_t_5);
  } else {
    __pyx_t_6 = ((int)__pyx_t_4);
  }
  __pyx_t_4 = __pyx_t_6;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (__pyx_t_4) {

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":169
 *             return
 *         if type(rhs) in (int, long):
 *             if rhs < 0:             # <<<<<<<<<<<<<<
 *                 raise ValueError("rhs can't be negative")
 *             self.bitset = intBitSetCreate(rhs, trailing_bits)
 */
    __pyx_t_3 = PyObject_RichCompare(__pyx_v_rhs, __pyx_int_0, Py_LT); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 169; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_4 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 169; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    if (__pyx_t_4) {

      /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":170
 *         if type(rhs) in (int, long):
 *             if rhs < 0:
 *                 raise ValueError("rhs can't be negative")             # <<<<<<<<<<<<<<
 *             self.bitset = intBitSetCreate(rhs, trailing_bits)
 *         elif type(rhs) is intbitset:
 */
      __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 170; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(((PyObject *)__pyx_t_3));
      __Pyx_INCREF(__pyx_kp_9);
      PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_kp_9);
      __Pyx_GIVEREF(__pyx_kp_9);
      __pyx_t_2 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 170; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
      __Pyx_Raise(__pyx_t_2, 0, 0);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 170; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      goto __pyx_L8;
    }
    __pyx_L8:;

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":171
 *             if rhs < 0:
 *                 raise ValueError("rhs can't be negative")
 *             self.bitset = intBitSetCreate(rhs, trailing_bits)             # <<<<<<<<<<<<<<
 *         elif type(rhs) is intbitset:
 *             self.bitset = intBitSetClone((<intbitset>rhs).bitset)
 */
    __pyx_t_1 = __Pyx_PyInt_AsInt(__pyx_v_rhs); if (unlikely((__pyx_t_1 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 171; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    ((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset = intBitSetCreate(__pyx_t_1, __pyx_v_trailing_bits);
    goto __pyx_L7;
  }

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":172
 *                 raise ValueError("rhs can't be negative")
 *             self.bitset = intBitSetCreate(rhs, trailing_bits)
 *         elif type(rhs) is intbitset:             # <<<<<<<<<<<<<<
 *             self.bitset = intBitSetClone((<intbitset>rhs).bitset)
 *         elif type(rhs) in (str, array):
 */
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 172; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(((PyObject *)__pyx_t_2));
  __Pyx_INCREF(__pyx_v_rhs);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rhs);
  __Pyx_GIVEREF(__pyx_v_rhs);
  __pyx_t_3 = PyObject_Call(((PyObject *)((PyObject*)&PyType_Type)), ((PyObject *)__pyx_t_2), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 172; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
  __pyx_t_4 = (__pyx_t_3 == ((PyObject *)((PyObject*)__pyx_ptype_3lib_9intbitset_intbitset)));
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (__pyx_t_4) {

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":173
 *             self.bitset = intBitSetCreate(rhs, trailing_bits)
 *         elif type(rhs) is intbitset:
 *             self.bitset = intBitSetClone((<intbitset>rhs).bitset)             # <<<<<<<<<<<<<<
 *         elif type(rhs) in (str, array):
 *             try:
 */
    ((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset = intBitSetClone(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_rhs)->bitset);
    goto __pyx_L7;
  }

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":174
 *         elif type(rhs) is intbitset:
 *             self.bitset = intBitSetClone((<intbitset>rhs).bitset)
 *         elif type(rhs) in (str, array):             # <<<<<<<<<<<<<<
 *             try:
 *                 if type(rhs) is array:
 */
  __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 174; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(((PyObject *)__pyx_t_3));
  __Pyx_INCREF(__pyx_v_rhs);
  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_rhs);
  __Pyx_GIVEREF(__pyx_v_rhs);
  __pyx_t_2 = PyObject_Call(((PyObject *)((PyObject*)&PyType_Type)), ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 174; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
  __pyx_t_3 = PyObject_RichCompare(__pyx_t_2, ((PyObject *)((PyObject*)&PyString_Type)), Py_EQ); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 174; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely((__pyx_t_4 == (int)-1))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 174; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  if (!((int)__pyx_t_4)) {
    __pyx_1 = __Pyx_GetName(__pyx_m, __pyx_kp_array); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 174; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_1);
    __pyx_t_3 = PyObject_RichCompare(__pyx_t_2, __pyx_1, Py_EQ); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 174; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
    __pyx_t_6 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely((__pyx_t_6 == (int)-1))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 174; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_5 = ((int)__pyx_t_6);
  } else {
    __pyx_t_5 = ((int)__pyx_t_4);
  }
  __pyx_t_4 = __pyx_t_5;
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  if (__pyx_t_4) {

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":175
 *             self.bitset = intBitSetClone((<intbitset>rhs).bitset)
 *         elif type(rhs) in (str, array):
 *             try:             # <<<<<<<<<<<<<<
 *                 if type(rhs) is array:
 *                     rhs = rhs.tostring()
 */
    {
      PyObject *__pyx_save_exc_type, *__pyx_save_exc_value, *__pyx_save_exc_tb;
      __Pyx_ExceptionSave(&__pyx_save_exc_type, &__pyx_save_exc_value, &__pyx_save_exc_tb);
      __Pyx_XGOTREF(__pyx_save_exc_type);
      __Pyx_XGOTREF(__pyx_save_exc_value);
      __Pyx_XGOTREF(__pyx_save_exc_tb);
      /*try:*/ {

        /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":176
 *         elif type(rhs) in (str, array):
 *             try:
 *                 if type(rhs) is array:             # <<<<<<<<<<<<<<
 *                     rhs = rhs.tostring()
 *                 tmp = zlib.decompress(rhs)
 */
        __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 176; __pyx_clineno = __LINE__; goto __pyx_L9_error;}
        __Pyx_GOTREF(((PyObject *)__pyx_t_2));
        __Pyx_INCREF(__pyx_v_rhs);
        PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rhs);
        __Pyx_GIVEREF(__pyx_v_rhs);
        __pyx_t_3 = PyObject_Call(((PyObject *)((PyObject*)&PyType_Type)), ((PyObject *)__pyx_t_2), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 176; __pyx_clineno = __LINE__; goto __pyx_L9_error;}
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
        __pyx_1 = __Pyx_GetName(__pyx_m, __pyx_kp_array); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 176; __pyx_clineno = __LINE__; goto __pyx_L9_error;}
        __Pyx_GOTREF(__pyx_1);
        __pyx_t_4 = (__pyx_t_3 == __pyx_1);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
        if (__pyx_t_4) {

          /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":177
 *             try:
 *                 if type(rhs) is array:
 *                     rhs = rhs.tostring()             # <<<<<<<<<<<<<<
 *                 tmp = zlib.decompress(rhs)
 *                 if PyObject_AsReadBuffer(tmp, &buf, &size) < 0:
 */
          __pyx_t_3 = PyObject_GetAttr(__pyx_v_rhs, __pyx_kp_tostring); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 177; __pyx_clineno = __LINE__; goto __pyx_L9_error;}
          __Pyx_GOTREF(__pyx_t_3);
          __pyx_t_2 = PyObject_Call(__pyx_t_3, ((PyObject *)__pyx_empty_tuple), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 177; __pyx_clineno = __LINE__; goto __pyx_L9_error;}
          __Pyx_GOTREF(__pyx_t_2);
          __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
          __Pyx_DECREF(__pyx_v_rhs);
          __pyx_v_rhs = __pyx_t_2;
          __pyx_t_2 = 0;
          goto __pyx_L17;
        }
        __pyx_L17:;

        /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":178
 *                 if type(rhs) is array:
 *                     rhs = rhs.tostring()
 *                 tmp = zlib.decompress(rhs)             # <<<<<<<<<<<<<<
 *                 if PyObject_AsReadBuffer(tmp, &buf, &size) < 0:
 *                     raise Exception("Buffer error!!!")
 */
        __pyx_1 = __Pyx_GetName(__pyx_m, __pyx_kp_zlib); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 178; __pyx_clineno = __LINE__; goto __pyx_L9_error;}
        __Pyx_GOTREF(__pyx_1);
        __pyx_t_2 = PyObject_GetAttr(__pyx_1, __pyx_kp_decompress); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 178; __pyx_clineno = __LINE__; goto __pyx_L9_error;}
        __Pyx_GOTREF(__pyx_t_2);
        __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
        __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 178; __pyx_clineno = __LINE__; goto __pyx_L9_error;}
        __Pyx_GOTREF(((PyObject *)__pyx_t_3));
        __Pyx_INCREF(__pyx_v_rhs);
        PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_rhs);
        __Pyx_GIVEREF(__pyx_v_rhs);
        __pyx_t_7 = PyObject_Call(__pyx_t_2, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 178; __pyx_clineno = __LINE__; goto __pyx_L9_error;}
        __Pyx_GOTREF(__pyx_t_7);
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
        __Pyx_DECREF(__pyx_v_tmp);
        __pyx_v_tmp = __pyx_t_7;
        __pyx_t_7 = 0;

        /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":179
 *                     rhs = rhs.tostring()
 *                 tmp = zlib.decompress(rhs)
 *                 if PyObject_AsReadBuffer(tmp, &buf, &size) < 0:             # <<<<<<<<<<<<<<
 *                     raise Exception("Buffer error!!!")
 *                 self.bitset = intBitSetCreateFromBuffer(buf, size)
 */
        __pyx_t_4 = (PyObject_AsReadBuffer(__pyx_v_tmp, (&__pyx_v_buf), (&__pyx_v_size)) < 0);
        if (__pyx_t_4) {

          /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":180
 *                 tmp = zlib.decompress(rhs)
 *                 if PyObject_AsReadBuffer(tmp, &buf, &size) < 0:
 *                     raise Exception("Buffer error!!!")             # <<<<<<<<<<<<<<
 *                 self.bitset = intBitSetCreateFromBuffer(buf, size)
 *             except Exception, msg:
 */
          __pyx_t_7 = PyTuple_New(1); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 180; __pyx_clineno = __LINE__; goto __pyx_L9_error;}
          __Pyx_GOTREF(((PyObject *)__pyx_t_7));
          __Pyx_INCREF(__pyx_kp_10);
          PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_kp_10);
          __Pyx_GIVEREF(__pyx_kp_10);
          __pyx_t_3 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_t_7), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 180; __pyx_clineno = __LINE__; goto __pyx_L9_error;}
          __Pyx_GOTREF(__pyx_t_3);
          __Pyx_DECREF(((PyObject *)__pyx_t_7)); __pyx_t_7 = 0;
          __Pyx_Raise(__pyx_t_3, 0, 0);
          __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
          {__pyx_filename = __pyx_f[0]; __pyx_lineno = 180; __pyx_clineno = __LINE__; goto __pyx_L9_error;}
          goto __pyx_L18;
        }
        __pyx_L18:;

        /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":181
 *                 if PyObject_AsReadBuffer(tmp, &buf, &size) < 0:
 *                     raise Exception("Buffer error!!!")
 *                 self.bitset = intBitSetCreateFromBuffer(buf, size)             # <<<<<<<<<<<<<<
 *             except Exception, msg:
 *                 raise ValueError("rhs is corrupted: %s" % msg)
 */
        ((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset = intBitSetCreateFromBuffer(__pyx_v_buf, __pyx_v_size);
      }
      __Pyx_XDECREF(__pyx_save_exc_type); __pyx_save_exc_type = 0;
      __Pyx_XDECREF(__pyx_save_exc_value); __pyx_save_exc_value = 0;
      __Pyx_XDECREF(__pyx_save_exc_tb); __pyx_save_exc_tb = 0;
      goto __pyx_L16_try_end;
      __pyx_L9_error:;
      __Pyx_XDECREF(__pyx_1); __pyx_1 = 0;
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;
      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;

      /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":182
 *                     raise Exception("Buffer error!!!")
 *                 self.bitset = intBitSetCreateFromBuffer(buf, size)
 *             except Exception, msg:             # <<<<<<<<<<<<<<
 *                 raise ValueError("rhs is corrupted: %s" % msg)
 *         elif hasattr(rhs, '__iter__'):
 */
      __pyx_2 = PyErr_ExceptionMatches(__pyx_builtin_Exception);
      if (__pyx_2) {
        __Pyx_AddTraceback("lib.intbitset.__cinit__");
        if (__Pyx_GetException(&__pyx_1, &__pyx_3, &__pyx_4) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 182; __pyx_clineno = __LINE__; goto __pyx_L11_except_error;}
        __Pyx_GOTREF(__pyx_1);
        __Pyx_GOTREF(__pyx_3);
        __Pyx_GOTREF(__pyx_4);
        __Pyx_INCREF(__pyx_3);
        __Pyx_DECREF(__pyx_v_msg);
        __pyx_v_msg = __pyx_3;

        /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":183
 *                 self.bitset = intBitSetCreateFromBuffer(buf, size)
 *             except Exception, msg:
 *                 raise ValueError("rhs is corrupted: %s" % msg)             # <<<<<<<<<<<<<<
 *         elif hasattr(rhs, '__iter__'):
 *             tuple_of_tuples = rhs and type(rhs[0]) is tuple
 */
        __pyx_t_3 = PyNumber_Remainder(__pyx_kp_11, __pyx_v_msg); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 183; __pyx_clineno = __LINE__; goto __pyx_L11_except_error;}
        __Pyx_GOTREF(__pyx_t_3);
        __pyx_t_7 = PyTuple_New(1); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 183; __pyx_clineno = __LINE__; goto __pyx_L11_except_error;}
        __Pyx_GOTREF(((PyObject *)__pyx_t_7));
        PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_t_3);
        __Pyx_GIVEREF(__pyx_t_3);
        __pyx_t_3 = 0;
        __pyx_t_3 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_t_7), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 183; __pyx_clineno = __LINE__; goto __pyx_L11_except_error;}
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_DECREF(((PyObject *)__pyx_t_7)); __pyx_t_7 = 0;
        __Pyx_Raise(__pyx_t_3, 0, 0);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        {__pyx_filename = __pyx_f[0]; __pyx_lineno = 183; __pyx_clineno = __LINE__; goto __pyx_L11_except_error;}
        __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
        __Pyx_DECREF(__pyx_3); __pyx_3 = 0;
        __Pyx_DECREF(__pyx_4); __pyx_4 = 0;
        goto __pyx_L10_exception_handled;
      }
      __pyx_L11_except_error:;
      __Pyx_XDECREF(__pyx_save_exc_type);
      __Pyx_XDECREF(__pyx_save_exc_value);
      __Pyx_XDECREF(__pyx_save_exc_tb);
      goto __pyx_L1_error;
      __pyx_L10_exception_handled:;
      __Pyx_XGIVEREF(__pyx_save_exc_type);
      __Pyx_XGIVEREF(__pyx_save_exc_value);
      __Pyx_XGIVEREF(__pyx_save_exc_tb);
      __Pyx_ExceptionReset(__pyx_save_exc_type, __pyx_save_exc_value, __pyx_save_exc_tb);
      __pyx_L16_try_end:;
    }
    goto __pyx_L7;
  }

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":184
 *             except Exception, msg:
 *                 raise ValueError("rhs is corrupted: %s" % msg)
 *         elif hasattr(rhs, '__iter__'):             # <<<<<<<<<<<<<<
 *             tuple_of_tuples = rhs and type(rhs[0]) is tuple
 *             try:
 */
  __pyx_t_4 = PyObject_HasAttr(__pyx_v_rhs, __pyx_kp_12); if (unlikely(__pyx_t_4 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 184; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__pyx_t_4) {

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":185
 *                 raise ValueError("rhs is corrupted: %s" % msg)
 *         elif hasattr(rhs, '__iter__'):
 *             tuple_of_tuples = rhs and type(rhs[0]) is tuple             # <<<<<<<<<<<<<<
 *             try:
 *                 if preallocate < 0:
 */
    __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_v_rhs); if (unlikely(__pyx_t_4 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 185; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    if (__pyx_t_4) {
      __pyx_1 = __Pyx_GetItemInt(__pyx_v_rhs, 0, sizeof(long), PyInt_FromLong); if (!__pyx_1) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 185; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_1);
      __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 185; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(((PyObject *)__pyx_t_3));
      PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_1);
      __Pyx_GIVEREF(__pyx_1);
      __pyx_1 = 0;
      __pyx_t_7 = PyObject_Call(((PyObject *)((PyObject*)&PyType_Type)), ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 185; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_7);
      __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
      __pyx_t_4 = (__pyx_t_7 == ((PyObject *)((PyObject*)&PyTuple_Type)));
      __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
      __pyx_t_7 = __Pyx_PyBool_FromLong(__pyx_t_4); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 185; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_7);
      __pyx_t_3 = __pyx_t_7;
      __pyx_t_7 = 0;
    } else {
      __Pyx_INCREF(__pyx_v_rhs);
      __pyx_t_3 = __pyx_v_rhs;
    }
    __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely((__pyx_t_4 == (int)-1))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 185; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_v_tuple_of_tuples = __pyx_t_4;

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":186
 *         elif hasattr(rhs, '__iter__'):
 *             tuple_of_tuples = rhs and type(rhs[0]) is tuple
 *             try:             # <<<<<<<<<<<<<<
 *                 if preallocate < 0:
 *                     if rhs and type(rhs[0]) is int:
 */
    {
      PyObject *__pyx_save_exc_type, *__pyx_save_exc_value, *__pyx_save_exc_tb;
      __Pyx_ExceptionSave(&__pyx_save_exc_type, &__pyx_save_exc_value, &__pyx_save_exc_tb);
      __Pyx_XGOTREF(__pyx_save_exc_type);
      __Pyx_XGOTREF(__pyx_save_exc_value);
      __Pyx_XGOTREF(__pyx_save_exc_tb);
      /*try:*/ {

        /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":187
 *             tuple_of_tuples = rhs and type(rhs[0]) is tuple
 *             try:
 *                 if preallocate < 0:             # <<<<<<<<<<<<<<
 *                     if rhs and type(rhs[0]) is int:
 *                         preallocate = max(rhs)
 */
        __pyx_t_4 = (__pyx_v_preallocate < 0);
        if (__pyx_t_4) {

          /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":188
 *             try:
 *                 if preallocate < 0:
 *                     if rhs and type(rhs[0]) is int:             # <<<<<<<<<<<<<<
 *                         preallocate = max(rhs)
 *                     else:
 */
          __pyx_t_4 = __Pyx_PyObject_IsTrue(__pyx_v_rhs); if (unlikely(__pyx_t_4 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 188; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
          if (__pyx_t_4) {
            __pyx_3 = __Pyx_GetItemInt(__pyx_v_rhs, 0, sizeof(long), PyInt_FromLong); if (!__pyx_3) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 188; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
            __Pyx_GOTREF(__pyx_3);
            __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 188; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
            __Pyx_GOTREF(((PyObject *)__pyx_t_3));
            PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_3);
            __Pyx_GIVEREF(__pyx_3);
            __pyx_3 = 0;
            __pyx_t_7 = PyObject_Call(((PyObject *)((PyObject*)&PyType_Type)), ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 188; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
            __Pyx_GOTREF(__pyx_t_7);
            __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
            __pyx_t_5 = (__pyx_t_7 == ((PyObject *)((PyObject*)&PyInt_Type)));
            __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
            __pyx_t_6 = __pyx_t_5;
          } else {
            __pyx_t_6 = __pyx_t_4;
          }
          if (__pyx_t_6) {

            /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":189
 *                 if preallocate < 0:
 *                     if rhs and type(rhs[0]) is int:
 *                         preallocate = max(rhs)             # <<<<<<<<<<<<<<
 *                     else:
 *                         preallocate = 0
 */
            __pyx_t_7 = PyTuple_New(1); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 189; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
            __Pyx_GOTREF(((PyObject *)__pyx_t_7));
            __Pyx_INCREF(__pyx_v_rhs);
            PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_v_rhs);
            __Pyx_GIVEREF(__pyx_v_rhs);
            __pyx_t_3 = PyObject_Call(__pyx_builtin_max, ((PyObject *)__pyx_t_7), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 189; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
            __Pyx_GOTREF(__pyx_t_3);
            __Pyx_DECREF(((PyObject *)__pyx_t_7)); __pyx_t_7 = 0;
            __pyx_t_1 = __Pyx_PyInt_AsInt(__pyx_t_3); if (unlikely((__pyx_t_1 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 189; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
            __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
            __pyx_v_preallocate = __pyx_t_1;
            goto __pyx_L30;
          }
          /*else*/ {

            /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":191
 *                         preallocate = max(rhs)
 *                     else:
 *                         preallocate = 0             # <<<<<<<<<<<<<<
 *                 if self.sanity_checks:
 *                     if not (0 <= preallocate < maxelem):
 */
            __pyx_v_preallocate = 0;
          }
          __pyx_L30:;
          goto __pyx_L29;
        }
        __pyx_L29:;

        /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":192
 *                     else:
 *                         preallocate = 0
 *                 if self.sanity_checks:             # <<<<<<<<<<<<<<
 *                     if not (0 <= preallocate < maxelem):
 *                         raise OverflowError("Can't integers bigger than %s" % maxelem)
 */
        __pyx_t_6 = ((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->sanity_checks;
        if (__pyx_t_6) {

          /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":193
 *                         preallocate = 0
 *                 if self.sanity_checks:
 *                     if not (0 <= preallocate < maxelem):             # <<<<<<<<<<<<<<
 *                         raise OverflowError("Can't integers bigger than %s" % maxelem)
 *                 self.bitset = intBitSetCreate(preallocate, trailing_bits)
 */
          __pyx_t_6 = (0 <= __pyx_v_preallocate);
          if (__pyx_t_6) {
            __pyx_t_6 = (__pyx_v_preallocate < maxelem);
          }
          __pyx_t_4 = (!__pyx_t_6);
          if (__pyx_t_4) {

            /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":194
 *                 if self.sanity_checks:
 *                     if not (0 <= preallocate < maxelem):
 *                         raise OverflowError("Can't integers bigger than %s" % maxelem)             # <<<<<<<<<<<<<<
 *                 self.bitset = intBitSetCreate(preallocate, trailing_bits)
 *                 if trailing_bits:
 */
            __pyx_t_3 = PyInt_FromLong(maxelem); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 194; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
            __Pyx_GOTREF(__pyx_t_3);
            __pyx_t_7 = PyNumber_Remainder(__pyx_kp_13, __pyx_t_3); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 194; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
            __Pyx_GOTREF(__pyx_t_7);
            __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
            __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 194; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
            __Pyx_GOTREF(((PyObject *)__pyx_t_3));
            PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_7);
            __Pyx_GIVEREF(__pyx_t_7);
            __pyx_t_7 = 0;
            __pyx_t_7 = PyObject_Call(__pyx_builtin_OverflowError, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 194; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
            __Pyx_GOTREF(__pyx_t_7);
            __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
            __Pyx_Raise(__pyx_t_7, 0, 0);
            __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
            {__pyx_filename = __pyx_f[0]; __pyx_lineno = 194; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
            goto __pyx_L32;
          }
          __pyx_L32:;
          goto __pyx_L31;
        }
        __pyx_L31:;

        /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":195
 *                     if not (0 <= preallocate < maxelem):
 *                         raise OverflowError("Can't integers bigger than %s" % maxelem)
 *                 self.bitset = intBitSetCreate(preallocate, trailing_bits)             # <<<<<<<<<<<<<<
 *                 if trailing_bits:
 *                     last = 0
 */
        ((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset = intBitSetCreate(__pyx_v_preallocate, __pyx_v_trailing_bits);

        /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":196
 *                         raise OverflowError("Can't integers bigger than %s" % maxelem)
 *                 self.bitset = intBitSetCreate(preallocate, trailing_bits)
 *                 if trailing_bits:             # <<<<<<<<<<<<<<
 *                     last = 0
 *                     if self.sanity_checks:
 */
        __pyx_t_1 = __pyx_v_trailing_bits;
        if (__pyx_t_1) {

          /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":197
 *                 self.bitset = intBitSetCreate(preallocate, trailing_bits)
 *                 if trailing_bits:
 *                     last = 0             # <<<<<<<<<<<<<<
 *                     if self.sanity_checks:
 *                         if tuple_of_tuples:
 */
          __pyx_v_last = 0;

          /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":198
 *                 if trailing_bits:
 *                     last = 0
 *                     if self.sanity_checks:             # <<<<<<<<<<<<<<
 *                         if tuple_of_tuples:
 *                             for tmp_tuple in rhs:
 */
          __pyx_t_4 = ((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->sanity_checks;
          if (__pyx_t_4) {

            /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":199
 *                     last = 0
 *                     if self.sanity_checks:
 *                         if tuple_of_tuples:             # <<<<<<<<<<<<<<
 *                             for tmp_tuple in rhs:
 *                                 elem = tmp_tuple[0]
 */
            __pyx_t_4 = __pyx_v_tuple_of_tuples;
            if (__pyx_t_4) {

              /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":200
 *                     if self.sanity_checks:
 *                         if tuple_of_tuples:
 *                             for tmp_tuple in rhs:             # <<<<<<<<<<<<<<
 *                                 elem = tmp_tuple[0]
 *                                 if elem < 0:
 */
              if (PyList_CheckExact(__pyx_v_rhs) || PyTuple_CheckExact(__pyx_v_rhs)) {
                __pyx_t_8 = 0; __pyx_t_7 = __pyx_v_rhs; __Pyx_INCREF(__pyx_t_7);
              } else {
                __pyx_t_8 = -1; __pyx_t_7 = PyObject_GetIter(__pyx_v_rhs); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 200; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                __Pyx_GOTREF(__pyx_t_7);
              }
              for (;;) {
                if (likely(PyList_CheckExact(__pyx_t_7))) {
                  if (__pyx_t_8 >= PyList_GET_SIZE(__pyx_t_7)) break;
                  __pyx_t_3 = PyList_GET_ITEM(__pyx_t_7, __pyx_t_8); __Pyx_INCREF(__pyx_t_3); __pyx_t_8++;
                } else if (likely(PyTuple_CheckExact(__pyx_t_7))) {
                  if (__pyx_t_8 >= PyTuple_GET_SIZE(__pyx_t_7)) break;
                  __pyx_t_3 = PyTuple_GET_ITEM(__pyx_t_7, __pyx_t_8); __Pyx_INCREF(__pyx_t_3); __pyx_t_8++;
                } else {
                  __pyx_t_3 = PyIter_Next(__pyx_t_7);
                  if (!__pyx_t_3) {
                    if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 200; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                    break;
                  }
                  __Pyx_GOTREF(__pyx_t_3);
                }
                __Pyx_DECREF(__pyx_v_tmp_tuple);
                __pyx_v_tmp_tuple = __pyx_t_3;
                __pyx_t_3 = 0;

                /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":201
 *                         if tuple_of_tuples:
 *                             for tmp_tuple in rhs:
 *                                 elem = tmp_tuple[0]             # <<<<<<<<<<<<<<
 *                                 if elem < 0:
 *                                     raise ValueError("Negative numbers, not allowed")
 */
                __pyx_4 = __Pyx_GetItemInt(__pyx_v_tmp_tuple, 0, sizeof(long), PyInt_FromLong); if (!__pyx_4) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 201; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                __Pyx_GOTREF(__pyx_4);
                __pyx_t_1 = __Pyx_PyInt_AsInt(__pyx_4); if (unlikely((__pyx_t_1 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 201; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                __Pyx_DECREF(__pyx_4); __pyx_4 = 0;
                __pyx_v_elem = __pyx_t_1;

                /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":202
 *                             for tmp_tuple in rhs:
 *                                 elem = tmp_tuple[0]
 *                                 if elem < 0:             # <<<<<<<<<<<<<<
 *                                     raise ValueError("Negative numbers, not allowed")
 *                                 elif elem > maxelem:
 */
                __pyx_t_4 = (__pyx_v_elem < 0);
                if (__pyx_t_4) {

                  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":203
 *                                 elem = tmp_tuple[0]
 *                                 if elem < 0:
 *                                     raise ValueError("Negative numbers, not allowed")             # <<<<<<<<<<<<<<
 *                                 elif elem > maxelem:
 *                                     raise OverflowError("Elements must be <= %s" % maxelem)
 */
                  __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 203; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                  __Pyx_GOTREF(((PyObject *)__pyx_t_3));
                  __Pyx_INCREF(__pyx_kp_14);
                  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_kp_14);
                  __Pyx_GIVEREF(__pyx_kp_14);
                  __pyx_t_2 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 203; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                  __Pyx_GOTREF(__pyx_t_2);
                  __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
                  __Pyx_Raise(__pyx_t_2, 0, 0);
                  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
                  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 203; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                  goto __pyx_L38;
                }

                /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":204
 *                                 if elem < 0:
 *                                     raise ValueError("Negative numbers, not allowed")
 *                                 elif elem > maxelem:             # <<<<<<<<<<<<<<
 *                                     raise OverflowError("Elements must be <= %s" % maxelem)
 *                                 for remelem from last <= remelem < elem:
 */
                __pyx_t_4 = (__pyx_v_elem > maxelem);
                if (__pyx_t_4) {

                  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":205
 *                                     raise ValueError("Negative numbers, not allowed")
 *                                 elif elem > maxelem:
 *                                     raise OverflowError("Elements must be <= %s" % maxelem)             # <<<<<<<<<<<<<<
 *                                 for remelem from last <= remelem < elem:
 *                                     intBitSetDelElem(self.bitset, remelem)
 */
                  __pyx_t_2 = PyInt_FromLong(maxelem); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 205; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                  __Pyx_GOTREF(__pyx_t_2);
                  __pyx_t_3 = PyNumber_Remainder(__pyx_kp_15, __pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 205; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                  __Pyx_GOTREF(__pyx_t_3);
                  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
                  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 205; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                  __Pyx_GOTREF(((PyObject *)__pyx_t_2));
                  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_3);
                  __Pyx_GIVEREF(__pyx_t_3);
                  __pyx_t_3 = 0;
                  __pyx_t_3 = PyObject_Call(__pyx_builtin_OverflowError, ((PyObject *)__pyx_t_2), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 205; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                  __Pyx_GOTREF(__pyx_t_3);
                  __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
                  __Pyx_Raise(__pyx_t_3, 0, 0);
                  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
                  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 205; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                  goto __pyx_L38;
                }
                __pyx_L38:;

                /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":206
 *                                 elif elem > maxelem:
 *                                     raise OverflowError("Elements must be <= %s" % maxelem)
 *                                 for remelem from last <= remelem < elem:             # <<<<<<<<<<<<<<
 *                                     intBitSetDelElem(self.bitset, remelem)
 *                                 last = elem + 1
 */
                __pyx_t_1 = __pyx_v_elem;
                for (__pyx_v_remelem = __pyx_v_last; __pyx_v_remelem < __pyx_t_1; __pyx_v_remelem++) {

                  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":207
 *                                     raise OverflowError("Elements must be <= %s" % maxelem)
 *                                 for remelem from last <= remelem < elem:
 *                                     intBitSetDelElem(self.bitset, remelem)             # <<<<<<<<<<<<<<
 *                                 last = elem + 1
 *                         else:
 */
                  intBitSetDelElem(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset, __pyx_v_remelem);
                }

                /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":208
 *                                 for remelem from last <= remelem < elem:
 *                                     intBitSetDelElem(self.bitset, remelem)
 *                                 last = elem + 1             # <<<<<<<<<<<<<<
 *                         else:
 *                             for elem in rhs:
 */
                __pyx_v_last = (__pyx_v_elem + 1);
              }
              __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
              goto __pyx_L35;
            }
            /*else*/ {

              /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":210
 *                                 last = elem + 1
 *                         else:
 *                             for elem in rhs:             # <<<<<<<<<<<<<<
 *                                 if elem < 0:
 *                                     raise ValueError("Negative numbers, not allowed")
 */
              if (PyList_CheckExact(__pyx_v_rhs) || PyTuple_CheckExact(__pyx_v_rhs)) {
                __pyx_t_8 = 0; __pyx_t_7 = __pyx_v_rhs; __Pyx_INCREF(__pyx_t_7);
              } else {
                __pyx_t_8 = -1; __pyx_t_7 = PyObject_GetIter(__pyx_v_rhs); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 210; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                __Pyx_GOTREF(__pyx_t_7);
              }
              for (;;) {
                if (likely(PyList_CheckExact(__pyx_t_7))) {
                  if (__pyx_t_8 >= PyList_GET_SIZE(__pyx_t_7)) break;
                  __pyx_t_3 = PyList_GET_ITEM(__pyx_t_7, __pyx_t_8); __Pyx_INCREF(__pyx_t_3); __pyx_t_8++;
                } else if (likely(PyTuple_CheckExact(__pyx_t_7))) {
                  if (__pyx_t_8 >= PyTuple_GET_SIZE(__pyx_t_7)) break;
                  __pyx_t_3 = PyTuple_GET_ITEM(__pyx_t_7, __pyx_t_8); __Pyx_INCREF(__pyx_t_3); __pyx_t_8++;
                } else {
                  __pyx_t_3 = PyIter_Next(__pyx_t_7);
                  if (!__pyx_t_3) {
                    if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 210; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                    break;
                  }
                  __Pyx_GOTREF(__pyx_t_3);
                }
                __pyx_t_1 = __Pyx_PyInt_AsInt(__pyx_t_3); if (unlikely((__pyx_t_1 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 210; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
                __pyx_v_elem = __pyx_t_1;

                /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":211
 *                         else:
 *                             for elem in rhs:
 *                                 if elem < 0:             # <<<<<<<<<<<<<<
 *                                     raise ValueError("Negative numbers, not allowed")
 *                                 elif elem > maxelem:
 */
                __pyx_t_4 = (__pyx_v_elem < 0);
                if (__pyx_t_4) {

                  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":212
 *                             for elem in rhs:
 *                                 if elem < 0:
 *                                     raise ValueError("Negative numbers, not allowed")             # <<<<<<<<<<<<<<
 *                                 elif elem > maxelem:
 *                                     raise OverflowError("Elements must be <= %s" % maxelem)
 */
                  __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 212; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                  __Pyx_GOTREF(((PyObject *)__pyx_t_3));
                  __Pyx_INCREF(__pyx_kp_16);
                  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_kp_16);
                  __Pyx_GIVEREF(__pyx_kp_16);
                  __pyx_t_2 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 212; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                  __Pyx_GOTREF(__pyx_t_2);
                  __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
                  __Pyx_Raise(__pyx_t_2, 0, 0);
                  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
                  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 212; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                  goto __pyx_L43;
                }

                /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":213
 *                                 if elem < 0:
 *                                     raise ValueError("Negative numbers, not allowed")
 *                                 elif elem > maxelem:             # <<<<<<<<<<<<<<
 *                                     raise OverflowError("Elements must be <= %s" % maxelem)
 *                                 for remelem from last <= remelem < elem:
 */
                __pyx_t_4 = (__pyx_v_elem > maxelem);
                if (__pyx_t_4) {

                  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":214
 *                                     raise ValueError("Negative numbers, not allowed")
 *                                 elif elem > maxelem:
 *                                     raise OverflowError("Elements must be <= %s" % maxelem)             # <<<<<<<<<<<<<<
 *                                 for remelem from last <= remelem < elem:
 *                                     intBitSetDelElem(self.bitset, remelem)
 */
                  __pyx_t_2 = PyInt_FromLong(maxelem); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 214; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                  __Pyx_GOTREF(__pyx_t_2);
                  __pyx_t_3 = PyNumber_Remainder(__pyx_kp_17, __pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 214; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                  __Pyx_GOTREF(__pyx_t_3);
                  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
                  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 214; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                  __Pyx_GOTREF(((PyObject *)__pyx_t_2));
                  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_3);
                  __Pyx_GIVEREF(__pyx_t_3);
                  __pyx_t_3 = 0;
                  __pyx_t_3 = PyObject_Call(__pyx_builtin_OverflowError, ((PyObject *)__pyx_t_2), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 214; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                  __Pyx_GOTREF(__pyx_t_3);
                  __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
                  __Pyx_Raise(__pyx_t_3, 0, 0);
                  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
                  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 214; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                  goto __pyx_L43;
                }
                __pyx_L43:;

                /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":215
 *                                 elif elem > maxelem:
 *                                     raise OverflowError("Elements must be <= %s" % maxelem)
 *                                 for remelem from last <= remelem < elem:             # <<<<<<<<<<<<<<
 *                                     intBitSetDelElem(self.bitset, remelem)
 *                                 last = elem + 1
 */
                __pyx_t_1 = __pyx_v_elem;
                for (__pyx_v_remelem = __pyx_v_last; __pyx_v_remelem < __pyx_t_1; __pyx_v_remelem++) {

                  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":216
 *                                     raise OverflowError("Elements must be <= %s" % maxelem)
 *                                 for remelem from last <= remelem < elem:
 *                                     intBitSetDelElem(self.bitset, remelem)             # <<<<<<<<<<<<<<
 *                                 last = elem + 1
 *                     else:
 */
                  intBitSetDelElem(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset, __pyx_v_remelem);
                }

                /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":217
 *                                 for remelem from last <= remelem < elem:
 *                                     intBitSetDelElem(self.bitset, remelem)
 *                                 last = elem + 1             # <<<<<<<<<<<<<<
 *                     else:
 *                         if tuple_of_tuples:
 */
                __pyx_v_last = (__pyx_v_elem + 1);
              }
              __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
            }
            __pyx_L35:;
            goto __pyx_L34;
          }
          /*else*/ {

            /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":219
 *                                 last = elem + 1
 *                     else:
 *                         if tuple_of_tuples:             # <<<<<<<<<<<<<<
 *                             for tmp_tuple in rhs:
 *                                 elem = tmp_tuple[0]
 */
            __pyx_t_4 = __pyx_v_tuple_of_tuples;
            if (__pyx_t_4) {

              /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":220
 *                     else:
 *                         if tuple_of_tuples:
 *                             for tmp_tuple in rhs:             # <<<<<<<<<<<<<<
 *                                 elem = tmp_tuple[0]
 *                                 for remelem from last <= remelem < elem:
 */
              if (PyList_CheckExact(__pyx_v_rhs) || PyTuple_CheckExact(__pyx_v_rhs)) {
                __pyx_t_8 = 0; __pyx_t_7 = __pyx_v_rhs; __Pyx_INCREF(__pyx_t_7);
              } else {
                __pyx_t_8 = -1; __pyx_t_7 = PyObject_GetIter(__pyx_v_rhs); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 220; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                __Pyx_GOTREF(__pyx_t_7);
              }
              for (;;) {
                if (likely(PyList_CheckExact(__pyx_t_7))) {
                  if (__pyx_t_8 >= PyList_GET_SIZE(__pyx_t_7)) break;
                  __pyx_t_3 = PyList_GET_ITEM(__pyx_t_7, __pyx_t_8); __Pyx_INCREF(__pyx_t_3); __pyx_t_8++;
                } else if (likely(PyTuple_CheckExact(__pyx_t_7))) {
                  if (__pyx_t_8 >= PyTuple_GET_SIZE(__pyx_t_7)) break;
                  __pyx_t_3 = PyTuple_GET_ITEM(__pyx_t_7, __pyx_t_8); __Pyx_INCREF(__pyx_t_3); __pyx_t_8++;
                } else {
                  __pyx_t_3 = PyIter_Next(__pyx_t_7);
                  if (!__pyx_t_3) {
                    if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 220; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                    break;
                  }
                  __Pyx_GOTREF(__pyx_t_3);
                }
                __Pyx_DECREF(__pyx_v_tmp_tuple);
                __pyx_v_tmp_tuple = __pyx_t_3;
                __pyx_t_3 = 0;

                /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":221
 *                         if tuple_of_tuples:
 *                             for tmp_tuple in rhs:
 *                                 elem = tmp_tuple[0]             # <<<<<<<<<<<<<<
 *                                 for remelem from last <= remelem < elem:
 *                                     intBitSetDelElem(self.bitset, remelem)
 */
                __pyx_1 = __Pyx_GetItemInt(__pyx_v_tmp_tuple, 0, sizeof(long), PyInt_FromLong); if (!__pyx_1) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 221; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                __Pyx_GOTREF(__pyx_1);
                __pyx_t_1 = __Pyx_PyInt_AsInt(__pyx_1); if (unlikely((__pyx_t_1 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 221; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
                __pyx_v_elem = __pyx_t_1;

                /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":222
 *                             for tmp_tuple in rhs:
 *                                 elem = tmp_tuple[0]
 *                                 for remelem from last <= remelem < elem:             # <<<<<<<<<<<<<<
 *                                     intBitSetDelElem(self.bitset, remelem)
 *                                 last = elem + 1
 */
                __pyx_t_1 = __pyx_v_elem;
                for (__pyx_v_remelem = __pyx_v_last; __pyx_v_remelem < __pyx_t_1; __pyx_v_remelem++) {

                  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":223
 *                                 elem = tmp_tuple[0]
 *                                 for remelem from last <= remelem < elem:
 *                                     intBitSetDelElem(self.bitset, remelem)             # <<<<<<<<<<<<<<
 *                                 last = elem + 1
 *                         else:
 */
                  intBitSetDelElem(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset, __pyx_v_remelem);
                }

                /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":224
 *                                 for remelem from last <= remelem < elem:
 *                                     intBitSetDelElem(self.bitset, remelem)
 *                                 last = elem + 1             # <<<<<<<<<<<<<<
 *                         else:
 *                             for elem in rhs:
 */
                __pyx_v_last = (__pyx_v_elem + 1);
              }
              __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
              goto __pyx_L46;
            }
            /*else*/ {

              /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":226
 *                                 last = elem + 1
 *                         else:
 *                             for elem in rhs:             # <<<<<<<<<<<<<<
 *                                 for remelem from last <= remelem < elem:
 *                                     intBitSetDelElem(self.bitset, remelem)
 */
              if (PyList_CheckExact(__pyx_v_rhs) || PyTuple_CheckExact(__pyx_v_rhs)) {
                __pyx_t_8 = 0; __pyx_t_7 = __pyx_v_rhs; __Pyx_INCREF(__pyx_t_7);
              } else {
                __pyx_t_8 = -1; __pyx_t_7 = PyObject_GetIter(__pyx_v_rhs); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 226; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                __Pyx_GOTREF(__pyx_t_7);
              }
              for (;;) {
                if (likely(PyList_CheckExact(__pyx_t_7))) {
                  if (__pyx_t_8 >= PyList_GET_SIZE(__pyx_t_7)) break;
                  __pyx_t_3 = PyList_GET_ITEM(__pyx_t_7, __pyx_t_8); __Pyx_INCREF(__pyx_t_3); __pyx_t_8++;
                } else if (likely(PyTuple_CheckExact(__pyx_t_7))) {
                  if (__pyx_t_8 >= PyTuple_GET_SIZE(__pyx_t_7)) break;
                  __pyx_t_3 = PyTuple_GET_ITEM(__pyx_t_7, __pyx_t_8); __Pyx_INCREF(__pyx_t_3); __pyx_t_8++;
                } else {
                  __pyx_t_3 = PyIter_Next(__pyx_t_7);
                  if (!__pyx_t_3) {
                    if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 226; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                    break;
                  }
                  __Pyx_GOTREF(__pyx_t_3);
                }
                __pyx_t_1 = __Pyx_PyInt_AsInt(__pyx_t_3); if (unlikely((__pyx_t_1 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 226; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
                __pyx_v_elem = __pyx_t_1;

                /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":227
 *                         else:
 *                             for elem in rhs:
 *                                 for remelem from last <= remelem < elem:             # <<<<<<<<<<<<<<
 *                                     intBitSetDelElem(self.bitset, remelem)
 *                                 last = elem + 1
 */
                __pyx_t_1 = __pyx_v_elem;
                for (__pyx_v_remelem = __pyx_v_last; __pyx_v_remelem < __pyx_t_1; __pyx_v_remelem++) {

                  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":228
 *                             for elem in rhs:
 *                                 for remelem from last <= remelem < elem:
 *                                     intBitSetDelElem(self.bitset, remelem)             # <<<<<<<<<<<<<<
 *                                 last = elem + 1
 * 
 */
                  intBitSetDelElem(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset, __pyx_v_remelem);
                }

                /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":229
 *                                 for remelem from last <= remelem < elem:
 *                                     intBitSetDelElem(self.bitset, remelem)
 *                                 last = elem + 1             # <<<<<<<<<<<<<<
 * 
 *                 else:
 */
                __pyx_v_last = (__pyx_v_elem + 1);
              }
              __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
            }
            __pyx_L46:;
          }
          __pyx_L34:;
          goto __pyx_L33;
        }
        /*else*/ {

          /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":232
 * 
 *                 else:
 *                     if self.sanity_checks:             # <<<<<<<<<<<<<<
 *                         if tuple_of_tuples:
 *                             for tmp_tuple in rhs:
 */
          __pyx_t_4 = ((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->sanity_checks;
          if (__pyx_t_4) {

            /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":233
 *                 else:
 *                     if self.sanity_checks:
 *                         if tuple_of_tuples:             # <<<<<<<<<<<<<<
 *                             for tmp_tuple in rhs:
 *                                 elem = tmp_tuple[0]
 */
            __pyx_t_4 = __pyx_v_tuple_of_tuples;
            if (__pyx_t_4) {

              /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":234
 *                     if self.sanity_checks:
 *                         if tuple_of_tuples:
 *                             for tmp_tuple in rhs:             # <<<<<<<<<<<<<<
 *                                 elem = tmp_tuple[0]
 *                                 if elem < 0:
 */
              if (PyList_CheckExact(__pyx_v_rhs) || PyTuple_CheckExact(__pyx_v_rhs)) {
                __pyx_t_8 = 0; __pyx_t_7 = __pyx_v_rhs; __Pyx_INCREF(__pyx_t_7);
              } else {
                __pyx_t_8 = -1; __pyx_t_7 = PyObject_GetIter(__pyx_v_rhs); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 234; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                __Pyx_GOTREF(__pyx_t_7);
              }
              for (;;) {
                if (likely(PyList_CheckExact(__pyx_t_7))) {
                  if (__pyx_t_8 >= PyList_GET_SIZE(__pyx_t_7)) break;
                  __pyx_t_3 = PyList_GET_ITEM(__pyx_t_7, __pyx_t_8); __Pyx_INCREF(__pyx_t_3); __pyx_t_8++;
                } else if (likely(PyTuple_CheckExact(__pyx_t_7))) {
                  if (__pyx_t_8 >= PyTuple_GET_SIZE(__pyx_t_7)) break;
                  __pyx_t_3 = PyTuple_GET_ITEM(__pyx_t_7, __pyx_t_8); __Pyx_INCREF(__pyx_t_3); __pyx_t_8++;
                } else {
                  __pyx_t_3 = PyIter_Next(__pyx_t_7);
                  if (!__pyx_t_3) {
                    if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 234; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                    break;
                  }
                  __Pyx_GOTREF(__pyx_t_3);
                }
                __Pyx_DECREF(__pyx_v_tmp_tuple);
                __pyx_v_tmp_tuple = __pyx_t_3;
                __pyx_t_3 = 0;

                /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":235
 *                         if tuple_of_tuples:
 *                             for tmp_tuple in rhs:
 *                                 elem = tmp_tuple[0]             # <<<<<<<<<<<<<<
 *                                 if elem < 0:
 *                                     raise ValueError("Negative numbers, not allowed")
 */
                __pyx_3 = __Pyx_GetItemInt(__pyx_v_tmp_tuple, 0, sizeof(long), PyInt_FromLong); if (!__pyx_3) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 235; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                __Pyx_GOTREF(__pyx_3);
                __pyx_t_1 = __Pyx_PyInt_AsInt(__pyx_3); if (unlikely((__pyx_t_1 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 235; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                __Pyx_DECREF(__pyx_3); __pyx_3 = 0;
                __pyx_v_elem = __pyx_t_1;

                /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":236
 *                             for tmp_tuple in rhs:
 *                                 elem = tmp_tuple[0]
 *                                 if elem < 0:             # <<<<<<<<<<<<<<
 *                                     raise ValueError("Negative numbers, not allowed")
 *                                 elif elem > maxelem:
 */
                __pyx_t_4 = (__pyx_v_elem < 0);
                if (__pyx_t_4) {

                  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":237
 *                                 elem = tmp_tuple[0]
 *                                 if elem < 0:
 *                                     raise ValueError("Negative numbers, not allowed")             # <<<<<<<<<<<<<<
 *                                 elif elem > maxelem:
 *                                     raise OverflowError("Elements must be <= %s" % maxelem)
 */
                  __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 237; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                  __Pyx_GOTREF(((PyObject *)__pyx_t_3));
                  __Pyx_INCREF(__pyx_kp_18);
                  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_kp_18);
                  __Pyx_GIVEREF(__pyx_kp_18);
                  __pyx_t_2 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 237; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                  __Pyx_GOTREF(__pyx_t_2);
                  __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
                  __Pyx_Raise(__pyx_t_2, 0, 0);
                  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
                  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 237; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                  goto __pyx_L59;
                }

                /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":238
 *                                 if elem < 0:
 *                                     raise ValueError("Negative numbers, not allowed")
 *                                 elif elem > maxelem:             # <<<<<<<<<<<<<<
 *                                     raise OverflowError("Elements must be <= %s" % maxelem)
 *                                 intBitSetAddElem(self.bitset, elem)
 */
                __pyx_t_4 = (__pyx_v_elem > maxelem);
                if (__pyx_t_4) {

                  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":239
 *                                     raise ValueError("Negative numbers, not allowed")
 *                                 elif elem > maxelem:
 *                                     raise OverflowError("Elements must be <= %s" % maxelem)             # <<<<<<<<<<<<<<
 *                                 intBitSetAddElem(self.bitset, elem)
 *                         else:
 */
                  __pyx_t_2 = PyInt_FromLong(maxelem); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 239; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                  __Pyx_GOTREF(__pyx_t_2);
                  __pyx_t_3 = PyNumber_Remainder(__pyx_kp_19, __pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 239; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                  __Pyx_GOTREF(__pyx_t_3);
                  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
                  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 239; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                  __Pyx_GOTREF(((PyObject *)__pyx_t_2));
                  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_3);
                  __Pyx_GIVEREF(__pyx_t_3);
                  __pyx_t_3 = 0;
                  __pyx_t_3 = PyObject_Call(__pyx_builtin_OverflowError, ((PyObject *)__pyx_t_2), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 239; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                  __Pyx_GOTREF(__pyx_t_3);
                  __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
                  __Pyx_Raise(__pyx_t_3, 0, 0);
                  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
                  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 239; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                  goto __pyx_L59;
                }
                __pyx_L59:;

                /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":240
 *                                 elif elem > maxelem:
 *                                     raise OverflowError("Elements must be <= %s" % maxelem)
 *                                 intBitSetAddElem(self.bitset, elem)             # <<<<<<<<<<<<<<
 *                         else:
 *                             for elem in rhs:
 */
                intBitSetAddElem(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset, __pyx_v_elem);
              }
              __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
              goto __pyx_L56;
            }
            /*else*/ {

              /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":242
 *                                 intBitSetAddElem(self.bitset, elem)
 *                         else:
 *                             for elem in rhs:             # <<<<<<<<<<<<<<
 *                                 if elem < 0:
 *                                     raise ValueError("Negative numbers, not allowed")
 */
              if (PyList_CheckExact(__pyx_v_rhs) || PyTuple_CheckExact(__pyx_v_rhs)) {
                __pyx_t_8 = 0; __pyx_t_7 = __pyx_v_rhs; __Pyx_INCREF(__pyx_t_7);
              } else {
                __pyx_t_8 = -1; __pyx_t_7 = PyObject_GetIter(__pyx_v_rhs); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 242; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                __Pyx_GOTREF(__pyx_t_7);
              }
              for (;;) {
                if (likely(PyList_CheckExact(__pyx_t_7))) {
                  if (__pyx_t_8 >= PyList_GET_SIZE(__pyx_t_7)) break;
                  __pyx_t_3 = PyList_GET_ITEM(__pyx_t_7, __pyx_t_8); __Pyx_INCREF(__pyx_t_3); __pyx_t_8++;
                } else if (likely(PyTuple_CheckExact(__pyx_t_7))) {
                  if (__pyx_t_8 >= PyTuple_GET_SIZE(__pyx_t_7)) break;
                  __pyx_t_3 = PyTuple_GET_ITEM(__pyx_t_7, __pyx_t_8); __Pyx_INCREF(__pyx_t_3); __pyx_t_8++;
                } else {
                  __pyx_t_3 = PyIter_Next(__pyx_t_7);
                  if (!__pyx_t_3) {
                    if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 242; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                    break;
                  }
                  __Pyx_GOTREF(__pyx_t_3);
                }
                __pyx_t_1 = __Pyx_PyInt_AsInt(__pyx_t_3); if (unlikely((__pyx_t_1 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 242; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
                __pyx_v_elem = __pyx_t_1;

                /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":243
 *                         else:
 *                             for elem in rhs:
 *                                 if elem < 0:             # <<<<<<<<<<<<<<
 *                                     raise ValueError("Negative numbers, not allowed")
 *                                 elif elem > maxelem:
 */
                __pyx_t_4 = (__pyx_v_elem < 0);
                if (__pyx_t_4) {

                  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":244
 *                             for elem in rhs:
 *                                 if elem < 0:
 *                                     raise ValueError("Negative numbers, not allowed")             # <<<<<<<<<<<<<<
 *                                 elif elem > maxelem:
 *                                     raise OverflowError("Elements must be <= %s" % maxelem)
 */
                  __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 244; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                  __Pyx_GOTREF(((PyObject *)__pyx_t_3));
                  __Pyx_INCREF(__pyx_kp_20);
                  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_kp_20);
                  __Pyx_GIVEREF(__pyx_kp_20);
                  __pyx_t_2 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 244; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                  __Pyx_GOTREF(__pyx_t_2);
                  __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
                  __Pyx_Raise(__pyx_t_2, 0, 0);
                  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
                  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 244; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                  goto __pyx_L62;
                }

                /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":245
 *                                 if elem < 0:
 *                                     raise ValueError("Negative numbers, not allowed")
 *                                 elif elem > maxelem:             # <<<<<<<<<<<<<<
 *                                     raise OverflowError("Elements must be <= %s" % maxelem)
 *                                 intBitSetAddElem(self.bitset, elem)
 */
                __pyx_t_4 = (__pyx_v_elem > maxelem);
                if (__pyx_t_4) {

                  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":246
 *                                     raise ValueError("Negative numbers, not allowed")
 *                                 elif elem > maxelem:
 *                                     raise OverflowError("Elements must be <= %s" % maxelem)             # <<<<<<<<<<<<<<
 *                                 intBitSetAddElem(self.bitset, elem)
 *                     else:
 */
                  __pyx_t_2 = PyInt_FromLong(maxelem); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 246; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                  __Pyx_GOTREF(__pyx_t_2);
                  __pyx_t_3 = PyNumber_Remainder(__pyx_kp_21, __pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 246; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                  __Pyx_GOTREF(__pyx_t_3);
                  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
                  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 246; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                  __Pyx_GOTREF(((PyObject *)__pyx_t_2));
                  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_3);
                  __Pyx_GIVEREF(__pyx_t_3);
                  __pyx_t_3 = 0;
                  __pyx_t_3 = PyObject_Call(__pyx_builtin_OverflowError, ((PyObject *)__pyx_t_2), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 246; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                  __Pyx_GOTREF(__pyx_t_3);
                  __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
                  __Pyx_Raise(__pyx_t_3, 0, 0);
                  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
                  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 246; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                  goto __pyx_L62;
                }
                __pyx_L62:;

                /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":247
 *                                 elif elem > maxelem:
 *                                     raise OverflowError("Elements must be <= %s" % maxelem)
 *                                 intBitSetAddElem(self.bitset, elem)             # <<<<<<<<<<<<<<
 *                     else:
 *                         if tuple_of_tuples:
 */
                intBitSetAddElem(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset, __pyx_v_elem);
              }
              __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
            }
            __pyx_L56:;
            goto __pyx_L55;
          }
          /*else*/ {

            /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":249
 *                                 intBitSetAddElem(self.bitset, elem)
 *                     else:
 *                         if tuple_of_tuples:             # <<<<<<<<<<<<<<
 *                             for tmp_tuple in rhs:
 *                                 elem = tmp_tuple[0]
 */
            __pyx_t_4 = __pyx_v_tuple_of_tuples;
            if (__pyx_t_4) {

              /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":250
 *                     else:
 *                         if tuple_of_tuples:
 *                             for tmp_tuple in rhs:             # <<<<<<<<<<<<<<
 *                                 elem = tmp_tuple[0]
 *                                 intBitSetAddElem(self.bitset, elem)
 */
              if (PyList_CheckExact(__pyx_v_rhs) || PyTuple_CheckExact(__pyx_v_rhs)) {
                __pyx_t_8 = 0; __pyx_t_7 = __pyx_v_rhs; __Pyx_INCREF(__pyx_t_7);
              } else {
                __pyx_t_8 = -1; __pyx_t_7 = PyObject_GetIter(__pyx_v_rhs); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 250; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                __Pyx_GOTREF(__pyx_t_7);
              }
              for (;;) {
                if (likely(PyList_CheckExact(__pyx_t_7))) {
                  if (__pyx_t_8 >= PyList_GET_SIZE(__pyx_t_7)) break;
                  __pyx_t_3 = PyList_GET_ITEM(__pyx_t_7, __pyx_t_8); __Pyx_INCREF(__pyx_t_3); __pyx_t_8++;
                } else if (likely(PyTuple_CheckExact(__pyx_t_7))) {
                  if (__pyx_t_8 >= PyTuple_GET_SIZE(__pyx_t_7)) break;
                  __pyx_t_3 = PyTuple_GET_ITEM(__pyx_t_7, __pyx_t_8); __Pyx_INCREF(__pyx_t_3); __pyx_t_8++;
                } else {
                  __pyx_t_3 = PyIter_Next(__pyx_t_7);
                  if (!__pyx_t_3) {
                    if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 250; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                    break;
                  }
                  __Pyx_GOTREF(__pyx_t_3);
                }
                __Pyx_DECREF(__pyx_v_tmp_tuple);
                __pyx_v_tmp_tuple = __pyx_t_3;
                __pyx_t_3 = 0;

                /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":251
 *                         if tuple_of_tuples:
 *                             for tmp_tuple in rhs:
 *                                 elem = tmp_tuple[0]             # <<<<<<<<<<<<<<
 *                                 intBitSetAddElem(self.bitset, elem)
 *                         else:
 */
                __pyx_4 = __Pyx_GetItemInt(__pyx_v_tmp_tuple, 0, sizeof(long), PyInt_FromLong); if (!__pyx_4) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 251; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                __Pyx_GOTREF(__pyx_4);
                __pyx_t_1 = __Pyx_PyInt_AsInt(__pyx_4); if (unlikely((__pyx_t_1 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 251; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                __Pyx_DECREF(__pyx_4); __pyx_4 = 0;
                __pyx_v_elem = __pyx_t_1;

                /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":252
 *                             for tmp_tuple in rhs:
 *                                 elem = tmp_tuple[0]
 *                                 intBitSetAddElem(self.bitset, elem)             # <<<<<<<<<<<<<<
 *                         else:
 *                             for elem in rhs:
 */
                intBitSetAddElem(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset, __pyx_v_elem);
              }
              __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
              goto __pyx_L63;
            }
            /*else*/ {

              /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":254
 *                                 intBitSetAddElem(self.bitset, elem)
 *                         else:
 *                             for elem in rhs:             # <<<<<<<<<<<<<<
 *                                 intBitSetAddElem(self.bitset, elem)
 *             except Exception, msg:
 */
              if (PyList_CheckExact(__pyx_v_rhs) || PyTuple_CheckExact(__pyx_v_rhs)) {
                __pyx_t_8 = 0; __pyx_t_7 = __pyx_v_rhs; __Pyx_INCREF(__pyx_t_7);
              } else {
                __pyx_t_8 = -1; __pyx_t_7 = PyObject_GetIter(__pyx_v_rhs); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 254; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                __Pyx_GOTREF(__pyx_t_7);
              }
              for (;;) {
                if (likely(PyList_CheckExact(__pyx_t_7))) {
                  if (__pyx_t_8 >= PyList_GET_SIZE(__pyx_t_7)) break;
                  __pyx_t_3 = PyList_GET_ITEM(__pyx_t_7, __pyx_t_8); __Pyx_INCREF(__pyx_t_3); __pyx_t_8++;
                } else if (likely(PyTuple_CheckExact(__pyx_t_7))) {
                  if (__pyx_t_8 >= PyTuple_GET_SIZE(__pyx_t_7)) break;
                  __pyx_t_3 = PyTuple_GET_ITEM(__pyx_t_7, __pyx_t_8); __Pyx_INCREF(__pyx_t_3); __pyx_t_8++;
                } else {
                  __pyx_t_3 = PyIter_Next(__pyx_t_7);
                  if (!__pyx_t_3) {
                    if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 254; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                    break;
                  }
                  __Pyx_GOTREF(__pyx_t_3);
                }
                __pyx_t_1 = __Pyx_PyInt_AsInt(__pyx_t_3); if (unlikely((__pyx_t_1 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 254; __pyx_clineno = __LINE__; goto __pyx_L21_error;}
                __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
                __pyx_v_elem = __pyx_t_1;

                /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":255
 *                         else:
 *                             for elem in rhs:
 *                                 intBitSetAddElem(self.bitset, elem)             # <<<<<<<<<<<<<<
 *             except Exception, msg:
 *                 raise ValueError("retrieving integers from rhs is impossible: %s" % msg)
 */
                intBitSetAddElem(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset, __pyx_v_elem);
              }
              __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
            }
            __pyx_L63:;
          }
          __pyx_L55:;
        }
        __pyx_L33:;
      }
      __Pyx_XDECREF(__pyx_save_exc_type); __pyx_save_exc_type = 0;
      __Pyx_XDECREF(__pyx_save_exc_value); __pyx_save_exc_value = 0;
      __Pyx_XDECREF(__pyx_save_exc_tb); __pyx_save_exc_tb = 0;
      goto __pyx_L28_try_end;
      __pyx_L21_error:;
      __Pyx_XDECREF(__pyx_1); __pyx_1 = 0;
      __Pyx_XDECREF(__pyx_3); __pyx_3 = 0;
      __Pyx_XDECREF(__pyx_4); __pyx_4 = 0;
      __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_XDECREF(__pyx_t_7); __pyx_t_7 = 0;

      /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":256
 *                             for elem in rhs:
 *                                 intBitSetAddElem(self.bitset, elem)
 *             except Exception, msg:             # <<<<<<<<<<<<<<
 *                 raise ValueError("retrieving integers from rhs is impossible: %s" % msg)
 *         else:
 */
      __pyx_2 = PyErr_ExceptionMatches(__pyx_builtin_Exception);
      if (__pyx_2) {
        __Pyx_AddTraceback("lib.intbitset.__cinit__");
        if (__Pyx_GetException(&__pyx_1, &__pyx_3, &__pyx_4) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 256; __pyx_clineno = __LINE__; goto __pyx_L23_except_error;}
        __Pyx_GOTREF(__pyx_1);
        __Pyx_GOTREF(__pyx_3);
        __Pyx_GOTREF(__pyx_4);
        __Pyx_INCREF(__pyx_3);
        __Pyx_DECREF(__pyx_v_msg);
        __pyx_v_msg = __pyx_3;

        /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":257
 *                                 intBitSetAddElem(self.bitset, elem)
 *             except Exception, msg:
 *                 raise ValueError("retrieving integers from rhs is impossible: %s" % msg)             # <<<<<<<<<<<<<<
 *         else:
 *             raise TypeError("rhs is of unknown type %s" % type(rhs))
 */
        __pyx_t_7 = PyNumber_Remainder(__pyx_kp_22, __pyx_v_msg); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 257; __pyx_clineno = __LINE__; goto __pyx_L23_except_error;}
        __Pyx_GOTREF(__pyx_t_7);
        __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 257; __pyx_clineno = __LINE__; goto __pyx_L23_except_error;}
        __Pyx_GOTREF(((PyObject *)__pyx_t_3));
        PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_7);
        __Pyx_GIVEREF(__pyx_t_7);
        __pyx_t_7 = 0;
        __pyx_t_7 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 257; __pyx_clineno = __LINE__; goto __pyx_L23_except_error;}
        __Pyx_GOTREF(__pyx_t_7);
        __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
        __Pyx_Raise(__pyx_t_7, 0, 0);
        __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
        {__pyx_filename = __pyx_f[0]; __pyx_lineno = 257; __pyx_clineno = __LINE__; goto __pyx_L23_except_error;}
        __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
        __Pyx_DECREF(__pyx_3); __pyx_3 = 0;
        __Pyx_DECREF(__pyx_4); __pyx_4 = 0;
        goto __pyx_L22_exception_handled;
      }
      __pyx_L23_except_error:;
      __Pyx_XDECREF(__pyx_save_exc_type);
      __Pyx_XDECREF(__pyx_save_exc_value);
      __Pyx_XDECREF(__pyx_save_exc_tb);
      goto __pyx_L1_error;
      __pyx_L22_exception_handled:;
      __Pyx_XGIVEREF(__pyx_save_exc_type);
      __Pyx_XGIVEREF(__pyx_save_exc_value);
      __Pyx_XGIVEREF(__pyx_save_exc_tb);
      __Pyx_ExceptionReset(__pyx_save_exc_type, __pyx_save_exc_value, __pyx_save_exc_tb);
      __pyx_L28_try_end:;
    }
    goto __pyx_L7;
  }
  /*else*/ {

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":259
 *                 raise ValueError("retrieving integers from rhs is impossible: %s" % msg)
 *         else:
 *             raise TypeError("rhs is of unknown type %s" % type(rhs))             # <<<<<<<<<<<<<<
 * 
 *     def __dealloc__(self):
 */
    __pyx_t_7 = PyTuple_New(1); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 259; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(((PyObject *)__pyx_t_7));
    __Pyx_INCREF(__pyx_v_rhs);
    PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_v_rhs);
    __Pyx_GIVEREF(__pyx_v_rhs);
    __pyx_t_3 = PyObject_Call(((PyObject *)((PyObject*)&PyType_Type)), ((PyObject *)__pyx_t_7), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 259; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(((PyObject *)__pyx_t_7)); __pyx_t_7 = 0;
    __pyx_t_7 = PyNumber_Remainder(__pyx_kp_23, __pyx_t_3); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 259; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_7);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 259; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(((PyObject *)__pyx_t_3));
    PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_7);
    __Pyx_GIVEREF(__pyx_t_7);
    __pyx_t_7 = 0;
    __pyx_t_7 = PyObject_Call(__pyx_builtin_TypeError, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 259; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_7);
    __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
    __Pyx_Raise(__pyx_t_7, 0, 0);
    __Pyx_DECREF(__pyx_t_7); __pyx_t_7 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 259; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L7:;

  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_1);
  __Pyx_XDECREF(__pyx_3);
  __Pyx_XDECREF(__pyx_4);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_AddTraceback("lib.intbitset.intbitset.__cinit__");
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_msg);
  __Pyx_DECREF(__pyx_v_tmp);
  __Pyx_DECREF(__pyx_v_tmp_tuple);
  __Pyx_DECREF(__pyx_v_rhs);
  __Pyx_FinishRefcountContext();
  return __pyx_r;
}

/* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":261
 *             raise TypeError("rhs is of unknown type %s" % type(rhs))
 * 
 *     def __dealloc__(self):             # <<<<<<<<<<<<<<
 *         if self.bitset:
 *             intBitSetDestroy(self.bitset)
 */

static void __pyx_pf_3lib_9intbitset_9intbitset___dealloc__(PyObject *__pyx_v_self); /*proto*/
static void __pyx_pf_3lib_9intbitset_9intbitset___dealloc__(PyObject *__pyx_v_self) {
  int __pyx_t_1;
  __Pyx_SetupRefcountContext("__dealloc__");

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":262
 * 
 *     def __dealloc__(self):
 *         if self.bitset:             # <<<<<<<<<<<<<<
 *             intBitSetDestroy(self.bitset)
 * 
 */
  __pyx_t_1 = (((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset != 0);
  if (__pyx_t_1) {

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":263
 *     def __dealloc__(self):
 *         if self.bitset:
 *             intBitSetDestroy(self.bitset)             # <<<<<<<<<<<<<<
 * 
 *     def __contains__(self, int elem):
 */
    intBitSetDestroy(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset);
    goto __pyx_L5;
  }
  __pyx_L5:;

  __Pyx_FinishRefcountContext();
}

/* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":265
 *             intBitSetDestroy(self.bitset)
 * 
 *     def __contains__(self, int elem):             # <<<<<<<<<<<<<<
 *         if self.sanity_checks:
 *             if elem < 0:
 */

static int __pyx_pf_3lib_9intbitset_9intbitset___contains__(PyObject *__pyx_v_self, PyObject *__pyx_arg_elem); /*proto*/
static int __pyx_pf_3lib_9intbitset_9intbitset___contains__(PyObject *__pyx_v_self, PyObject *__pyx_arg_elem) {
  int __pyx_v_elem;
  int __pyx_r;
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_SetupRefcountContext("__contains__");
  assert(__pyx_arg_elem); {
    __pyx_v_elem = __Pyx_PyInt_AsInt(__pyx_arg_elem); if (unlikely((__pyx_v_elem == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 265; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("lib.intbitset.intbitset.__contains__");
  return -1;
  __pyx_L4_argument_unpacking_done:;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":266
 * 
 *     def __contains__(self, int elem):
 *         if self.sanity_checks:             # <<<<<<<<<<<<<<
 *             if elem < 0:
 *                 raise ValueError("Negative numbers, not allowed")
 */
  __pyx_t_1 = ((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->sanity_checks;
  if (__pyx_t_1) {

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":267
 *     def __contains__(self, int elem):
 *         if self.sanity_checks:
 *             if elem < 0:             # <<<<<<<<<<<<<<
 *                 raise ValueError("Negative numbers, not allowed")
 *             elif elem > maxelem:
 */
    __pyx_t_1 = (__pyx_v_elem < 0);
    if (__pyx_t_1) {

      /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":268
 *         if self.sanity_checks:
 *             if elem < 0:
 *                 raise ValueError("Negative numbers, not allowed")             # <<<<<<<<<<<<<<
 *             elif elem > maxelem:
 *                 raise OverflowError("Element must be <= %s" % maxelem)
 */
      __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 268; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(((PyObject *)__pyx_t_2));
      __Pyx_INCREF(__pyx_kp_24);
      PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_kp_24);
      __Pyx_GIVEREF(__pyx_kp_24);
      __pyx_t_3 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_t_2), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 268; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
      __Pyx_Raise(__pyx_t_3, 0, 0);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 268; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      goto __pyx_L6;
    }

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":269
 *             if elem < 0:
 *                 raise ValueError("Negative numbers, not allowed")
 *             elif elem > maxelem:             # <<<<<<<<<<<<<<
 *                 raise OverflowError("Element must be <= %s" % maxelem)
 *         return intBitSetIsInElem(self.bitset, elem) != 0
 */
    __pyx_t_1 = (__pyx_v_elem > maxelem);
    if (__pyx_t_1) {

      /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":270
 *                 raise ValueError("Negative numbers, not allowed")
 *             elif elem > maxelem:
 *                 raise OverflowError("Element must be <= %s" % maxelem)             # <<<<<<<<<<<<<<
 *         return intBitSetIsInElem(self.bitset, elem) != 0
 * 
 */
      __pyx_t_3 = PyInt_FromLong(maxelem); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 270; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_2 = PyNumber_Remainder(__pyx_kp_25, __pyx_t_3); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 270; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 270; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(((PyObject *)__pyx_t_3));
      PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_2);
      __Pyx_GIVEREF(__pyx_t_2);
      __pyx_t_2 = 0;
      __pyx_t_2 = PyObject_Call(__pyx_builtin_OverflowError, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 270; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
      __Pyx_Raise(__pyx_t_2, 0, 0);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 270; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      goto __pyx_L6;
    }
    __pyx_L6:;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":271
 *             elif elem > maxelem:
 *                 raise OverflowError("Element must be <= %s" % maxelem)
 *         return intBitSetIsInElem(self.bitset, elem) != 0             # <<<<<<<<<<<<<<
 * 
 *     def __cmp__(self, intbitset rhs not None):
 */
  __pyx_r = (intBitSetIsInElem(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset, __pyx_v_elem) != 0);
  goto __pyx_L0;

  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("lib.intbitset.intbitset.__contains__");
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_FinishRefcountContext();
  return __pyx_r;
}

/* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":273
 *         return intBitSetIsInElem(self.bitset, elem) != 0
 * 
 *     def __cmp__(self, intbitset rhs not None):             # <<<<<<<<<<<<<<
 *         raise TypeError("cannot compare intbitset using cmp()")
 * 
 */

static int __pyx_pf_3lib_9intbitset_9intbitset___cmp__(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs); /*proto*/
static int __pyx_pf_3lib_9intbitset_9intbitset___cmp__(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs) {
  int __pyx_r;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  __Pyx_SetupRefcountContext("__cmp__");
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_rhs), __pyx_ptype_3lib_9intbitset_intbitset, 0, "rhs", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 273; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":274
 * 
 *     def __cmp__(self, intbitset rhs not None):
 *         raise TypeError("cannot compare intbitset using cmp()")             # <<<<<<<<<<<<<<
 * 
 *     def __richcmp__(self, intbitset rhs not None, int op):
 */
  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 274; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(((PyObject *)__pyx_t_1));
  __Pyx_INCREF(__pyx_kp_26);
  PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_kp_26);
  __Pyx_GIVEREF(__pyx_kp_26);
  __pyx_t_2 = PyObject_Call(__pyx_builtin_TypeError, ((PyObject *)__pyx_t_1), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 274; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
  __Pyx_Raise(__pyx_t_2, 0, 0);
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  {__pyx_filename = __pyx_f[0]; __pyx_lineno = 274; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("lib.intbitset.intbitset.__cmp__");
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_FinishRefcountContext();
  return __pyx_r;
}

/* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":276
 *         raise TypeError("cannot compare intbitset using cmp()")
 * 
 *     def __richcmp__(self, intbitset rhs not None, int op):             # <<<<<<<<<<<<<<
 *         cdef short unsigned int tmp
 *         tmp = intBitSetCmp((<intbitset>self).bitset, rhs.bitset)
 */

static PyObject *__pyx_pf_3lib_9intbitset_9intbitset___richcmp__(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs, int __pyx_v_op); /*proto*/
static PyObject *__pyx_pf_3lib_9intbitset_9intbitset___richcmp__(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs, int __pyx_v_op) {
  unsigned short __pyx_v_tmp;
  PyObject *__pyx_r = NULL;
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  unsigned short __pyx_t_3;
  __Pyx_SetupRefcountContext("__richcmp__");
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_rhs), __pyx_ptype_3lib_9intbitset_intbitset, 0, "rhs", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 276; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":278
 *     def __richcmp__(self, intbitset rhs not None, int op):
 *         cdef short unsigned int tmp
 *         tmp = intBitSetCmp((<intbitset>self).bitset, rhs.bitset)             # <<<<<<<<<<<<<<
 *         if op == 0: # <
 *             return tmp == 1
 */
  __pyx_v_tmp = intBitSetCmp(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset, ((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_rhs)->bitset);

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":279
 *         cdef short unsigned int tmp
 *         tmp = intBitSetCmp((<intbitset>self).bitset, rhs.bitset)
 *         if op == 0: # <             # <<<<<<<<<<<<<<
 *             return tmp == 1
 *         if op == 1: # <=
 */
  __pyx_t_1 = (__pyx_v_op == 0);
  if (__pyx_t_1) {

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":280
 *         tmp = intBitSetCmp((<intbitset>self).bitset, rhs.bitset)
 *         if op == 0: # <
 *             return tmp == 1             # <<<<<<<<<<<<<<
 *         if op == 1: # <=
 *             return tmp <= 1
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_2 = __Pyx_PyBool_FromLong((__pyx_v_tmp == 1)); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 280; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_r = __pyx_t_2;
    __pyx_t_2 = 0;
    goto __pyx_L0;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":281
 *         if op == 0: # <
 *             return tmp == 1
 *         if op == 1: # <=             # <<<<<<<<<<<<<<
 *             return tmp <= 1
 *         if op == 2: # ==
 */
  __pyx_t_1 = (__pyx_v_op == 1);
  if (__pyx_t_1) {

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":282
 *             return tmp == 1
 *         if op == 1: # <=
 *             return tmp <= 1             # <<<<<<<<<<<<<<
 *         if op == 2: # ==
 *             return tmp == 0
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_2 = __Pyx_PyBool_FromLong((__pyx_v_tmp <= 1)); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 282; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_r = __pyx_t_2;
    __pyx_t_2 = 0;
    goto __pyx_L0;
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":283
 *         if op == 1: # <=
 *             return tmp <= 1
 *         if op == 2: # ==             # <<<<<<<<<<<<<<
 *             return tmp == 0
 *         if op == 3: # !=
 */
  __pyx_t_1 = (__pyx_v_op == 2);
  if (__pyx_t_1) {

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":284
 *             return tmp <= 1
 *         if op == 2: # ==
 *             return tmp == 0             # <<<<<<<<<<<<<<
 *         if op == 3: # !=
 *             return tmp > 0
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_2 = __Pyx_PyBool_FromLong((__pyx_v_tmp == 0)); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 284; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_r = __pyx_t_2;
    __pyx_t_2 = 0;
    goto __pyx_L0;
    goto __pyx_L7;
  }
  __pyx_L7:;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":285
 *         if op == 2: # ==
 *             return tmp == 0
 *         if op == 3: # !=             # <<<<<<<<<<<<<<
 *             return tmp > 0
 *         if op == 4: # >
 */
  __pyx_t_1 = (__pyx_v_op == 3);
  if (__pyx_t_1) {

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":286
 *             return tmp == 0
 *         if op == 3: # !=
 *             return tmp > 0             # <<<<<<<<<<<<<<
 *         if op == 4: # >
 *             return tmp == 2
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_2 = __Pyx_PyBool_FromLong((__pyx_v_tmp > 0)); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 286; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_r = __pyx_t_2;
    __pyx_t_2 = 0;
    goto __pyx_L0;
    goto __pyx_L8;
  }
  __pyx_L8:;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":287
 *         if op == 3: # !=
 *             return tmp > 0
 *         if op == 4: # >             # <<<<<<<<<<<<<<
 *             return tmp == 2
 *         if op == 5: # >=
 */
  __pyx_t_1 = (__pyx_v_op == 4);
  if (__pyx_t_1) {

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":288
 *             return tmp > 0
 *         if op == 4: # >
 *             return tmp == 2             # <<<<<<<<<<<<<<
 *         if op == 5: # >=
 *             return tmp in (0, 2)
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_2 = __Pyx_PyBool_FromLong((__pyx_v_tmp == 2)); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 288; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_r = __pyx_t_2;
    __pyx_t_2 = 0;
    goto __pyx_L0;
    goto __pyx_L9;
  }
  __pyx_L9:;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":289
 *         if op == 4: # >
 *             return tmp == 2
 *         if op == 5: # >=             # <<<<<<<<<<<<<<
 *             return tmp in (0, 2)
 * 
 */
  __pyx_t_1 = (__pyx_v_op == 5);
  if (__pyx_t_1) {

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":290
 *             return tmp == 2
 *         if op == 5: # >=
 *             return tmp in (0, 2)             # <<<<<<<<<<<<<<
 * 
 *     def __len__(self):
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_3 = __pyx_v_tmp;
    if (!((int)(__pyx_t_3 == 0))) {
      __pyx_t_1 = ((int)(__pyx_t_3 == 2));
    } else {
      __pyx_t_1 = ((int)(__pyx_t_3 == 0));
    }
    __pyx_t_2 = __Pyx_PyBool_FromLong(__pyx_t_1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 290; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_r = __pyx_t_2;
    __pyx_t_2 = 0;
    goto __pyx_L0;
    goto __pyx_L10;
  }
  __pyx_L10:;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("lib.intbitset.intbitset.__richcmp__");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_FinishRefcountContext();
  return __pyx_r;
}

/* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":292
 *             return tmp in (0, 2)
 * 
 *     def __len__(self):             # <<<<<<<<<<<<<<
 *         return intBitSetGetTot(self.bitset)
 * 
 */

static Py_ssize_t __pyx_pf_3lib_9intbitset_9intbitset___len__(PyObject *__pyx_v_self); /*proto*/
static Py_ssize_t __pyx_pf_3lib_9intbitset_9intbitset___len__(PyObject *__pyx_v_self) {
  Py_ssize_t __pyx_r;
  __Pyx_SetupRefcountContext("__len__");

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":293
 * 
 *     def __len__(self):
 *         return intBitSetGetTot(self.bitset)             # <<<<<<<<<<<<<<
 * 
 *     def __hash__(self):
 */
  __pyx_r = intBitSetGetTot(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset);
  goto __pyx_L0;

  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_FinishRefcountContext();
  return __pyx_r;
}

/* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":295
 *         return intBitSetGetTot(self.bitset)
 * 
 *     def __hash__(self):             # <<<<<<<<<<<<<<
 *         return hash(PyString_FromStringAndSize(<char *>self.bitset.bitset, wordbytesize * (intBitSetGetTot(self.bitset) / wordbitsize + 1)))
 * 
 */

static long __pyx_pf_3lib_9intbitset_9intbitset___hash__(PyObject *__pyx_v_self); /*proto*/
static long __pyx_pf_3lib_9intbitset_9intbitset___hash__(PyObject *__pyx_v_self) {
  long __pyx_r;
  PyObject *__pyx_t_1 = NULL;
  long __pyx_t_2;
  __Pyx_SetupRefcountContext("__hash__");

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":296
 * 
 *     def __hash__(self):
 *         return hash(PyString_FromStringAndSize(<char *>self.bitset.bitset, wordbytesize * (intBitSetGetTot(self.bitset) / wordbitsize + 1)))             # <<<<<<<<<<<<<<
 * 
 *     def __nonzero__(self):
 */
  __pyx_t_1 = PyString_FromStringAndSize(((char *)((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset->bitset), (wordbytesize * ((intBitSetGetTot(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset) / wordbitsize) + 1))); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 296; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyObject_Hash(__pyx_t_1); if (unlikely(__pyx_t_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 296; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __pyx_r = __pyx_t_2;
  goto __pyx_L0;

  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("lib.intbitset.intbitset.__hash__");
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_FinishRefcountContext();
  return __pyx_r;
}

/* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":298
 *         return hash(PyString_FromStringAndSize(<char *>self.bitset.bitset, wordbytesize * (intBitSetGetTot(self.bitset) / wordbitsize + 1)))
 * 
 *     def __nonzero__(self):             # <<<<<<<<<<<<<<
 *         return not intBitSetEmpty(self.bitset)
 * 
 */

static int __pyx_pf_3lib_9intbitset_9intbitset___nonzero__(PyObject *__pyx_v_self); /*proto*/
static int __pyx_pf_3lib_9intbitset_9intbitset___nonzero__(PyObject *__pyx_v_self) {
  int __pyx_r;
  __Pyx_SetupRefcountContext("__nonzero__");

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":299
 * 
 *     def __nonzero__(self):
 *         return not intBitSetEmpty(self.bitset)             # <<<<<<<<<<<<<<
 * 
 *     def __iadd__(self, rhs):
 */
  __pyx_r = (!intBitSetEmpty(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset));
  goto __pyx_L0;

  __pyx_r = 0;
  __pyx_L0:;
  __Pyx_FinishRefcountContext();
  return __pyx_r;
}

/* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":301
 *         return not intBitSetEmpty(self.bitset)
 * 
 *     def __iadd__(self, rhs):             # <<<<<<<<<<<<<<
 *         cdef int elem
 *         if isinstance(rhs, (int, long)):
 */

static PyObject *__pyx_pf_3lib_9intbitset_9intbitset___iadd__(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs); /*proto*/
static PyObject *__pyx_pf_3lib_9intbitset_9intbitset___iadd__(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs) {
  int __pyx_v_elem;
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  Py_ssize_t __pyx_t_5;
  PyObject *__pyx_t_6 = NULL;
  __Pyx_SetupRefcountContext("__iadd__");

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":303
 *     def __iadd__(self, rhs):
 *         cdef int elem
 *         if isinstance(rhs, (int, long)):             # <<<<<<<<<<<<<<
 *             if self.sanity_checks:
 *                 if rhs < 0:
 */
  __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 303; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(((PyObject *)__pyx_t_1));
  __Pyx_INCREF(((PyObject *)((PyObject*)&PyInt_Type)));
  PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)((PyObject*)&PyInt_Type)));
  __Pyx_GIVEREF(((PyObject *)((PyObject*)&PyInt_Type)));
  __Pyx_INCREF(((PyObject *)((PyObject*)&PyLong_Type)));
  PyTuple_SET_ITEM(__pyx_t_1, 1, ((PyObject *)((PyObject*)&PyLong_Type)));
  __Pyx_GIVEREF(((PyObject *)((PyObject*)&PyLong_Type)));
  __pyx_t_2 = PyObject_IsInstance(__pyx_v_rhs, ((PyObject *)__pyx_t_1)); if (unlikely(__pyx_t_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 303; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
  if (__pyx_t_2) {

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":304
 *         cdef int elem
 *         if isinstance(rhs, (int, long)):
 *             if self.sanity_checks:             # <<<<<<<<<<<<<<
 *                 if rhs < 0:
 *                     raise ValueError("Negative numbers, not allowed")
 */
    __pyx_t_2 = ((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->sanity_checks;
    if (__pyx_t_2) {

      /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":305
 *         if isinstance(rhs, (int, long)):
 *             if self.sanity_checks:
 *                 if rhs < 0:             # <<<<<<<<<<<<<<
 *                     raise ValueError("Negative numbers, not allowed")
 *                 elif rhs > maxelem:
 */
      __pyx_t_1 = PyObject_RichCompare(__pyx_v_rhs, __pyx_int_0, Py_LT); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 305; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 305; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      if (__pyx_t_2) {

        /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":306
 *             if self.sanity_checks:
 *                 if rhs < 0:
 *                     raise ValueError("Negative numbers, not allowed")             # <<<<<<<<<<<<<<
 *                 elif rhs > maxelem:
 *                     raise OverflowError("rhs must be <= %s" % maxelem)
 */
        __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 306; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __Pyx_GOTREF(((PyObject *)__pyx_t_1));
        __Pyx_INCREF(__pyx_kp_27);
        PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_kp_27);
        __Pyx_GIVEREF(__pyx_kp_27);
        __pyx_t_3 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_t_1), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 306; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
        __Pyx_Raise(__pyx_t_3, 0, 0);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        {__pyx_filename = __pyx_f[0]; __pyx_lineno = 306; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        goto __pyx_L7;
      }

      /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":307
 *                 if rhs < 0:
 *                     raise ValueError("Negative numbers, not allowed")
 *                 elif rhs > maxelem:             # <<<<<<<<<<<<<<
 *                     raise OverflowError("rhs must be <= %s" % maxelem)
 *             intBitSetAddElem(self.bitset, rhs)
 */
      __pyx_t_3 = PyInt_FromLong(maxelem); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 307; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_1 = PyObject_RichCompare(__pyx_v_rhs, __pyx_t_3, Py_GT); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 307; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 307; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      if (__pyx_t_2) {

        /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":308
 *                     raise ValueError("Negative numbers, not allowed")
 *                 elif rhs > maxelem:
 *                     raise OverflowError("rhs must be <= %s" % maxelem)             # <<<<<<<<<<<<<<
 *             intBitSetAddElem(self.bitset, rhs)
 *         elif isinstance(rhs, intbitset):
 */
        __pyx_t_1 = PyInt_FromLong(maxelem); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 308; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __Pyx_GOTREF(__pyx_t_1);
        __pyx_t_3 = PyNumber_Remainder(__pyx_kp_28, __pyx_t_1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 308; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 308; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __Pyx_GOTREF(((PyObject *)__pyx_t_1));
        PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_t_3);
        __Pyx_GIVEREF(__pyx_t_3);
        __pyx_t_3 = 0;
        __pyx_t_3 = PyObject_Call(__pyx_builtin_OverflowError, ((PyObject *)__pyx_t_1), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 308; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
        __Pyx_Raise(__pyx_t_3, 0, 0);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        {__pyx_filename = __pyx_f[0]; __pyx_lineno = 308; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        goto __pyx_L7;
      }
      __pyx_L7:;
      goto __pyx_L6;
    }
    __pyx_L6:;

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":309
 *                 elif rhs > maxelem:
 *                     raise OverflowError("rhs must be <= %s" % maxelem)
 *             intBitSetAddElem(self.bitset, rhs)             # <<<<<<<<<<<<<<
 *         elif isinstance(rhs, intbitset):
 *             intBitSetIUnion(self.bitset, (<intbitset> rhs).bitset)
 */
    __pyx_t_4 = __Pyx_PyInt_AsInt(__pyx_v_rhs); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 309; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    intBitSetAddElem(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset, __pyx_t_4);
    goto __pyx_L5;
  }

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":310
 *                     raise OverflowError("rhs must be <= %s" % maxelem)
 *             intBitSetAddElem(self.bitset, rhs)
 *         elif isinstance(rhs, intbitset):             # <<<<<<<<<<<<<<
 *             intBitSetIUnion(self.bitset, (<intbitset> rhs).bitset)
 *         else:
 */
  __pyx_t_2 = PyObject_TypeCheck(__pyx_v_rhs, ((PyTypeObject *)((PyObject*)__pyx_ptype_3lib_9intbitset_intbitset))); 
  if (__pyx_t_2) {

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":311
 *             intBitSetAddElem(self.bitset, rhs)
 *         elif isinstance(rhs, intbitset):
 *             intBitSetIUnion(self.bitset, (<intbitset> rhs).bitset)             # <<<<<<<<<<<<<<
 *         else:
 *             if self.sanity_checks:
 */
    intBitSetIUnion(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset, ((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_rhs)->bitset);
    goto __pyx_L5;
  }
  /*else*/ {

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":313
 *             intBitSetIUnion(self.bitset, (<intbitset> rhs).bitset)
 *         else:
 *             if self.sanity_checks:             # <<<<<<<<<<<<<<
 *                 for elem in rhs:
 *                     if elem < 0:
 */
    __pyx_t_2 = ((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->sanity_checks;
    if (__pyx_t_2) {

      /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":314
 *         else:
 *             if self.sanity_checks:
 *                 for elem in rhs:             # <<<<<<<<<<<<<<
 *                     if elem < 0:
 *                         raise ValueError("Negative numbers, not allowed")
 */
      if (PyList_CheckExact(__pyx_v_rhs) || PyTuple_CheckExact(__pyx_v_rhs)) {
        __pyx_t_5 = 0; __pyx_t_3 = __pyx_v_rhs; __Pyx_INCREF(__pyx_t_3);
      } else {
        __pyx_t_5 = -1; __pyx_t_3 = PyObject_GetIter(__pyx_v_rhs); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 314; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __Pyx_GOTREF(__pyx_t_3);
      }
      for (;;) {
        if (likely(PyList_CheckExact(__pyx_t_3))) {
          if (__pyx_t_5 >= PyList_GET_SIZE(__pyx_t_3)) break;
          __pyx_t_1 = PyList_GET_ITEM(__pyx_t_3, __pyx_t_5); __Pyx_INCREF(__pyx_t_1); __pyx_t_5++;
        } else if (likely(PyTuple_CheckExact(__pyx_t_3))) {
          if (__pyx_t_5 >= PyTuple_GET_SIZE(__pyx_t_3)) break;
          __pyx_t_1 = PyTuple_GET_ITEM(__pyx_t_3, __pyx_t_5); __Pyx_INCREF(__pyx_t_1); __pyx_t_5++;
        } else {
          __pyx_t_1 = PyIter_Next(__pyx_t_3);
          if (!__pyx_t_1) {
            if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 314; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
            break;
          }
          __Pyx_GOTREF(__pyx_t_1);
        }
        __pyx_t_4 = __Pyx_PyInt_AsInt(__pyx_t_1); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 314; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        __pyx_v_elem = __pyx_t_4;

        /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":315
 *             if self.sanity_checks:
 *                 for elem in rhs:
 *                     if elem < 0:             # <<<<<<<<<<<<<<
 *                         raise ValueError("Negative numbers, not allowed")
 *                     elif elem > maxelem:
 */
        __pyx_t_2 = (__pyx_v_elem < 0);
        if (__pyx_t_2) {

          /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":316
 *                 for elem in rhs:
 *                     if elem < 0:
 *                         raise ValueError("Negative numbers, not allowed")             # <<<<<<<<<<<<<<
 *                     elif elem > maxelem:
 *                         raise OverflowError("Elements must be <= %s" % maxelem)
 */
          __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 316; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          __Pyx_GOTREF(((PyObject *)__pyx_t_1));
          __Pyx_INCREF(__pyx_kp_29);
          PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_kp_29);
          __Pyx_GIVEREF(__pyx_kp_29);
          __pyx_t_6 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_t_1), NULL); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 316; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          __Pyx_GOTREF(__pyx_t_6);
          __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
          __Pyx_Raise(__pyx_t_6, 0, 0);
          __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
          {__pyx_filename = __pyx_f[0]; __pyx_lineno = 316; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          goto __pyx_L11;
        }

        /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":317
 *                     if elem < 0:
 *                         raise ValueError("Negative numbers, not allowed")
 *                     elif elem > maxelem:             # <<<<<<<<<<<<<<
 *                         raise OverflowError("Elements must be <= %s" % maxelem)
 *                     intBitSetAddElem(self.bitset, elem)
 */
        __pyx_t_2 = (__pyx_v_elem > maxelem);
        if (__pyx_t_2) {

          /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":318
 *                         raise ValueError("Negative numbers, not allowed")
 *                     elif elem > maxelem:
 *                         raise OverflowError("Elements must be <= %s" % maxelem)             # <<<<<<<<<<<<<<
 *                     intBitSetAddElem(self.bitset, elem)
 *             else:
 */
          __pyx_t_6 = PyInt_FromLong(maxelem); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 318; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          __Pyx_GOTREF(__pyx_t_6);
          __pyx_t_1 = PyNumber_Remainder(__pyx_kp_30, __pyx_t_6); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 318; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          __Pyx_GOTREF(__pyx_t_1);
          __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
          __pyx_t_6 = PyTuple_New(1); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 318; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          __Pyx_GOTREF(((PyObject *)__pyx_t_6));
          PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_1);
          __Pyx_GIVEREF(__pyx_t_1);
          __pyx_t_1 = 0;
          __pyx_t_1 = PyObject_Call(__pyx_builtin_OverflowError, ((PyObject *)__pyx_t_6), NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 318; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          __Pyx_GOTREF(__pyx_t_1);
          __Pyx_DECREF(((PyObject *)__pyx_t_6)); __pyx_t_6 = 0;
          __Pyx_Raise(__pyx_t_1, 0, 0);
          __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
          {__pyx_filename = __pyx_f[0]; __pyx_lineno = 318; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          goto __pyx_L11;
        }
        __pyx_L11:;

        /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":319
 *                     elif elem > maxelem:
 *                         raise OverflowError("Elements must be <= %s" % maxelem)
 *                     intBitSetAddElem(self.bitset, elem)             # <<<<<<<<<<<<<<
 *             else:
 *                 for elem in rhs:
 */
        intBitSetAddElem(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset, __pyx_v_elem);
      }
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      goto __pyx_L8;
    }
    /*else*/ {

      /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":321
 *                     intBitSetAddElem(self.bitset, elem)
 *             else:
 *                 for elem in rhs:             # <<<<<<<<<<<<<<
 *                     if elem < 0:
 *                         raise ValueError("Negative numbers, not allowed")
 */
      if (PyList_CheckExact(__pyx_v_rhs) || PyTuple_CheckExact(__pyx_v_rhs)) {
        __pyx_t_5 = 0; __pyx_t_3 = __pyx_v_rhs; __Pyx_INCREF(__pyx_t_3);
      } else {
        __pyx_t_5 = -1; __pyx_t_3 = PyObject_GetIter(__pyx_v_rhs); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 321; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __Pyx_GOTREF(__pyx_t_3);
      }
      for (;;) {
        if (likely(PyList_CheckExact(__pyx_t_3))) {
          if (__pyx_t_5 >= PyList_GET_SIZE(__pyx_t_3)) break;
          __pyx_t_1 = PyList_GET_ITEM(__pyx_t_3, __pyx_t_5); __Pyx_INCREF(__pyx_t_1); __pyx_t_5++;
        } else if (likely(PyTuple_CheckExact(__pyx_t_3))) {
          if (__pyx_t_5 >= PyTuple_GET_SIZE(__pyx_t_3)) break;
          __pyx_t_1 = PyTuple_GET_ITEM(__pyx_t_3, __pyx_t_5); __Pyx_INCREF(__pyx_t_1); __pyx_t_5++;
        } else {
          __pyx_t_1 = PyIter_Next(__pyx_t_3);
          if (!__pyx_t_1) {
            if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 321; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
            break;
          }
          __Pyx_GOTREF(__pyx_t_1);
        }
        __pyx_t_4 = __Pyx_PyInt_AsInt(__pyx_t_1); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 321; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        __pyx_v_elem = __pyx_t_4;

        /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":322
 *             else:
 *                 for elem in rhs:
 *                     if elem < 0:             # <<<<<<<<<<<<<<
 *                         raise ValueError("Negative numbers, not allowed")
 *                     elif elem > maxelem:
 */
        __pyx_t_2 = (__pyx_v_elem < 0);
        if (__pyx_t_2) {

          /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":323
 *                 for elem in rhs:
 *                     if elem < 0:
 *                         raise ValueError("Negative numbers, not allowed")             # <<<<<<<<<<<<<<
 *                     elif elem > maxelem:
 *                         raise OverflowError("Elements must be <= %s" % maxelem)
 */
          __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 323; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          __Pyx_GOTREF(((PyObject *)__pyx_t_1));
          __Pyx_INCREF(__pyx_kp_31);
          PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_kp_31);
          __Pyx_GIVEREF(__pyx_kp_31);
          __pyx_t_6 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_t_1), NULL); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 323; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          __Pyx_GOTREF(__pyx_t_6);
          __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
          __Pyx_Raise(__pyx_t_6, 0, 0);
          __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
          {__pyx_filename = __pyx_f[0]; __pyx_lineno = 323; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          goto __pyx_L14;
        }

        /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":324
 *                     if elem < 0:
 *                         raise ValueError("Negative numbers, not allowed")
 *                     elif elem > maxelem:             # <<<<<<<<<<<<<<
 *                         raise OverflowError("Elements must be <= %s" % maxelem)
 *                     intBitSetAddElem(self.bitset, elem)
 */
        __pyx_t_2 = (__pyx_v_elem > maxelem);
        if (__pyx_t_2) {

          /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":325
 *                         raise ValueError("Negative numbers, not allowed")
 *                     elif elem > maxelem:
 *                         raise OverflowError("Elements must be <= %s" % maxelem)             # <<<<<<<<<<<<<<
 *                     intBitSetAddElem(self.bitset, elem)
 *         return self
 */
          __pyx_t_6 = PyInt_FromLong(maxelem); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 325; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          __Pyx_GOTREF(__pyx_t_6);
          __pyx_t_1 = PyNumber_Remainder(__pyx_kp_32, __pyx_t_6); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 325; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          __Pyx_GOTREF(__pyx_t_1);
          __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
          __pyx_t_6 = PyTuple_New(1); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 325; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          __Pyx_GOTREF(((PyObject *)__pyx_t_6));
          PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_1);
          __Pyx_GIVEREF(__pyx_t_1);
          __pyx_t_1 = 0;
          __pyx_t_1 = PyObject_Call(__pyx_builtin_OverflowError, ((PyObject *)__pyx_t_6), NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 325; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          __Pyx_GOTREF(__pyx_t_1);
          __Pyx_DECREF(((PyObject *)__pyx_t_6)); __pyx_t_6 = 0;
          __Pyx_Raise(__pyx_t_1, 0, 0);
          __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
          {__pyx_filename = __pyx_f[0]; __pyx_lineno = 325; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          goto __pyx_L14;
        }
        __pyx_L14:;

        /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":326
 *                     elif elem > maxelem:
 *                         raise OverflowError("Elements must be <= %s" % maxelem)
 *                     intBitSetAddElem(self.bitset, elem)             # <<<<<<<<<<<<<<
 *         return self
 * 
 */
        intBitSetAddElem(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset, __pyx_v_elem);
      }
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    }
    __pyx_L8:;
  }
  __pyx_L5:;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":327
 *                         raise OverflowError("Elements must be <= %s" % maxelem)
 *                     intBitSetAddElem(self.bitset, elem)
 *         return self             # <<<<<<<<<<<<<<
 * 
 *     def __isub__(self, rhs):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_self);
  __pyx_r = __pyx_v_self;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("lib.intbitset.intbitset.__iadd__");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_FinishRefcountContext();
  return __pyx_r;
}

/* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":329
 *         return self
 * 
 *     def __isub__(self, rhs):             # <<<<<<<<<<<<<<
 *         cdef int elem
 *         if isinstance(rhs, (int, long)):
 */

static PyObject *__pyx_pf_3lib_9intbitset_9intbitset___isub__(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs); /*proto*/
static PyObject *__pyx_pf_3lib_9intbitset_9intbitset___isub__(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs) {
  int __pyx_v_elem;
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  int __pyx_t_4;
  Py_ssize_t __pyx_t_5;
  PyObject *__pyx_t_6 = NULL;
  __Pyx_SetupRefcountContext("__isub__");

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":331
 *     def __isub__(self, rhs):
 *         cdef int elem
 *         if isinstance(rhs, (int, long)):             # <<<<<<<<<<<<<<
 *             if self.sanity_checks:
 *                 if rhs < 0:
 */
  __pyx_t_1 = PyTuple_New(2); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 331; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(((PyObject *)__pyx_t_1));
  __Pyx_INCREF(((PyObject *)((PyObject*)&PyInt_Type)));
  PyTuple_SET_ITEM(__pyx_t_1, 0, ((PyObject *)((PyObject*)&PyInt_Type)));
  __Pyx_GIVEREF(((PyObject *)((PyObject*)&PyInt_Type)));
  __Pyx_INCREF(((PyObject *)((PyObject*)&PyLong_Type)));
  PyTuple_SET_ITEM(__pyx_t_1, 1, ((PyObject *)((PyObject*)&PyLong_Type)));
  __Pyx_GIVEREF(((PyObject *)((PyObject*)&PyLong_Type)));
  __pyx_t_2 = PyObject_IsInstance(__pyx_v_rhs, ((PyObject *)__pyx_t_1)); if (unlikely(__pyx_t_2 == -1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 331; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
  if (__pyx_t_2) {

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":332
 *         cdef int elem
 *         if isinstance(rhs, (int, long)):
 *             if self.sanity_checks:             # <<<<<<<<<<<<<<
 *                 if rhs < 0:
 *                     raise ValueError("Negative numbers, not allowed")
 */
    __pyx_t_2 = ((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->sanity_checks;
    if (__pyx_t_2) {

      /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":333
 *         if isinstance(rhs, (int, long)):
 *             if self.sanity_checks:
 *                 if rhs < 0:             # <<<<<<<<<<<<<<
 *                     raise ValueError("Negative numbers, not allowed")
 *                 elif rhs > maxelem:
 */
      __pyx_t_1 = PyObject_RichCompare(__pyx_v_rhs, __pyx_int_0, Py_LT); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 333; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_1);
      __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 333; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      if (__pyx_t_2) {

        /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":334
 *             if self.sanity_checks:
 *                 if rhs < 0:
 *                     raise ValueError("Negative numbers, not allowed")             # <<<<<<<<<<<<<<
 *                 elif rhs > maxelem:
 *                     raise OverflowError("rhs must be <= %s" % maxelem)
 */
        __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 334; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __Pyx_GOTREF(((PyObject *)__pyx_t_1));
        __Pyx_INCREF(__pyx_kp_33);
        PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_kp_33);
        __Pyx_GIVEREF(__pyx_kp_33);
        __pyx_t_3 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_t_1), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 334; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
        __Pyx_Raise(__pyx_t_3, 0, 0);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        {__pyx_filename = __pyx_f[0]; __pyx_lineno = 334; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        goto __pyx_L7;
      }

      /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":335
 *                 if rhs < 0:
 *                     raise ValueError("Negative numbers, not allowed")
 *                 elif rhs > maxelem:             # <<<<<<<<<<<<<<
 *                     raise OverflowError("rhs must be <= %s" % maxelem)
 *             intBitSetDelElem(self.bitset, rhs)
 */
      __pyx_t_3 = PyInt_FromLong(maxelem); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 335; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_1 = PyObject_RichCompare(__pyx_v_rhs, __pyx_t_3, Py_GT); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 335; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_1); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 335; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      if (__pyx_t_2) {

        /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":336
 *                     raise ValueError("Negative numbers, not allowed")
 *                 elif rhs > maxelem:
 *                     raise OverflowError("rhs must be <= %s" % maxelem)             # <<<<<<<<<<<<<<
 *             intBitSetDelElem(self.bitset, rhs)
 *         elif isinstance(rhs, intbitset):
 */
        __pyx_t_1 = PyInt_FromLong(maxelem); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 336; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __Pyx_GOTREF(__pyx_t_1);
        __pyx_t_3 = PyNumber_Remainder(__pyx_kp_34, __pyx_t_1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 336; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 336; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __Pyx_GOTREF(((PyObject *)__pyx_t_1));
        PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_t_3);
        __Pyx_GIVEREF(__pyx_t_3);
        __pyx_t_3 = 0;
        __pyx_t_3 = PyObject_Call(__pyx_builtin_OverflowError, ((PyObject *)__pyx_t_1), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 336; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __Pyx_GOTREF(__pyx_t_3);
        __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
        __Pyx_Raise(__pyx_t_3, 0, 0);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        {__pyx_filename = __pyx_f[0]; __pyx_lineno = 336; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        goto __pyx_L7;
      }
      __pyx_L7:;
      goto __pyx_L6;
    }
    __pyx_L6:;

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":337
 *                 elif rhs > maxelem:
 *                     raise OverflowError("rhs must be <= %s" % maxelem)
 *             intBitSetDelElem(self.bitset, rhs)             # <<<<<<<<<<<<<<
 *         elif isinstance(rhs, intbitset):
 *             intBitSetISub(self.bitset, (<intbitset> rhs).bitset)
 */
    __pyx_t_4 = __Pyx_PyInt_AsInt(__pyx_v_rhs); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 337; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    intBitSetDelElem(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset, __pyx_t_4);
    goto __pyx_L5;
  }

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":338
 *                     raise OverflowError("rhs must be <= %s" % maxelem)
 *             intBitSetDelElem(self.bitset, rhs)
 *         elif isinstance(rhs, intbitset):             # <<<<<<<<<<<<<<
 *             intBitSetISub(self.bitset, (<intbitset> rhs).bitset)
 *         else:
 */
  __pyx_t_2 = PyObject_TypeCheck(__pyx_v_rhs, ((PyTypeObject *)((PyObject*)__pyx_ptype_3lib_9intbitset_intbitset))); 
  if (__pyx_t_2) {

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":339
 *             intBitSetDelElem(self.bitset, rhs)
 *         elif isinstance(rhs, intbitset):
 *             intBitSetISub(self.bitset, (<intbitset> rhs).bitset)             # <<<<<<<<<<<<<<
 *         else:
 *             if self.sanity_checks:
 */
    intBitSetISub(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset, ((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_rhs)->bitset);
    goto __pyx_L5;
  }
  /*else*/ {

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":341
 *             intBitSetISub(self.bitset, (<intbitset> rhs).bitset)
 *         else:
 *             if self.sanity_checks:             # <<<<<<<<<<<<<<
 *                 for elem in rhs:
 *                     if elem < 0:
 */
    __pyx_t_2 = ((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->sanity_checks;
    if (__pyx_t_2) {

      /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":342
 *         else:
 *             if self.sanity_checks:
 *                 for elem in rhs:             # <<<<<<<<<<<<<<
 *                     if elem < 0:
 *                         raise ValueError("Negative numbers, not allowed")
 */
      if (PyList_CheckExact(__pyx_v_rhs) || PyTuple_CheckExact(__pyx_v_rhs)) {
        __pyx_t_5 = 0; __pyx_t_3 = __pyx_v_rhs; __Pyx_INCREF(__pyx_t_3);
      } else {
        __pyx_t_5 = -1; __pyx_t_3 = PyObject_GetIter(__pyx_v_rhs); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 342; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __Pyx_GOTREF(__pyx_t_3);
      }
      for (;;) {
        if (likely(PyList_CheckExact(__pyx_t_3))) {
          if (__pyx_t_5 >= PyList_GET_SIZE(__pyx_t_3)) break;
          __pyx_t_1 = PyList_GET_ITEM(__pyx_t_3, __pyx_t_5); __Pyx_INCREF(__pyx_t_1); __pyx_t_5++;
        } else if (likely(PyTuple_CheckExact(__pyx_t_3))) {
          if (__pyx_t_5 >= PyTuple_GET_SIZE(__pyx_t_3)) break;
          __pyx_t_1 = PyTuple_GET_ITEM(__pyx_t_3, __pyx_t_5); __Pyx_INCREF(__pyx_t_1); __pyx_t_5++;
        } else {
          __pyx_t_1 = PyIter_Next(__pyx_t_3);
          if (!__pyx_t_1) {
            if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 342; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
            break;
          }
          __Pyx_GOTREF(__pyx_t_1);
        }
        __pyx_t_4 = __Pyx_PyInt_AsInt(__pyx_t_1); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 342; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        __pyx_v_elem = __pyx_t_4;

        /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":343
 *             if self.sanity_checks:
 *                 for elem in rhs:
 *                     if elem < 0:             # <<<<<<<<<<<<<<
 *                         raise ValueError("Negative numbers, not allowed")
 *                     elif elem > maxelem:
 */
        __pyx_t_2 = (__pyx_v_elem < 0);
        if (__pyx_t_2) {

          /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":344
 *                 for elem in rhs:
 *                     if elem < 0:
 *                         raise ValueError("Negative numbers, not allowed")             # <<<<<<<<<<<<<<
 *                     elif elem > maxelem:
 *                         raise OverflowError("Elements must be <= %s" % maxelem)
 */
          __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 344; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          __Pyx_GOTREF(((PyObject *)__pyx_t_1));
          __Pyx_INCREF(__pyx_kp_35);
          PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_kp_35);
          __Pyx_GIVEREF(__pyx_kp_35);
          __pyx_t_6 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_t_1), NULL); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 344; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          __Pyx_GOTREF(__pyx_t_6);
          __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
          __Pyx_Raise(__pyx_t_6, 0, 0);
          __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
          {__pyx_filename = __pyx_f[0]; __pyx_lineno = 344; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          goto __pyx_L11;
        }

        /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":345
 *                     if elem < 0:
 *                         raise ValueError("Negative numbers, not allowed")
 *                     elif elem > maxelem:             # <<<<<<<<<<<<<<
 *                         raise OverflowError("Elements must be <= %s" % maxelem)
 *                     intBitSetDelElem(self.bitset, elem)
 */
        __pyx_t_2 = (__pyx_v_elem > maxelem);
        if (__pyx_t_2) {

          /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":346
 *                         raise ValueError("Negative numbers, not allowed")
 *                     elif elem > maxelem:
 *                         raise OverflowError("Elements must be <= %s" % maxelem)             # <<<<<<<<<<<<<<
 *                     intBitSetDelElem(self.bitset, elem)
 *             else:
 */
          __pyx_t_6 = PyInt_FromLong(maxelem); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 346; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          __Pyx_GOTREF(__pyx_t_6);
          __pyx_t_1 = PyNumber_Remainder(__pyx_kp_36, __pyx_t_6); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 346; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          __Pyx_GOTREF(__pyx_t_1);
          __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
          __pyx_t_6 = PyTuple_New(1); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 346; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          __Pyx_GOTREF(((PyObject *)__pyx_t_6));
          PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_1);
          __Pyx_GIVEREF(__pyx_t_1);
          __pyx_t_1 = 0;
          __pyx_t_1 = PyObject_Call(__pyx_builtin_OverflowError, ((PyObject *)__pyx_t_6), NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 346; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          __Pyx_GOTREF(__pyx_t_1);
          __Pyx_DECREF(((PyObject *)__pyx_t_6)); __pyx_t_6 = 0;
          __Pyx_Raise(__pyx_t_1, 0, 0);
          __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
          {__pyx_filename = __pyx_f[0]; __pyx_lineno = 346; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          goto __pyx_L11;
        }
        __pyx_L11:;

        /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":347
 *                     elif elem > maxelem:
 *                         raise OverflowError("Elements must be <= %s" % maxelem)
 *                     intBitSetDelElem(self.bitset, elem)             # <<<<<<<<<<<<<<
 *             else:
 *                 for elem in rhs:
 */
        intBitSetDelElem(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset, __pyx_v_elem);
      }
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      goto __pyx_L8;
    }
    /*else*/ {

      /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":349
 *                     intBitSetDelElem(self.bitset, elem)
 *             else:
 *                 for elem in rhs:             # <<<<<<<<<<<<<<
 *                     intBitSetDelElem(self.bitset, elem)
 *         return self
 */
      if (PyList_CheckExact(__pyx_v_rhs) || PyTuple_CheckExact(__pyx_v_rhs)) {
        __pyx_t_5 = 0; __pyx_t_3 = __pyx_v_rhs; __Pyx_INCREF(__pyx_t_3);
      } else {
        __pyx_t_5 = -1; __pyx_t_3 = PyObject_GetIter(__pyx_v_rhs); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 349; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __Pyx_GOTREF(__pyx_t_3);
      }
      for (;;) {
        if (likely(PyList_CheckExact(__pyx_t_3))) {
          if (__pyx_t_5 >= PyList_GET_SIZE(__pyx_t_3)) break;
          __pyx_t_1 = PyList_GET_ITEM(__pyx_t_3, __pyx_t_5); __Pyx_INCREF(__pyx_t_1); __pyx_t_5++;
        } else if (likely(PyTuple_CheckExact(__pyx_t_3))) {
          if (__pyx_t_5 >= PyTuple_GET_SIZE(__pyx_t_3)) break;
          __pyx_t_1 = PyTuple_GET_ITEM(__pyx_t_3, __pyx_t_5); __Pyx_INCREF(__pyx_t_1); __pyx_t_5++;
        } else {
          __pyx_t_1 = PyIter_Next(__pyx_t_3);
          if (!__pyx_t_1) {
            if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 349; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
            break;
          }
          __Pyx_GOTREF(__pyx_t_1);
        }
        __pyx_t_4 = __Pyx_PyInt_AsInt(__pyx_t_1); if (unlikely((__pyx_t_4 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 349; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
        __pyx_v_elem = __pyx_t_4;

        /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":350
 *             else:
 *                 for elem in rhs:
 *                     intBitSetDelElem(self.bitset, elem)             # <<<<<<<<<<<<<<
 *         return self
 * 
 */
        intBitSetDelElem(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset, __pyx_v_elem);
      }
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    }
    __pyx_L8:;
  }
  __pyx_L5:;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":351
 *                 for elem in rhs:
 *                     intBitSetDelElem(self.bitset, elem)
 *         return self             # <<<<<<<<<<<<<<
 * 
 *     def __deepcopy__(self, memo):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_self);
  __pyx_r = __pyx_v_self;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("lib.intbitset.intbitset.__isub__");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_FinishRefcountContext();
  return __pyx_r;
}

/* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":353
 *         return self
 * 
 *     def __deepcopy__(self, memo):             # <<<<<<<<<<<<<<
 *         return intbitset(self)
 * 
 */

static PyObject *__pyx_pf_3lib_9intbitset_9intbitset___deepcopy__(PyObject *__pyx_v_self, PyObject *__pyx_v_memo); /*proto*/
static PyObject *__pyx_pf_3lib_9intbitset_9intbitset___deepcopy__(PyObject *__pyx_v_self, PyObject *__pyx_v_memo) {
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  __Pyx_SetupRefcountContext("__deepcopy__");

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":354
 * 
 *     def __deepcopy__(self, memo):
 *         return intbitset(self)             # <<<<<<<<<<<<<<
 * 
 *     def __del__(self, int elem):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 354; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(((PyObject *)__pyx_t_1));
  __Pyx_INCREF(__pyx_v_self);
  PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_self);
  __Pyx_GIVEREF(__pyx_v_self);
  __pyx_t_2 = PyObject_Call(((PyObject *)((PyObject*)__pyx_ptype_3lib_9intbitset_intbitset)), ((PyObject *)__pyx_t_1), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 354; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("lib.intbitset.intbitset.__deepcopy__");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_FinishRefcountContext();
  return __pyx_r;
}

/* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":356
 *         return intbitset(self)
 * 
 *     def __del__(self, int elem):             # <<<<<<<<<<<<<<
 *         if self.sanity_checks:
 *             if elem < 0:
 */

static PyObject *__pyx_pf_3lib_9intbitset_9intbitset___del__(PyObject *__pyx_v_self, PyObject *__pyx_arg_elem); /*proto*/
static PyObject *__pyx_pf_3lib_9intbitset_9intbitset___del__(PyObject *__pyx_v_self, PyObject *__pyx_arg_elem) {
  int __pyx_v_elem;
  PyObject *__pyx_r = NULL;
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_SetupRefcountContext("__del__");
  assert(__pyx_arg_elem); {
    __pyx_v_elem = __Pyx_PyInt_AsInt(__pyx_arg_elem); if (unlikely((__pyx_v_elem == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 356; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("lib.intbitset.intbitset.__del__");
  return NULL;
  __pyx_L4_argument_unpacking_done:;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":357
 * 
 *     def __del__(self, int elem):
 *         if self.sanity_checks:             # <<<<<<<<<<<<<<
 *             if elem < 0:
 *                 raise ValueError("Negative numbers, not allowed")
 */
  __pyx_t_1 = ((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->sanity_checks;
  if (__pyx_t_1) {

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":358
 *     def __del__(self, int elem):
 *         if self.sanity_checks:
 *             if elem < 0:             # <<<<<<<<<<<<<<
 *                 raise ValueError("Negative numbers, not allowed")
 *             elif elem > maxelem:
 */
    __pyx_t_1 = (__pyx_v_elem < 0);
    if (__pyx_t_1) {

      /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":359
 *         if self.sanity_checks:
 *             if elem < 0:
 *                 raise ValueError("Negative numbers, not allowed")             # <<<<<<<<<<<<<<
 *             elif elem > maxelem:
 *                 raise OverflowError("Element must be <= %s" % maxelem)
 */
      __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 359; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(((PyObject *)__pyx_t_2));
      __Pyx_INCREF(__pyx_kp_37);
      PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_kp_37);
      __Pyx_GIVEREF(__pyx_kp_37);
      __pyx_t_3 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_t_2), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 359; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
      __Pyx_Raise(__pyx_t_3, 0, 0);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 359; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      goto __pyx_L6;
    }

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":360
 *             if elem < 0:
 *                 raise ValueError("Negative numbers, not allowed")
 *             elif elem > maxelem:             # <<<<<<<<<<<<<<
 *                 raise OverflowError("Element must be <= %s" % maxelem)
 *         intBitSetDelElem(self.bitset, elem)
 */
    __pyx_t_1 = (__pyx_v_elem > maxelem);
    if (__pyx_t_1) {

      /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":361
 *                 raise ValueError("Negative numbers, not allowed")
 *             elif elem > maxelem:
 *                 raise OverflowError("Element must be <= %s" % maxelem)             # <<<<<<<<<<<<<<
 *         intBitSetDelElem(self.bitset, elem)
 * 
 */
      __pyx_t_3 = PyInt_FromLong(maxelem); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 361; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_2 = PyNumber_Remainder(__pyx_kp_38, __pyx_t_3); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 361; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 361; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(((PyObject *)__pyx_t_3));
      PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_2);
      __Pyx_GIVEREF(__pyx_t_2);
      __pyx_t_2 = 0;
      __pyx_t_2 = PyObject_Call(__pyx_builtin_OverflowError, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 361; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
      __Pyx_Raise(__pyx_t_2, 0, 0);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 361; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      goto __pyx_L6;
    }
    __pyx_L6:;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":362
 *             elif elem > maxelem:
 *                 raise OverflowError("Element must be <= %s" % maxelem)
 *         intBitSetDelElem(self.bitset, elem)             # <<<<<<<<<<<<<<
 * 
 *     def __and__(self, intbitset rhs not None):
 */
  intBitSetDelElem(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset, __pyx_v_elem);

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("lib.intbitset.intbitset.__del__");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_FinishRefcountContext();
  return __pyx_r;
}

/* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":364
 *         intBitSetDelElem(self.bitset, elem)
 * 
 *     def __and__(self, intbitset rhs not None):             # <<<<<<<<<<<<<<
 *         ret = intbitset(no_allocate=1)
 *         (<intbitset>ret).bitset = intBitSetIntersection((<intbitset> self).bitset, rhs.bitset)
 */

static PyObject *__pyx_pf_3lib_9intbitset_9intbitset___and__(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs); /*proto*/
static PyObject *__pyx_pf_3lib_9intbitset_9intbitset___and__(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs) {
  PyObject *__pyx_v_ret;
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_1 = 0;
  PyObject *__pyx_t_1 = NULL;
  __Pyx_SetupRefcountContext("__and__");
  __pyx_v_ret = Py_None; __Pyx_INCREF(Py_None);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_rhs), __pyx_ptype_3lib_9intbitset_intbitset, 0, "rhs", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 364; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":365
 * 
 *     def __and__(self, intbitset rhs not None):
 *         ret = intbitset(no_allocate=1)             # <<<<<<<<<<<<<<
 *         (<intbitset>ret).bitset = intBitSetIntersection((<intbitset> self).bitset, rhs.bitset)
 *         return ret
 */
  __pyx_1 = PyDict_New(); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 365; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(((PyObject *)__pyx_1));
  if (PyDict_SetItem(__pyx_1, __pyx_kp_no_allocate, __pyx_int_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 365; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_1 = PyEval_CallObjectWithKeywords(((PyObject *)((PyObject*)__pyx_ptype_3lib_9intbitset_intbitset)), ((PyObject *)__pyx_empty_tuple), ((PyObject *)__pyx_1)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 365; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(((PyObject *)__pyx_1)); __pyx_1 = 0;
  __Pyx_DECREF(__pyx_v_ret);
  __pyx_v_ret = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":366
 *     def __and__(self, intbitset rhs not None):
 *         ret = intbitset(no_allocate=1)
 *         (<intbitset>ret).bitset = intBitSetIntersection((<intbitset> self).bitset, rhs.bitset)             # <<<<<<<<<<<<<<
 *         return ret
 * 
 */
  ((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_ret)->bitset = intBitSetIntersection(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset, ((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_rhs)->bitset);

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":367
 *         ret = intbitset(no_allocate=1)
 *         (<intbitset>ret).bitset = intBitSetIntersection((<intbitset> self).bitset, rhs.bitset)
 *         return ret             # <<<<<<<<<<<<<<
 * 
 *     def __or__(self, intbitset rhs not None):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_ret);
  __pyx_r = __pyx_v_ret;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_1);
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("lib.intbitset.intbitset.__and__");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_ret);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_FinishRefcountContext();
  return __pyx_r;
}

/* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":369
 *         return ret
 * 
 *     def __or__(self, intbitset rhs not None):             # <<<<<<<<<<<<<<
 *         ret = intbitset(no_allocate=1)
 *         (<intbitset>ret).bitset = intBitSetUnion((<intbitset> self).bitset, rhs.bitset)
 */

static PyObject *__pyx_pf_3lib_9intbitset_9intbitset___or__(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs); /*proto*/
static PyObject *__pyx_pf_3lib_9intbitset_9intbitset___or__(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs) {
  PyObject *__pyx_v_ret;
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_1 = 0;
  PyObject *__pyx_t_1 = NULL;
  __Pyx_SetupRefcountContext("__or__");
  __pyx_v_ret = Py_None; __Pyx_INCREF(Py_None);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_rhs), __pyx_ptype_3lib_9intbitset_intbitset, 0, "rhs", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 369; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":370
 * 
 *     def __or__(self, intbitset rhs not None):
 *         ret = intbitset(no_allocate=1)             # <<<<<<<<<<<<<<
 *         (<intbitset>ret).bitset = intBitSetUnion((<intbitset> self).bitset, rhs.bitset)
 *         return ret
 */
  __pyx_1 = PyDict_New(); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 370; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(((PyObject *)__pyx_1));
  if (PyDict_SetItem(__pyx_1, __pyx_kp_no_allocate, __pyx_int_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 370; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_1 = PyEval_CallObjectWithKeywords(((PyObject *)((PyObject*)__pyx_ptype_3lib_9intbitset_intbitset)), ((PyObject *)__pyx_empty_tuple), ((PyObject *)__pyx_1)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 370; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(((PyObject *)__pyx_1)); __pyx_1 = 0;
  __Pyx_DECREF(__pyx_v_ret);
  __pyx_v_ret = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":371
 *     def __or__(self, intbitset rhs not None):
 *         ret = intbitset(no_allocate=1)
 *         (<intbitset>ret).bitset = intBitSetUnion((<intbitset> self).bitset, rhs.bitset)             # <<<<<<<<<<<<<<
 *         return ret
 * 
 */
  ((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_ret)->bitset = intBitSetUnion(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset, ((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_rhs)->bitset);

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":372
 *         ret = intbitset(no_allocate=1)
 *         (<intbitset>ret).bitset = intBitSetUnion((<intbitset> self).bitset, rhs.bitset)
 *         return ret             # <<<<<<<<<<<<<<
 * 
 *     def __xor__(self, intbitset rhs not None):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_ret);
  __pyx_r = __pyx_v_ret;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_1);
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("lib.intbitset.intbitset.__or__");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_ret);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_FinishRefcountContext();
  return __pyx_r;
}

/* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":374
 *         return ret
 * 
 *     def __xor__(self, intbitset rhs not None):             # <<<<<<<<<<<<<<
 *         ret = intbitset(no_allocate=1)
 *         (<intbitset>ret).bitset = intBitSetXor((<intbitset> self).bitset, rhs.bitset)
 */

static PyObject *__pyx_pf_3lib_9intbitset_9intbitset___xor__(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs); /*proto*/
static PyObject *__pyx_pf_3lib_9intbitset_9intbitset___xor__(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs) {
  PyObject *__pyx_v_ret;
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_1 = 0;
  PyObject *__pyx_t_1 = NULL;
  __Pyx_SetupRefcountContext("__xor__");
  __pyx_v_ret = Py_None; __Pyx_INCREF(Py_None);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_rhs), __pyx_ptype_3lib_9intbitset_intbitset, 0, "rhs", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 374; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":375
 * 
 *     def __xor__(self, intbitset rhs not None):
 *         ret = intbitset(no_allocate=1)             # <<<<<<<<<<<<<<
 *         (<intbitset>ret).bitset = intBitSetXor((<intbitset> self).bitset, rhs.bitset)
 *         return ret
 */
  __pyx_1 = PyDict_New(); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 375; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(((PyObject *)__pyx_1));
  if (PyDict_SetItem(__pyx_1, __pyx_kp_no_allocate, __pyx_int_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 375; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_1 = PyEval_CallObjectWithKeywords(((PyObject *)((PyObject*)__pyx_ptype_3lib_9intbitset_intbitset)), ((PyObject *)__pyx_empty_tuple), ((PyObject *)__pyx_1)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 375; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(((PyObject *)__pyx_1)); __pyx_1 = 0;
  __Pyx_DECREF(__pyx_v_ret);
  __pyx_v_ret = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":376
 *     def __xor__(self, intbitset rhs not None):
 *         ret = intbitset(no_allocate=1)
 *         (<intbitset>ret).bitset = intBitSetXor((<intbitset> self).bitset, rhs.bitset)             # <<<<<<<<<<<<<<
 *         return ret
 * 
 */
  ((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_ret)->bitset = intBitSetXor(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset, ((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_rhs)->bitset);

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":377
 *         ret = intbitset(no_allocate=1)
 *         (<intbitset>ret).bitset = intBitSetXor((<intbitset> self).bitset, rhs.bitset)
 *         return ret             # <<<<<<<<<<<<<<
 * 
 *     def __sub__(self, intbitset rhs not None):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_ret);
  __pyx_r = __pyx_v_ret;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_1);
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("lib.intbitset.intbitset.__xor__");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_ret);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_FinishRefcountContext();
  return __pyx_r;
}

/* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":379
 *         return ret
 * 
 *     def __sub__(self, intbitset rhs not None):             # <<<<<<<<<<<<<<
 *         ret = intbitset(no_allocate=1)
 *         (<intbitset>ret).bitset = intBitSetSub((<intbitset> self).bitset, rhs.bitset)
 */

static PyObject *__pyx_pf_3lib_9intbitset_9intbitset___sub__(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs); /*proto*/
static PyObject *__pyx_pf_3lib_9intbitset_9intbitset___sub__(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs) {
  PyObject *__pyx_v_ret;
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_1 = 0;
  PyObject *__pyx_t_1 = NULL;
  __Pyx_SetupRefcountContext("__sub__");
  __pyx_v_ret = Py_None; __Pyx_INCREF(Py_None);
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_rhs), __pyx_ptype_3lib_9intbitset_intbitset, 0, "rhs", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 379; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":380
 * 
 *     def __sub__(self, intbitset rhs not None):
 *         ret = intbitset(no_allocate=1)             # <<<<<<<<<<<<<<
 *         (<intbitset>ret).bitset = intBitSetSub((<intbitset> self).bitset, rhs.bitset)
 *         return ret
 */
  __pyx_1 = PyDict_New(); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 380; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(((PyObject *)__pyx_1));
  if (PyDict_SetItem(__pyx_1, __pyx_kp_no_allocate, __pyx_int_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 380; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_t_1 = PyEval_CallObjectWithKeywords(((PyObject *)((PyObject*)__pyx_ptype_3lib_9intbitset_intbitset)), ((PyObject *)__pyx_empty_tuple), ((PyObject *)__pyx_1)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 380; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(((PyObject *)__pyx_1)); __pyx_1 = 0;
  __Pyx_DECREF(__pyx_v_ret);
  __pyx_v_ret = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":381
 *     def __sub__(self, intbitset rhs not None):
 *         ret = intbitset(no_allocate=1)
 *         (<intbitset>ret).bitset = intBitSetSub((<intbitset> self).bitset, rhs.bitset)             # <<<<<<<<<<<<<<
 *         return ret
 * 
 */
  ((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_ret)->bitset = intBitSetSub(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset, ((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_rhs)->bitset);

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":382
 *         ret = intbitset(no_allocate=1)
 *         (<intbitset>ret).bitset = intBitSetSub((<intbitset> self).bitset, rhs.bitset)
 *         return ret             # <<<<<<<<<<<<<<
 * 
 *     def __iand__(self, intbitset rhs not None):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_ret);
  __pyx_r = __pyx_v_ret;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_1);
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("lib.intbitset.intbitset.__sub__");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_ret);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_FinishRefcountContext();
  return __pyx_r;
}

/* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":384
 *         return ret
 * 
 *     def __iand__(self, intbitset rhs not None):             # <<<<<<<<<<<<<<
 *         intBitSetIIntersection(self.bitset, rhs.bitset)
 *         return self
 */

static PyObject *__pyx_pf_3lib_9intbitset_9intbitset___iand__(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs); /*proto*/
static PyObject *__pyx_pf_3lib_9intbitset_9intbitset___iand__(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs) {
  PyObject *__pyx_r = NULL;
  __Pyx_SetupRefcountContext("__iand__");
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_rhs), __pyx_ptype_3lib_9intbitset_intbitset, 0, "rhs", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 384; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":385
 * 
 *     def __iand__(self, intbitset rhs not None):
 *         intBitSetIIntersection(self.bitset, rhs.bitset)             # <<<<<<<<<<<<<<
 *         return self
 * 
 */
  intBitSetIIntersection(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset, ((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_rhs)->bitset);

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":386
 *     def __iand__(self, intbitset rhs not None):
 *         intBitSetIIntersection(self.bitset, rhs.bitset)
 *         return self             # <<<<<<<<<<<<<<
 * 
 *     def __ior__(self, intbitset rhs not None):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_self);
  __pyx_r = __pyx_v_self;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("lib.intbitset.intbitset.__iand__");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_FinishRefcountContext();
  return __pyx_r;
}

/* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":388
 *         return self
 * 
 *     def __ior__(self, intbitset rhs not None):             # <<<<<<<<<<<<<<
 *         intBitSetIUnion(self.bitset, rhs.bitset)
 *         return self
 */

static PyObject *__pyx_pf_3lib_9intbitset_9intbitset___ior__(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs); /*proto*/
static PyObject *__pyx_pf_3lib_9intbitset_9intbitset___ior__(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs) {
  PyObject *__pyx_r = NULL;
  __Pyx_SetupRefcountContext("__ior__");
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_rhs), __pyx_ptype_3lib_9intbitset_intbitset, 0, "rhs", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 388; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":389
 * 
 *     def __ior__(self, intbitset rhs not None):
 *         intBitSetIUnion(self.bitset, rhs.bitset)             # <<<<<<<<<<<<<<
 *         return self
 * 
 */
  intBitSetIUnion(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset, ((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_rhs)->bitset);

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":390
 *     def __ior__(self, intbitset rhs not None):
 *         intBitSetIUnion(self.bitset, rhs.bitset)
 *         return self             # <<<<<<<<<<<<<<
 * 
 *     def __ixor__(self, intbitset rhs not None):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_self);
  __pyx_r = __pyx_v_self;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("lib.intbitset.intbitset.__ior__");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_FinishRefcountContext();
  return __pyx_r;
}

/* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":392
 *         return self
 * 
 *     def __ixor__(self, intbitset rhs not None):             # <<<<<<<<<<<<<<
 *         intBitSetIXor(self.bitset, rhs.bitset)
 *         return self
 */

static PyObject *__pyx_pf_3lib_9intbitset_9intbitset___ixor__(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs); /*proto*/
static PyObject *__pyx_pf_3lib_9intbitset_9intbitset___ixor__(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs) {
  PyObject *__pyx_r = NULL;
  __Pyx_SetupRefcountContext("__ixor__");
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_rhs), __pyx_ptype_3lib_9intbitset_intbitset, 0, "rhs", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 392; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":393
 * 
 *     def __ixor__(self, intbitset rhs not None):
 *         intBitSetIXor(self.bitset, rhs.bitset)             # <<<<<<<<<<<<<<
 *         return self
 * 
 */
  intBitSetIXor(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset, ((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_rhs)->bitset);

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":394
 *     def __ixor__(self, intbitset rhs not None):
 *         intBitSetIXor(self.bitset, rhs.bitset)
 *         return self             # <<<<<<<<<<<<<<
 * 
 *     def __repr__(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_self);
  __pyx_r = __pyx_v_self;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_AddTraceback("lib.intbitset.intbitset.__ixor__");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_FinishRefcountContext();
  return __pyx_r;
}

/* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":396
 *         return self
 * 
 *     def __repr__(self):             # <<<<<<<<<<<<<<
 *         cdef int last
 *         cdef int maxelem
 */

static PyObject *__pyx_pf_3lib_9intbitset_9intbitset___repr__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pf_3lib_9intbitset_9intbitset___repr__(PyObject *__pyx_v_self) {
  int __pyx_v_last;
  int __pyx_v_maxelem;
  PyObject *__pyx_v_ret;
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_1 = 0;
  word_t __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  __Pyx_SetupRefcountContext("__repr__");
  __pyx_v_ret = Py_None; __Pyx_INCREF(Py_None);

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":399
 *         cdef int last
 *         cdef int maxelem
 *         if self.bitset.trailing_bits:             # <<<<<<<<<<<<<<
 *             maxelem = (intBitSetGetSize(self.bitset)) * wordbitsize
 *             ret = "intbitset(["
 */
  __pyx_t_1 = ((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset->trailing_bits;
  if (__pyx_t_1) {

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":400
 *         cdef int maxelem
 *         if self.bitset.trailing_bits:
 *             maxelem = (intBitSetGetSize(self.bitset)) * wordbitsize             # <<<<<<<<<<<<<<
 *             ret = "intbitset(["
 *             last = -1
 */
    __pyx_v_maxelem = (intBitSetGetSize(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset) * wordbitsize);

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":401
 *         if self.bitset.trailing_bits:
 *             maxelem = (intBitSetGetSize(self.bitset)) * wordbitsize
 *             ret = "intbitset(["             # <<<<<<<<<<<<<<
 *             last = -1
 *             while last < maxelem:
 */
    __Pyx_INCREF(__pyx_kp_39);
    __Pyx_DECREF(__pyx_v_ret);
    __pyx_v_ret = __pyx_kp_39;

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":402
 *             maxelem = (intBitSetGetSize(self.bitset)) * wordbitsize
 *             ret = "intbitset(["
 *             last = -1             # <<<<<<<<<<<<<<
 *             while last < maxelem:
 *                 last = intBitSetGetNext(self.bitset, last)
 */
    __pyx_v_last = -1;

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":403
 *             ret = "intbitset(["
 *             last = -1
 *             while last < maxelem:             # <<<<<<<<<<<<<<
 *                 last = intBitSetGetNext(self.bitset, last)
 *                 ret = ret + '%i, ' % last
 */
    while (1) {
      __pyx_t_2 = (__pyx_v_last < __pyx_v_maxelem);
      if (!__pyx_t_2) break;

      /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":404
 *             last = -1
 *             while last < maxelem:
 *                 last = intBitSetGetNext(self.bitset, last)             # <<<<<<<<<<<<<<
 *                 ret = ret + '%i, ' % last
 *             if ret.endswith(", "):
 */
      __pyx_v_last = intBitSetGetNext(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset, __pyx_v_last);

      /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":405
 *             while last < maxelem:
 *                 last = intBitSetGetNext(self.bitset, last)
 *                 ret = ret + '%i, ' % last             # <<<<<<<<<<<<<<
 *             if ret.endswith(", "):
 *                 ret = ret[:-2]
 */
      __pyx_t_3 = PyInt_FromLong(__pyx_v_last); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 405; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_4 = PyNumber_Remainder(__pyx_kp_40, __pyx_t_3); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 405; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_3 = PyNumber_Add(__pyx_v_ret, __pyx_t_4); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 405; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_DECREF(__pyx_v_ret);
      __pyx_v_ret = __pyx_t_3;
      __pyx_t_3 = 0;
    }

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":406
 *                 last = intBitSetGetNext(self.bitset, last)
 *                 ret = ret + '%i, ' % last
 *             if ret.endswith(", "):             # <<<<<<<<<<<<<<
 *                 ret = ret[:-2]
 *             ret = ret + '], trailing_bits=True)'
 */
    __pyx_t_3 = PyObject_GetAttr(__pyx_v_ret, __pyx_kp_endswith); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 406; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 406; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(((PyObject *)__pyx_t_4));
    __Pyx_INCREF(__pyx_kp_41);
    PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_kp_41);
    __Pyx_GIVEREF(__pyx_kp_41);
    __pyx_t_5 = PyObject_Call(__pyx_t_3, ((PyObject *)__pyx_t_4), NULL); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 406; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(((PyObject *)__pyx_t_4)); __pyx_t_4 = 0;
    __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_5); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 406; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    if (__pyx_t_2) {

      /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":407
 *                 ret = ret + '%i, ' % last
 *             if ret.endswith(", "):
 *                 ret = ret[:-2]             # <<<<<<<<<<<<<<
 *             ret = ret + '], trailing_bits=True)'
 *             return ret
 */
      __pyx_1 = PySequence_GetSlice(__pyx_v_ret, 0, -2); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 407; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_1);
      __Pyx_DECREF(__pyx_v_ret);
      __pyx_v_ret = __pyx_1;
      __pyx_1 = 0;
      goto __pyx_L8;
    }
    __pyx_L8:;

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":408
 *             if ret.endswith(", "):
 *                 ret = ret[:-2]
 *             ret = ret + '], trailing_bits=True)'             # <<<<<<<<<<<<<<
 *             return ret
 *         else:
 */
    __pyx_t_5 = PyNumber_Add(__pyx_v_ret, __pyx_kp_42); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 408; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_5);
    __Pyx_DECREF(__pyx_v_ret);
    __pyx_v_ret = __pyx_t_5;
    __pyx_t_5 = 0;

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":409
 *                 ret = ret[:-2]
 *             ret = ret + '], trailing_bits=True)'
 *             return ret             # <<<<<<<<<<<<<<
 *         else:
 *             ret = "intbitset(["
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(__pyx_v_ret);
    __pyx_r = __pyx_v_ret;
    goto __pyx_L0;
    goto __pyx_L5;
  }
  /*else*/ {

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":411
 *             return ret
 *         else:
 *             ret = "intbitset(["             # <<<<<<<<<<<<<<
 *             last = -1
 *             while last >= -1:
 */
    __Pyx_INCREF(__pyx_kp_43);
    __Pyx_DECREF(__pyx_v_ret);
    __pyx_v_ret = __pyx_kp_43;

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":412
 *         else:
 *             ret = "intbitset(["
 *             last = -1             # <<<<<<<<<<<<<<
 *             while last >= -1:
 *                 last = intBitSetGetNext(self.bitset, last)
 */
    __pyx_v_last = -1;

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":413
 *             ret = "intbitset(["
 *             last = -1
 *             while last >= -1:             # <<<<<<<<<<<<<<
 *                 last = intBitSetGetNext(self.bitset, last)
 *                 ret = ret + '%i, ' % last
 */
    while (1) {
      __pyx_t_2 = (__pyx_v_last >= -1);
      if (!__pyx_t_2) break;

      /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":414
 *             last = -1
 *             while last >= -1:
 *                 last = intBitSetGetNext(self.bitset, last)             # <<<<<<<<<<<<<<
 *                 ret = ret + '%i, ' % last
 *             ret = ret[:-4] # -len('-2, ')
 */
      __pyx_v_last = intBitSetGetNext(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset, __pyx_v_last);

      /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":415
 *             while last >= -1:
 *                 last = intBitSetGetNext(self.bitset, last)
 *                 ret = ret + '%i, ' % last             # <<<<<<<<<<<<<<
 *             ret = ret[:-4] # -len('-2, ')
 *             if ret.endswith(', '):
 */
      __pyx_t_5 = PyInt_FromLong(__pyx_v_last); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 415; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      __pyx_t_4 = PyNumber_Remainder(__pyx_kp_44, __pyx_t_5); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 415; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
      __pyx_t_5 = PyNumber_Add(__pyx_v_ret, __pyx_t_4); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 415; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_5);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_DECREF(__pyx_v_ret);
      __pyx_v_ret = __pyx_t_5;
      __pyx_t_5 = 0;
    }

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":416
 *                 last = intBitSetGetNext(self.bitset, last)
 *                 ret = ret + '%i, ' % last
 *             ret = ret[:-4] # -len('-2, ')             # <<<<<<<<<<<<<<
 *             if ret.endswith(', '):
 *                 ret = ret[:-2]
 */
    __pyx_1 = PySequence_GetSlice(__pyx_v_ret, 0, -4); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 416; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_1);
    __Pyx_DECREF(__pyx_v_ret);
    __pyx_v_ret = __pyx_1;
    __pyx_1 = 0;

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":417
 *                 ret = ret + '%i, ' % last
 *             ret = ret[:-4] # -len('-2, ')
 *             if ret.endswith(', '):             # <<<<<<<<<<<<<<
 *                 ret = ret[:-2]
 *             ret = ret + '])'
 */
    __pyx_t_5 = PyObject_GetAttr(__pyx_v_ret, __pyx_kp_endswith); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 417; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_5);
    __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 417; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(((PyObject *)__pyx_t_4));
    __Pyx_INCREF(__pyx_kp_45);
    PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_kp_45);
    __Pyx_GIVEREF(__pyx_kp_45);
    __pyx_t_3 = PyObject_Call(__pyx_t_5, ((PyObject *)__pyx_t_4), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 417; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_5); __pyx_t_5 = 0;
    __Pyx_DECREF(((PyObject *)__pyx_t_4)); __pyx_t_4 = 0;
    __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_t_3); if (unlikely(__pyx_t_2 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 417; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    if (__pyx_t_2) {

      /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":418
 *             ret = ret[:-4] # -len('-2, ')
 *             if ret.endswith(', '):
 *                 ret = ret[:-2]             # <<<<<<<<<<<<<<
 *             ret = ret + '])'
 *             return ret
 */
      __pyx_1 = PySequence_GetSlice(__pyx_v_ret, 0, -2); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 418; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_1);
      __Pyx_DECREF(__pyx_v_ret);
      __pyx_v_ret = __pyx_1;
      __pyx_1 = 0;
      goto __pyx_L11;
    }
    __pyx_L11:;

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":419
 *             if ret.endswith(', '):
 *                 ret = ret[:-2]
 *             ret = ret + '])'             # <<<<<<<<<<<<<<
 *             return ret
 * 
 */
    __pyx_t_3 = PyNumber_Add(__pyx_v_ret, __pyx_kp_46); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 419; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_v_ret);
    __pyx_v_ret = __pyx_t_3;
    __pyx_t_3 = 0;

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":420
 *                 ret = ret[:-2]
 *             ret = ret + '])'
 *             return ret             # <<<<<<<<<<<<<<
 * 
 *     def __str__(self):
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(__pyx_v_ret);
    __pyx_r = __pyx_v_ret;
    goto __pyx_L0;
  }
  __pyx_L5:;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_1);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_AddTraceback("lib.intbitset.intbitset.__repr__");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_ret);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_FinishRefcountContext();
  return __pyx_r;
}

/* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":422
 *             return ret
 * 
 *     def __str__(self):             # <<<<<<<<<<<<<<
 *         cdef int tot
 *         tot = intBitSetGetTot(self.bitset)
 */

static PyObject *__pyx_pf_3lib_9intbitset_9intbitset___str__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pf_3lib_9intbitset_9intbitset___str__(PyObject *__pyx_v_self) {
  int __pyx_v_tot;
  PyObject *__pyx_v_begin_list;
  PyObject *__pyx_v_ret;
  PyObject *__pyx_v_n;
  PyObject *__pyx_v_end_list;
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_1 = 0;
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  Py_ssize_t __pyx_t_5;
  PyObject *__pyx_t_6 = NULL;
  __Pyx_SetupRefcountContext("__str__");
  __pyx_v_begin_list = Py_None; __Pyx_INCREF(Py_None);
  __pyx_v_ret = Py_None; __Pyx_INCREF(Py_None);
  __pyx_v_n = Py_None; __Pyx_INCREF(Py_None);
  __pyx_v_end_list = Py_None; __Pyx_INCREF(Py_None);

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":424
 *     def __str__(self):
 *         cdef int tot
 *         tot = intBitSetGetTot(self.bitset)             # <<<<<<<<<<<<<<
 *         if tot < 0:
 *             begin_list = self.to_sorted_list(0, 10)
 */
  __pyx_v_tot = intBitSetGetTot(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset);

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":425
 *         cdef int tot
 *         tot = intBitSetGetTot(self.bitset)
 *         if tot < 0:             # <<<<<<<<<<<<<<
 *             begin_list = self.to_sorted_list(0, 10)
 *             ret = "intbitset(["
 */
  __pyx_t_1 = (__pyx_v_tot < 0);
  if (__pyx_t_1) {

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":426
 *         tot = intBitSetGetTot(self.bitset)
 *         if tot < 0:
 *             begin_list = self.to_sorted_list(0, 10)             # <<<<<<<<<<<<<<
 *             ret = "intbitset(["
 *             for n in begin_list:
 */
    __pyx_t_2 = PyObject_GetAttr(__pyx_v_self, __pyx_kp_to_sorted_list); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 426; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_3 = PyTuple_New(2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 426; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(((PyObject *)__pyx_t_3));
    __Pyx_INCREF(__pyx_int_0);
    PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_int_0);
    __Pyx_GIVEREF(__pyx_int_0);
    __Pyx_INCREF(__pyx_int_10);
    PyTuple_SET_ITEM(__pyx_t_3, 1, __pyx_int_10);
    __Pyx_GIVEREF(__pyx_int_10);
    __pyx_t_4 = PyObject_Call(__pyx_t_2, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 426; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
    __Pyx_DECREF(__pyx_v_begin_list);
    __pyx_v_begin_list = __pyx_t_4;
    __pyx_t_4 = 0;

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":427
 *         if tot < 0:
 *             begin_list = self.to_sorted_list(0, 10)
 *             ret = "intbitset(["             # <<<<<<<<<<<<<<
 *             for n in begin_list:
 *                 ret = ret + '%i, ' % n
 */
    __Pyx_INCREF(__pyx_kp_47);
    __Pyx_DECREF(__pyx_v_ret);
    __pyx_v_ret = __pyx_kp_47;

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":428
 *             begin_list = self.to_sorted_list(0, 10)
 *             ret = "intbitset(["
 *             for n in begin_list:             # <<<<<<<<<<<<<<
 *                 ret = ret + '%i, ' % n
 *             ret = ret + "...])"
 */
    if (PyList_CheckExact(__pyx_v_begin_list) || PyTuple_CheckExact(__pyx_v_begin_list)) {
      __pyx_t_5 = 0; __pyx_t_4 = __pyx_v_begin_list; __Pyx_INCREF(__pyx_t_4);
    } else {
      __pyx_t_5 = -1; __pyx_t_4 = PyObject_GetIter(__pyx_v_begin_list); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 428; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_4);
    }
    for (;;) {
      if (likely(PyList_CheckExact(__pyx_t_4))) {
        if (__pyx_t_5 >= PyList_GET_SIZE(__pyx_t_4)) break;
        __pyx_t_3 = PyList_GET_ITEM(__pyx_t_4, __pyx_t_5); __Pyx_INCREF(__pyx_t_3); __pyx_t_5++;
      } else if (likely(PyTuple_CheckExact(__pyx_t_4))) {
        if (__pyx_t_5 >= PyTuple_GET_SIZE(__pyx_t_4)) break;
        __pyx_t_3 = PyTuple_GET_ITEM(__pyx_t_4, __pyx_t_5); __Pyx_INCREF(__pyx_t_3); __pyx_t_5++;
      } else {
        __pyx_t_3 = PyIter_Next(__pyx_t_4);
        if (!__pyx_t_3) {
          if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 428; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          break;
        }
        __Pyx_GOTREF(__pyx_t_3);
      }
      __Pyx_DECREF(__pyx_v_n);
      __pyx_v_n = __pyx_t_3;
      __pyx_t_3 = 0;

      /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":429
 *             ret = "intbitset(["
 *             for n in begin_list:
 *                 ret = ret + '%i, ' % n             # <<<<<<<<<<<<<<
 *             ret = ret + "...])"
 *             return ret
 */
      __pyx_t_3 = PyNumber_Remainder(__pyx_kp_48, __pyx_v_n); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 429; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_2 = PyNumber_Add(__pyx_v_ret, __pyx_t_3); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 429; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_DECREF(__pyx_v_ret);
      __pyx_v_ret = __pyx_t_2;
      __pyx_t_2 = 0;
    }
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":430
 *             for n in begin_list:
 *                 ret = ret + '%i, ' % n
 *             ret = ret + "...])"             # <<<<<<<<<<<<<<
 *             return ret
 *         elif tot > 10:
 */
    __pyx_t_4 = PyNumber_Add(__pyx_v_ret, __pyx_kp_49); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 430; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_v_ret);
    __pyx_v_ret = __pyx_t_4;
    __pyx_t_4 = 0;

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":431
 *                 ret = ret + '%i, ' % n
 *             ret = ret + "...])"
 *             return ret             # <<<<<<<<<<<<<<
 *         elif tot > 10:
 *             begin_list = self.to_sorted_list(0, 5)
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(__pyx_v_ret);
    __pyx_r = __pyx_v_ret;
    goto __pyx_L0;
    goto __pyx_L5;
  }

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":432
 *             ret = ret + "...])"
 *             return ret
 *         elif tot > 10:             # <<<<<<<<<<<<<<
 *             begin_list = self.to_sorted_list(0, 5)
 *             end_list = self.to_sorted_list(tot - 5, tot)
 */
  __pyx_t_1 = (__pyx_v_tot > 10);
  if (__pyx_t_1) {

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":433
 *             return ret
 *         elif tot > 10:
 *             begin_list = self.to_sorted_list(0, 5)             # <<<<<<<<<<<<<<
 *             end_list = self.to_sorted_list(tot - 5, tot)
 *             ret = "intbitset(["
 */
    __pyx_t_4 = PyObject_GetAttr(__pyx_v_self, __pyx_kp_to_sorted_list); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 433; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_2 = PyTuple_New(2); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 433; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(((PyObject *)__pyx_t_2));
    __Pyx_INCREF(__pyx_int_0);
    PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_int_0);
    __Pyx_GIVEREF(__pyx_int_0);
    __Pyx_INCREF(__pyx_int_5);
    PyTuple_SET_ITEM(__pyx_t_2, 1, __pyx_int_5);
    __Pyx_GIVEREF(__pyx_int_5);
    __pyx_t_3 = PyObject_Call(__pyx_t_4, ((PyObject *)__pyx_t_2), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 433; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
    __Pyx_DECREF(__pyx_v_begin_list);
    __pyx_v_begin_list = __pyx_t_3;
    __pyx_t_3 = 0;

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":434
 *         elif tot > 10:
 *             begin_list = self.to_sorted_list(0, 5)
 *             end_list = self.to_sorted_list(tot - 5, tot)             # <<<<<<<<<<<<<<
 *             ret = "intbitset(["
 *             for n in begin_list:
 */
    __pyx_t_3 = PyObject_GetAttr(__pyx_v_self, __pyx_kp_to_sorted_list); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 434; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_2 = PyInt_FromLong((__pyx_v_tot - 5)); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 434; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_4 = PyInt_FromLong(__pyx_v_tot); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 434; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_6 = PyTuple_New(2); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 434; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(((PyObject *)__pyx_t_6));
    PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_2);
    __Pyx_GIVEREF(__pyx_t_2);
    PyTuple_SET_ITEM(__pyx_t_6, 1, __pyx_t_4);
    __Pyx_GIVEREF(__pyx_t_4);
    __pyx_t_2 = 0;
    __pyx_t_4 = 0;
    __pyx_t_4 = PyObject_Call(__pyx_t_3, ((PyObject *)__pyx_t_6), NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 434; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    __Pyx_DECREF(((PyObject *)__pyx_t_6)); __pyx_t_6 = 0;
    __Pyx_DECREF(__pyx_v_end_list);
    __pyx_v_end_list = __pyx_t_4;
    __pyx_t_4 = 0;

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":435
 *             begin_list = self.to_sorted_list(0, 5)
 *             end_list = self.to_sorted_list(tot - 5, tot)
 *             ret = "intbitset(["             # <<<<<<<<<<<<<<
 *             for n in begin_list:
 *                 ret = ret + '%i, ' % n
 */
    __Pyx_INCREF(__pyx_kp_50);
    __Pyx_DECREF(__pyx_v_ret);
    __pyx_v_ret = __pyx_kp_50;

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":436
 *             end_list = self.to_sorted_list(tot - 5, tot)
 *             ret = "intbitset(["
 *             for n in begin_list:             # <<<<<<<<<<<<<<
 *                 ret = ret + '%i, ' % n
 *             ret = ret + "..., "
 */
    if (PyList_CheckExact(__pyx_v_begin_list) || PyTuple_CheckExact(__pyx_v_begin_list)) {
      __pyx_t_5 = 0; __pyx_t_4 = __pyx_v_begin_list; __Pyx_INCREF(__pyx_t_4);
    } else {
      __pyx_t_5 = -1; __pyx_t_4 = PyObject_GetIter(__pyx_v_begin_list); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 436; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_4);
    }
    for (;;) {
      if (likely(PyList_CheckExact(__pyx_t_4))) {
        if (__pyx_t_5 >= PyList_GET_SIZE(__pyx_t_4)) break;
        __pyx_t_6 = PyList_GET_ITEM(__pyx_t_4, __pyx_t_5); __Pyx_INCREF(__pyx_t_6); __pyx_t_5++;
      } else if (likely(PyTuple_CheckExact(__pyx_t_4))) {
        if (__pyx_t_5 >= PyTuple_GET_SIZE(__pyx_t_4)) break;
        __pyx_t_6 = PyTuple_GET_ITEM(__pyx_t_4, __pyx_t_5); __Pyx_INCREF(__pyx_t_6); __pyx_t_5++;
      } else {
        __pyx_t_6 = PyIter_Next(__pyx_t_4);
        if (!__pyx_t_6) {
          if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 436; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          break;
        }
        __Pyx_GOTREF(__pyx_t_6);
      }
      __Pyx_DECREF(__pyx_v_n);
      __pyx_v_n = __pyx_t_6;
      __pyx_t_6 = 0;

      /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":437
 *             ret = "intbitset(["
 *             for n in begin_list:
 *                 ret = ret + '%i, ' % n             # <<<<<<<<<<<<<<
 *             ret = ret + "..., "
 *             for n in end_list:
 */
      __pyx_t_6 = PyNumber_Remainder(__pyx_kp_51, __pyx_v_n); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 437; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_6);
      __pyx_t_3 = PyNumber_Add(__pyx_v_ret, __pyx_t_6); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 437; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      __Pyx_DECREF(__pyx_v_ret);
      __pyx_v_ret = __pyx_t_3;
      __pyx_t_3 = 0;
    }
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":438
 *             for n in begin_list:
 *                 ret = ret + '%i, ' % n
 *             ret = ret + "..., "             # <<<<<<<<<<<<<<
 *             for n in end_list:
 *                 ret = ret + '%i, ' % n
 */
    __pyx_t_4 = PyNumber_Add(__pyx_v_ret, __pyx_kp_52); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 438; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_v_ret);
    __pyx_v_ret = __pyx_t_4;
    __pyx_t_4 = 0;

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":439
 *                 ret = ret + '%i, ' % n
 *             ret = ret + "..., "
 *             for n in end_list:             # <<<<<<<<<<<<<<
 *                 ret = ret + '%i, ' % n
 *             ret = ret[:-2]
 */
    if (PyList_CheckExact(__pyx_v_end_list) || PyTuple_CheckExact(__pyx_v_end_list)) {
      __pyx_t_5 = 0; __pyx_t_4 = __pyx_v_end_list; __Pyx_INCREF(__pyx_t_4);
    } else {
      __pyx_t_5 = -1; __pyx_t_4 = PyObject_GetIter(__pyx_v_end_list); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 439; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_4);
    }
    for (;;) {
      if (likely(PyList_CheckExact(__pyx_t_4))) {
        if (__pyx_t_5 >= PyList_GET_SIZE(__pyx_t_4)) break;
        __pyx_t_3 = PyList_GET_ITEM(__pyx_t_4, __pyx_t_5); __Pyx_INCREF(__pyx_t_3); __pyx_t_5++;
      } else if (likely(PyTuple_CheckExact(__pyx_t_4))) {
        if (__pyx_t_5 >= PyTuple_GET_SIZE(__pyx_t_4)) break;
        __pyx_t_3 = PyTuple_GET_ITEM(__pyx_t_4, __pyx_t_5); __Pyx_INCREF(__pyx_t_3); __pyx_t_5++;
      } else {
        __pyx_t_3 = PyIter_Next(__pyx_t_4);
        if (!__pyx_t_3) {
          if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 439; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
          break;
        }
        __Pyx_GOTREF(__pyx_t_3);
      }
      __Pyx_DECREF(__pyx_v_n);
      __pyx_v_n = __pyx_t_3;
      __pyx_t_3 = 0;

      /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":440
 *             ret = ret + "..., "
 *             for n in end_list:
 *                 ret = ret + '%i, ' % n             # <<<<<<<<<<<<<<
 *             ret = ret[:-2]
 *             ret = ret + '])'
 */
      __pyx_t_3 = PyNumber_Remainder(__pyx_kp_53, __pyx_v_n); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 440; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_6 = PyNumber_Add(__pyx_v_ret, __pyx_t_3); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 440; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_DECREF(__pyx_v_ret);
      __pyx_v_ret = __pyx_t_6;
      __pyx_t_6 = 0;
    }
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":441
 *             for n in end_list:
 *                 ret = ret + '%i, ' % n
 *             ret = ret[:-2]             # <<<<<<<<<<<<<<
 *             ret = ret + '])'
 *             return ret
 */
    __pyx_1 = PySequence_GetSlice(__pyx_v_ret, 0, -2); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 441; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_1);
    __Pyx_DECREF(__pyx_v_ret);
    __pyx_v_ret = __pyx_1;
    __pyx_1 = 0;

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":442
 *                 ret = ret + '%i, ' % n
 *             ret = ret[:-2]
 *             ret = ret + '])'             # <<<<<<<<<<<<<<
 *             return ret
 *         else:
 */
    __pyx_t_4 = PyNumber_Add(__pyx_v_ret, __pyx_kp_54); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 442; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_v_ret);
    __pyx_v_ret = __pyx_t_4;
    __pyx_t_4 = 0;

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":443
 *             ret = ret[:-2]
 *             ret = ret + '])'
 *             return ret             # <<<<<<<<<<<<<<
 *         else:
 *             return self.__repr__()
 */
    __Pyx_XDECREF(__pyx_r);
    __Pyx_INCREF(__pyx_v_ret);
    __pyx_r = __pyx_v_ret;
    goto __pyx_L0;
    goto __pyx_L5;
  }
  /*else*/ {

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":445
 *             return ret
 *         else:
 *             return self.__repr__()             # <<<<<<<<<<<<<<
 * 
 *     ## Buffer interface
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_4 = PyObject_GetAttr(__pyx_v_self, __pyx_kp___repr__); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 445; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_6 = PyObject_Call(__pyx_t_4, ((PyObject *)__pyx_empty_tuple), NULL); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 445; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_r = __pyx_t_6;
    __pyx_t_6 = 0;
    goto __pyx_L0;
  }
  __pyx_L5:;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("lib.intbitset.intbitset.__str__");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_begin_list);
  __Pyx_DECREF(__pyx_v_ret);
  __Pyx_DECREF(__pyx_v_n);
  __Pyx_DECREF(__pyx_v_end_list);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_FinishRefcountContext();
  return __pyx_r;
}

/* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":472
 * 
 *     # Iterator interface
 *     def __iter__(self):             # <<<<<<<<<<<<<<
 *         if self.bitset.trailing_bits:
 *             raise OverflowError("It's impossible to iterate over an infinite set.")
 */

static PyObject *__pyx_pf_3lib_9intbitset_9intbitset___iter__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pf_3lib_9intbitset_9intbitset___iter__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  word_t __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_SetupRefcountContext("__iter__");

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":473
 *     # Iterator interface
 *     def __iter__(self):
 *         if self.bitset.trailing_bits:             # <<<<<<<<<<<<<<
 *             raise OverflowError("It's impossible to iterate over an infinite set.")
 *         return intbitset_iterator(self)
 */
  __pyx_t_1 = ((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset->trailing_bits;
  if (__pyx_t_1) {

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":474
 *     def __iter__(self):
 *         if self.bitset.trailing_bits:
 *             raise OverflowError("It's impossible to iterate over an infinite set.")             # <<<<<<<<<<<<<<
 *         return intbitset_iterator(self)
 * 
 */
    __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 474; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(((PyObject *)__pyx_t_2));
    __Pyx_INCREF(__pyx_kp_55);
    PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_kp_55);
    __Pyx_GIVEREF(__pyx_kp_55);
    __pyx_t_3 = PyObject_Call(__pyx_builtin_OverflowError, ((PyObject *)__pyx_t_2), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 474; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
    __Pyx_Raise(__pyx_t_3, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 474; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":475
 *         if self.bitset.trailing_bits:
 *             raise OverflowError("It's impossible to iterate over an infinite set.")
 *         return intbitset_iterator(self)             # <<<<<<<<<<<<<<
 * 
 *     # Customized interface
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 475; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(((PyObject *)__pyx_t_3));
  __Pyx_INCREF(__pyx_v_self);
  PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_self);
  __Pyx_GIVEREF(__pyx_v_self);
  __pyx_t_2 = PyObject_Call(((PyObject *)((PyObject*)__pyx_ptype_3lib_9intbitset_intbitset_iterator)), ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 475; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("lib.intbitset.intbitset.__iter__");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_FinishRefcountContext();
  return __pyx_r;
}

/* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":478
 * 
 *     # Customized interface
 *     def add(self, int elem):             # <<<<<<<<<<<<<<
 *         """Add an element to a set.
 *         This has no effect if the element is already present."""
 */

static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_add(PyObject *__pyx_v_self, PyObject *__pyx_arg_elem); /*proto*/
static char __pyx_doc_3lib_9intbitset_9intbitset_add[] = "Add an element to a set.\n        This has no effect if the element is already present.";
static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_add(PyObject *__pyx_v_self, PyObject *__pyx_arg_elem) {
  int __pyx_v_elem;
  PyObject *__pyx_r = NULL;
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_SetupRefcountContext("add");
  assert(__pyx_arg_elem); {
    __pyx_v_elem = __Pyx_PyInt_AsInt(__pyx_arg_elem); if (unlikely((__pyx_v_elem == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 478; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("lib.intbitset.intbitset.add");
  return NULL;
  __pyx_L4_argument_unpacking_done:;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":481
 *         """Add an element to a set.
 *         This has no effect if the element is already present."""
 *         if self.sanity_checks:             # <<<<<<<<<<<<<<
 *             if elem < 0:
 *                 raise ValueError("Negative numbers, not allowed")
 */
  __pyx_t_1 = ((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->sanity_checks;
  if (__pyx_t_1) {

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":482
 *         This has no effect if the element is already present."""
 *         if self.sanity_checks:
 *             if elem < 0:             # <<<<<<<<<<<<<<
 *                 raise ValueError("Negative numbers, not allowed")
 *             elif elem > maxelem:
 */
    __pyx_t_1 = (__pyx_v_elem < 0);
    if (__pyx_t_1) {

      /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":483
 *         if self.sanity_checks:
 *             if elem < 0:
 *                 raise ValueError("Negative numbers, not allowed")             # <<<<<<<<<<<<<<
 *             elif elem > maxelem:
 *                 raise OverflowError("Element must be <= %s" % maxelem)
 */
      __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 483; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(((PyObject *)__pyx_t_2));
      __Pyx_INCREF(__pyx_kp_56);
      PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_kp_56);
      __Pyx_GIVEREF(__pyx_kp_56);
      __pyx_t_3 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_t_2), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 483; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
      __Pyx_Raise(__pyx_t_3, 0, 0);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 483; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      goto __pyx_L6;
    }

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":484
 *             if elem < 0:
 *                 raise ValueError("Negative numbers, not allowed")
 *             elif elem > maxelem:             # <<<<<<<<<<<<<<
 *                 raise OverflowError("Element must be <= %s" % maxelem)
 *         intBitSetAddElem(self.bitset, elem)
 */
    __pyx_t_1 = (__pyx_v_elem > maxelem);
    if (__pyx_t_1) {

      /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":485
 *                 raise ValueError("Negative numbers, not allowed")
 *             elif elem > maxelem:
 *                 raise OverflowError("Element must be <= %s" % maxelem)             # <<<<<<<<<<<<<<
 *         intBitSetAddElem(self.bitset, elem)
 * 
 */
      __pyx_t_3 = PyInt_FromLong(maxelem); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 485; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_2 = PyNumber_Remainder(__pyx_kp_57, __pyx_t_3); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 485; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 485; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(((PyObject *)__pyx_t_3));
      PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_2);
      __Pyx_GIVEREF(__pyx_t_2);
      __pyx_t_2 = 0;
      __pyx_t_2 = PyObject_Call(__pyx_builtin_OverflowError, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 485; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
      __Pyx_Raise(__pyx_t_2, 0, 0);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 485; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      goto __pyx_L6;
    }
    __pyx_L6:;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":486
 *             elif elem > maxelem:
 *                 raise OverflowError("Element must be <= %s" % maxelem)
 *         intBitSetAddElem(self.bitset, elem)             # <<<<<<<<<<<<<<
 * 
 *     def clear(self):
 */
  intBitSetAddElem(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset, __pyx_v_elem);

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("lib.intbitset.intbitset.add");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_FinishRefcountContext();
  return __pyx_r;
}

/* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":488
 *         intBitSetAddElem(self.bitset, elem)
 * 
 *     def clear(self):             # <<<<<<<<<<<<<<
 *         intBitSetReset(self.bitset)
 * 
 */

static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_clear(PyObject *__pyx_v_self, PyObject *unused); /*proto*/
static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_clear(PyObject *__pyx_v_self, PyObject *unused) {
  PyObject *__pyx_r = NULL;
  __Pyx_SetupRefcountContext("clear");

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":489
 * 
 *     def clear(self):
 *         intBitSetReset(self.bitset)             # <<<<<<<<<<<<<<
 * 
 *     def difference(intbitset self, rhs):
 */
  intBitSetReset(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset);

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_FinishRefcountContext();
  return __pyx_r;
}

/* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":491
 *         intBitSetReset(self.bitset)
 * 
 *     def difference(intbitset self, rhs):             # <<<<<<<<<<<<<<
 *         """Return the difference of two intbitsets as a new set.
 *         (i.e. all elements that are in this intbitset but not the other.)
 */

static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_difference(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs); /*proto*/
static char __pyx_doc_3lib_9intbitset_9intbitset_difference[] = "Return the difference of two intbitsets as a new set.\n        (i.e. all elements that are in this intbitset but not the other.)\n        ";
static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_difference(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs) {
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_SetupRefcountContext("difference");

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":495
 *         (i.e. all elements that are in this intbitset but not the other.)
 *         """
 *         return self.__sub__(rhs)             # <<<<<<<<<<<<<<
 * 
 *     def difference_update(self, rhs):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyObject_GetAttr(__pyx_v_self, __pyx_kp___sub__); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 495; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 495; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(((PyObject *)__pyx_t_2));
  __Pyx_INCREF(__pyx_v_rhs);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rhs);
  __Pyx_GIVEREF(__pyx_v_rhs);
  __pyx_t_3 = PyObject_Call(__pyx_t_1, ((PyObject *)__pyx_t_2), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 495; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("lib.intbitset.intbitset.difference");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_FinishRefcountContext();
  return __pyx_r;
}

/* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":497
 *         return self.__sub__(rhs)
 * 
 *     def difference_update(self, rhs):             # <<<<<<<<<<<<<<
 *         """Remove all elements of another set from this set."""
 *         self.__isub__(rhs)
 */

static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_difference_update(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs); /*proto*/
static char __pyx_doc_3lib_9intbitset_9intbitset_difference_update[] = "Remove all elements of another set from this set.";
static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_difference_update(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs) {
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_SetupRefcountContext("difference_update");

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":499
 *     def difference_update(self, rhs):
 *         """Remove all elements of another set from this set."""
 *         self.__isub__(rhs)             # <<<<<<<<<<<<<<
 * 
 *     def discard(self, int elem):
 */
  __pyx_t_1 = PyObject_GetAttr(__pyx_v_self, __pyx_kp___isub__); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 499; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 499; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(((PyObject *)__pyx_t_2));
  __Pyx_INCREF(__pyx_v_rhs);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rhs);
  __Pyx_GIVEREF(__pyx_v_rhs);
  __pyx_t_3 = PyObject_Call(__pyx_t_1, ((PyObject *)__pyx_t_2), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 499; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("lib.intbitset.intbitset.difference_update");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_FinishRefcountContext();
  return __pyx_r;
}

/* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":501
 *         self.__isub__(rhs)
 * 
 *     def discard(self, int elem):             # <<<<<<<<<<<<<<
 *         """Remove an element from a intbitset if it is a member.
 *         If the element is not a member, do nothing."""
 */

static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_discard(PyObject *__pyx_v_self, PyObject *__pyx_arg_elem); /*proto*/
static char __pyx_doc_3lib_9intbitset_9intbitset_discard[] = "Remove an element from a intbitset if it is a member.\n        If the element is not a member, do nothing.";
static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_discard(PyObject *__pyx_v_self, PyObject *__pyx_arg_elem) {
  int __pyx_v_elem;
  PyObject *__pyx_r = NULL;
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_SetupRefcountContext("discard");
  assert(__pyx_arg_elem); {
    __pyx_v_elem = __Pyx_PyInt_AsInt(__pyx_arg_elem); if (unlikely((__pyx_v_elem == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 501; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("lib.intbitset.intbitset.discard");
  return NULL;
  __pyx_L4_argument_unpacking_done:;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":504
 *         """Remove an element from a intbitset if it is a member.
 *         If the element is not a member, do nothing."""
 *         if self.sanity_checks:             # <<<<<<<<<<<<<<
 *             if elem < 0:
 *                 raise ValueError("Negative numbers, not allowed")
 */
  __pyx_t_1 = ((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->sanity_checks;
  if (__pyx_t_1) {

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":505
 *         If the element is not a member, do nothing."""
 *         if self.sanity_checks:
 *             if elem < 0:             # <<<<<<<<<<<<<<
 *                 raise ValueError("Negative numbers, not allowed")
 *             elif elem > maxelem:
 */
    __pyx_t_1 = (__pyx_v_elem < 0);
    if (__pyx_t_1) {

      /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":506
 *         if self.sanity_checks:
 *             if elem < 0:
 *                 raise ValueError("Negative numbers, not allowed")             # <<<<<<<<<<<<<<
 *             elif elem > maxelem:
 *                 raise OverflowError("Element must be <= %s" % maxelem)
 */
      __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 506; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(((PyObject *)__pyx_t_2));
      __Pyx_INCREF(__pyx_kp_58);
      PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_kp_58);
      __Pyx_GIVEREF(__pyx_kp_58);
      __pyx_t_3 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_t_2), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 506; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
      __Pyx_Raise(__pyx_t_3, 0, 0);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 506; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      goto __pyx_L6;
    }

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":507
 *             if elem < 0:
 *                 raise ValueError("Negative numbers, not allowed")
 *             elif elem > maxelem:             # <<<<<<<<<<<<<<
 *                 raise OverflowError("Element must be <= %s" % maxelem)
 *         intBitSetDelElem(self.bitset, elem)
 */
    __pyx_t_1 = (__pyx_v_elem > maxelem);
    if (__pyx_t_1) {

      /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":508
 *                 raise ValueError("Negative numbers, not allowed")
 *             elif elem > maxelem:
 *                 raise OverflowError("Element must be <= %s" % maxelem)             # <<<<<<<<<<<<<<
 *         intBitSetDelElem(self.bitset, elem)
 * 
 */
      __pyx_t_3 = PyInt_FromLong(maxelem); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 508; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_2 = PyNumber_Remainder(__pyx_kp_59, __pyx_t_3); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 508; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 508; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(((PyObject *)__pyx_t_3));
      PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_2);
      __Pyx_GIVEREF(__pyx_t_2);
      __pyx_t_2 = 0;
      __pyx_t_2 = PyObject_Call(__pyx_builtin_OverflowError, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 508; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
      __Pyx_Raise(__pyx_t_2, 0, 0);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 508; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      goto __pyx_L6;
    }
    __pyx_L6:;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":509
 *             elif elem > maxelem:
 *                 raise OverflowError("Element must be <= %s" % maxelem)
 *         intBitSetDelElem(self.bitset, elem)             # <<<<<<<<<<<<<<
 * 
 *     def intersection(self, rhs):
 */
  intBitSetDelElem(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset, __pyx_v_elem);

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("lib.intbitset.intbitset.discard");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_FinishRefcountContext();
  return __pyx_r;
}

/* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":511
 *         intBitSetDelElem(self.bitset, elem)
 * 
 *     def intersection(self, rhs):             # <<<<<<<<<<<<<<
 *         """Return the intersection of two intbitsets as a new set.
 *         (i.e. all elements that are in both intbitsets.)
 */

static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_intersection(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs); /*proto*/
static char __pyx_doc_3lib_9intbitset_9intbitset_intersection[] = "Return the intersection of two intbitsets as a new set.\n        (i.e. all elements that are in both intbitsets.)\n        ";
static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_intersection(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs) {
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_SetupRefcountContext("intersection");

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":515
 *         (i.e. all elements that are in both intbitsets.)
 *         """
 *         return self.__and__(rhs)             # <<<<<<<<<<<<<<
 * 
 *     def intersection_update(self, rhs):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyObject_GetAttr(__pyx_v_self, __pyx_kp___and__); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 515; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 515; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(((PyObject *)__pyx_t_2));
  __Pyx_INCREF(__pyx_v_rhs);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rhs);
  __Pyx_GIVEREF(__pyx_v_rhs);
  __pyx_t_3 = PyObject_Call(__pyx_t_1, ((PyObject *)__pyx_t_2), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 515; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("lib.intbitset.intbitset.intersection");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_FinishRefcountContext();
  return __pyx_r;
}

/* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":517
 *         return self.__and__(rhs)
 * 
 *     def intersection_update(self, rhs):             # <<<<<<<<<<<<<<
 *         """Update a intbitset with the intersection of itself and another."""
 *         self.__iand__(rhs)
 */

static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_intersection_update(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs); /*proto*/
static char __pyx_doc_3lib_9intbitset_9intbitset_intersection_update[] = "Update a intbitset with the intersection of itself and another.";
static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_intersection_update(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs) {
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_SetupRefcountContext("intersection_update");

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":519
 *     def intersection_update(self, rhs):
 *         """Update a intbitset with the intersection of itself and another."""
 *         self.__iand__(rhs)             # <<<<<<<<<<<<<<
 * 
 *     def union(self, rhs):
 */
  __pyx_t_1 = PyObject_GetAttr(__pyx_v_self, __pyx_kp___iand__); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 519; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 519; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(((PyObject *)__pyx_t_2));
  __Pyx_INCREF(__pyx_v_rhs);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rhs);
  __Pyx_GIVEREF(__pyx_v_rhs);
  __pyx_t_3 = PyObject_Call(__pyx_t_1, ((PyObject *)__pyx_t_2), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 519; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("lib.intbitset.intbitset.intersection_update");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_FinishRefcountContext();
  return __pyx_r;
}

/* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":521
 *         self.__iand__(rhs)
 * 
 *     def union(self, rhs):             # <<<<<<<<<<<<<<
 *         """Return the union of two intbitsets as a new set.
 *         (i.e. all elements that are in either intbitsets.)
 */

static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_union(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs); /*proto*/
static char __pyx_doc_3lib_9intbitset_9intbitset_union[] = "Return the union of two intbitsets as a new set.\n        (i.e. all elements that are in either intbitsets.)\n        ";
static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_union(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs) {
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_SetupRefcountContext("union");

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":525
 *         (i.e. all elements that are in either intbitsets.)
 *         """
 *         return self.__or__(rhs)             # <<<<<<<<<<<<<<
 * 
 *     def union_update(self, rhs):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyObject_GetAttr(__pyx_v_self, __pyx_kp___or__); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 525; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 525; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(((PyObject *)__pyx_t_2));
  __Pyx_INCREF(__pyx_v_rhs);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rhs);
  __Pyx_GIVEREF(__pyx_v_rhs);
  __pyx_t_3 = PyObject_Call(__pyx_t_1, ((PyObject *)__pyx_t_2), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 525; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("lib.intbitset.intbitset.union");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_FinishRefcountContext();
  return __pyx_r;
}

/* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":527
 *         return self.__or__(rhs)
 * 
 *     def union_update(self, rhs):             # <<<<<<<<<<<<<<
 *         """Update a intbitset with the union of itself and another."""
 *         self.__ior__(rhs)
 */

static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_union_update(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs); /*proto*/
static char __pyx_doc_3lib_9intbitset_9intbitset_union_update[] = "Update a intbitset with the union of itself and another.";
static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_union_update(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs) {
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_SetupRefcountContext("union_update");

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":529
 *     def union_update(self, rhs):
 *         """Update a intbitset with the union of itself and another."""
 *         self.__ior__(rhs)             # <<<<<<<<<<<<<<
 * 
 *     def issubset(self, rhs):
 */
  __pyx_t_1 = PyObject_GetAttr(__pyx_v_self, __pyx_kp___ior__); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 529; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 529; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(((PyObject *)__pyx_t_2));
  __Pyx_INCREF(__pyx_v_rhs);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rhs);
  __Pyx_GIVEREF(__pyx_v_rhs);
  __pyx_t_3 = PyObject_Call(__pyx_t_1, ((PyObject *)__pyx_t_2), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 529; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("lib.intbitset.intbitset.union_update");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_FinishRefcountContext();
  return __pyx_r;
}

/* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":531
 *         self.__ior__(rhs)
 * 
 *     def issubset(self, rhs):             # <<<<<<<<<<<<<<
 *         """Report whether another set contains this set."""
 *         return self.__le__(rhs)
 */

static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_issubset(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs); /*proto*/
static char __pyx_doc_3lib_9intbitset_9intbitset_issubset[] = "Report whether another set contains this set.";
static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_issubset(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs) {
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_SetupRefcountContext("issubset");

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":533
 *     def issubset(self, rhs):
 *         """Report whether another set contains this set."""
 *         return self.__le__(rhs)             # <<<<<<<<<<<<<<
 * 
 *     def issuperset(self, rhs):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyObject_GetAttr(__pyx_v_self, __pyx_kp___le__); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 533; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 533; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(((PyObject *)__pyx_t_2));
  __Pyx_INCREF(__pyx_v_rhs);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rhs);
  __Pyx_GIVEREF(__pyx_v_rhs);
  __pyx_t_3 = PyObject_Call(__pyx_t_1, ((PyObject *)__pyx_t_2), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 533; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("lib.intbitset.intbitset.issubset");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_FinishRefcountContext();
  return __pyx_r;
}

/* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":535
 *         return self.__le__(rhs)
 * 
 *     def issuperset(self, rhs):             # <<<<<<<<<<<<<<
 *         """Report whether this set contains another set."""
 *         return self.__ge__(rhs)
 */

static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_issuperset(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs); /*proto*/
static char __pyx_doc_3lib_9intbitset_9intbitset_issuperset[] = "Report whether this set contains another set.";
static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_issuperset(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs) {
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_SetupRefcountContext("issuperset");

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":537
 *     def issuperset(self, rhs):
 *         """Report whether this set contains another set."""
 *         return self.__ge__(rhs)             # <<<<<<<<<<<<<<
 * 
 *     def symmetric_difference(self, rhs):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyObject_GetAttr(__pyx_v_self, __pyx_kp___ge__); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 537; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 537; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(((PyObject *)__pyx_t_2));
  __Pyx_INCREF(__pyx_v_rhs);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rhs);
  __Pyx_GIVEREF(__pyx_v_rhs);
  __pyx_t_3 = PyObject_Call(__pyx_t_1, ((PyObject *)__pyx_t_2), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 537; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("lib.intbitset.intbitset.issuperset");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_FinishRefcountContext();
  return __pyx_r;
}

/* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":539
 *         return self.__ge__(rhs)
 * 
 *     def symmetric_difference(self, rhs):             # <<<<<<<<<<<<<<
 *         """Return the symmetric difference of two sets as a new set.
 *         (i.e. all elements that are in exactly one of the sets.)
 */

static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_symmetric_difference(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs); /*proto*/
static char __pyx_doc_3lib_9intbitset_9intbitset_symmetric_difference[] = "Return the symmetric difference of two sets as a new set.\n        (i.e. all elements that are in exactly one of the sets.)\n        ";
static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_symmetric_difference(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs) {
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_SetupRefcountContext("symmetric_difference");

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":543
 *         (i.e. all elements that are in exactly one of the sets.)
 *         """
 *         return self.__xor__(rhs)             # <<<<<<<<<<<<<<
 * 
 *     def symmetric_difference_update(self, rhs):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyObject_GetAttr(__pyx_v_self, __pyx_kp___xor__); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 543; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 543; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(((PyObject *)__pyx_t_2));
  __Pyx_INCREF(__pyx_v_rhs);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rhs);
  __Pyx_GIVEREF(__pyx_v_rhs);
  __pyx_t_3 = PyObject_Call(__pyx_t_1, ((PyObject *)__pyx_t_2), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 543; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("lib.intbitset.intbitset.symmetric_difference");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_FinishRefcountContext();
  return __pyx_r;
}

/* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":545
 *         return self.__xor__(rhs)
 * 
 *     def symmetric_difference_update(self, rhs):             # <<<<<<<<<<<<<<
 *         """Update an intbitset with the symmetric difference of itself and another.
 *         """
 */

static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_symmetric_difference_update(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs); /*proto*/
static char __pyx_doc_3lib_9intbitset_9intbitset_symmetric_difference_update[] = "Update an intbitset with the symmetric difference of itself and another.\n        ";
static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_symmetric_difference_update(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs) {
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_SetupRefcountContext("symmetric_difference_update");

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":548
 *         """Update an intbitset with the symmetric difference of itself and another.
 *         """
 *         self.__ixor__(rhs)             # <<<<<<<<<<<<<<
 * 
 *     # Dumping & Loading
 */
  __pyx_t_1 = PyObject_GetAttr(__pyx_v_self, __pyx_kp___ixor__); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 548; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 548; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(((PyObject *)__pyx_t_2));
  __Pyx_INCREF(__pyx_v_rhs);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_rhs);
  __Pyx_GIVEREF(__pyx_v_rhs);
  __pyx_t_3 = PyObject_Call(__pyx_t_1, ((PyObject *)__pyx_t_2), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 548; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("lib.intbitset.intbitset.symmetric_difference_update");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_FinishRefcountContext();
  return __pyx_r;
}

/* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":551
 * 
 *     # Dumping & Loading
 *     def fastdump(self):             # <<<<<<<<<<<<<<
 *         """Return a compressed string representation suitable to be saved
 *         somewhere."""
 */

static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_fastdump(PyObject *__pyx_v_self, PyObject *unused); /*proto*/
static char __pyx_doc_3lib_9intbitset_9intbitset_fastdump[] = "Return a compressed string representation suitable to be saved\n        somewhere.";
static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_fastdump(PyObject *__pyx_v_self, PyObject *unused) {
  Py_ssize_t __pyx_v_size;
  PyObject *__pyx_v_tmp;
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_1 = 0;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_SetupRefcountContext("fastdump");
  __pyx_v_tmp = Py_None; __Pyx_INCREF(Py_None);

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":555
 *         somewhere."""
 *         cdef Py_ssize_t size
 *         size = intBitSetGetSize((<intbitset> self).bitset)             # <<<<<<<<<<<<<<
 *         tmp = PyString_FromStringAndSize(<char *>self.bitset.bitset, ( size + 1) * wordbytesize)
 *         return zlib.compress(tmp)
 */
  __pyx_v_size = intBitSetGetSize(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset);

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":556
 *         cdef Py_ssize_t size
 *         size = intBitSetGetSize((<intbitset> self).bitset)
 *         tmp = PyString_FromStringAndSize(<char *>self.bitset.bitset, ( size + 1) * wordbytesize)             # <<<<<<<<<<<<<<
 *         return zlib.compress(tmp)
 * 
 */
  __pyx_t_1 = PyString_FromStringAndSize(((char *)((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset->bitset), ((__pyx_v_size + 1) * wordbytesize)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 556; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_v_tmp);
  __pyx_v_tmp = __pyx_t_1;
  __pyx_t_1 = 0;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":557
 *         size = intBitSetGetSize((<intbitset> self).bitset)
 *         tmp = PyString_FromStringAndSize(<char *>self.bitset.bitset, ( size + 1) * wordbytesize)
 *         return zlib.compress(tmp)             # <<<<<<<<<<<<<<
 * 
 *     def fastload(self, strdump):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_1 = __Pyx_GetName(__pyx_m, __pyx_kp_zlib); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 557; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_1);
  __pyx_t_1 = PyObject_GetAttr(__pyx_1, __pyx_kp_compress); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 557; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
  __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 557; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(((PyObject *)__pyx_t_2));
  __Pyx_INCREF(__pyx_v_tmp);
  PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_tmp);
  __Pyx_GIVEREF(__pyx_v_tmp);
  __pyx_t_3 = PyObject_Call(__pyx_t_1, ((PyObject *)__pyx_t_2), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 557; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
  __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_1);
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("lib.intbitset.intbitset.fastdump");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_tmp);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_FinishRefcountContext();
  return __pyx_r;
}

/* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":559
 *         return zlib.compress(tmp)
 * 
 *     def fastload(self, strdump):             # <<<<<<<<<<<<<<
 *         """Load a compressed string representation produced by a previous call
 *         to the fastdump method into the current intbitset. The previous content
 */

static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_fastload(PyObject *__pyx_v_self, PyObject *__pyx_v_strdump); /*proto*/
static char __pyx_doc_3lib_9intbitset_9intbitset_fastload[] = "Load a compressed string representation produced by a previous call\n        to the fastdump method into the current intbitset. The previous content\n        will be replaced.";
static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_fastload(PyObject *__pyx_v_self, PyObject *__pyx_v_strdump) {
  Py_ssize_t __pyx_v_size;
  void *__pyx_v_buf;
  PyObject *__pyx_v_tmp;
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_1 = 0;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  int __pyx_t_3;
  PyObject *__pyx_t_4 = NULL;
  PyObject *__pyx_t_5 = NULL;
  PyObject *__pyx_t_6 = NULL;
  __Pyx_SetupRefcountContext("fastload");
  __Pyx_INCREF(__pyx_v_strdump);
  __pyx_v_tmp = Py_None; __Pyx_INCREF(Py_None);

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":565
 *         cdef Py_ssize_t size
 *         cdef void *buf
 *         buf = NULL             # <<<<<<<<<<<<<<
 *         size = 0
 *         try:
 */
  __pyx_v_buf = NULL;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":566
 *         cdef void *buf
 *         buf = NULL
 *         size = 0             # <<<<<<<<<<<<<<
 *         try:
 *             if type(strdump) is array:
 */
  __pyx_v_size = 0;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":567
 *         buf = NULL
 *         size = 0
 *         try:             # <<<<<<<<<<<<<<
 *             if type(strdump) is array:
 *                 strdump = strdump.tostring()
 */
  {
    PyObject *__pyx_save_exc_type, *__pyx_save_exc_value, *__pyx_save_exc_tb;
    __Pyx_ExceptionSave(&__pyx_save_exc_type, &__pyx_save_exc_value, &__pyx_save_exc_tb);
    __Pyx_XGOTREF(__pyx_save_exc_type);
    __Pyx_XGOTREF(__pyx_save_exc_value);
    __Pyx_XGOTREF(__pyx_save_exc_tb);
    /*try:*/ {

      /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":568
 *         size = 0
 *         try:
 *             if type(strdump) is array:             # <<<<<<<<<<<<<<
 *                 strdump = strdump.tostring()
 *             # tmp needed to not be garbage collected
 */
      __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 568; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
      __Pyx_GOTREF(((PyObject *)__pyx_t_1));
      __Pyx_INCREF(__pyx_v_strdump);
      PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_strdump);
      __Pyx_GIVEREF(__pyx_v_strdump);
      __pyx_t_2 = PyObject_Call(((PyObject *)((PyObject*)&PyType_Type)), ((PyObject *)__pyx_t_1), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 568; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
      __pyx_1 = __Pyx_GetName(__pyx_m, __pyx_kp_array); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 568; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
      __Pyx_GOTREF(__pyx_1);
      __pyx_t_3 = (__pyx_t_2 == __pyx_1);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
      if (__pyx_t_3) {

        /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":569
 *         try:
 *             if type(strdump) is array:
 *                 strdump = strdump.tostring()             # <<<<<<<<<<<<<<
 *             # tmp needed to not be garbage collected
 *             tmp = zlib.decompress(strdump)
 */
        __pyx_t_2 = PyObject_GetAttr(__pyx_v_strdump, __pyx_kp_tostring); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 569; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
        __Pyx_GOTREF(__pyx_t_2);
        __pyx_t_1 = PyObject_Call(__pyx_t_2, ((PyObject *)__pyx_empty_tuple), NULL); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 569; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
        __Pyx_GOTREF(__pyx_t_1);
        __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
        __Pyx_DECREF(__pyx_v_strdump);
        __pyx_v_strdump = __pyx_t_1;
        __pyx_t_1 = 0;
        goto __pyx_L13;
      }
      __pyx_L13:;

      /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":571
 *                 strdump = strdump.tostring()
 *             # tmp needed to not be garbage collected
 *             tmp = zlib.decompress(strdump)             # <<<<<<<<<<<<<<
 *             if PyObject_AsReadBuffer(tmp, &buf, &size) < 0:
 *                 raise Exception()
 */
      __pyx_1 = __Pyx_GetName(__pyx_m, __pyx_kp_zlib); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 571; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
      __Pyx_GOTREF(__pyx_1);
      __pyx_t_1 = PyObject_GetAttr(__pyx_1, __pyx_kp_decompress); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 571; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
      __Pyx_GOTREF(__pyx_t_1);
      __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
      __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 571; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
      __Pyx_GOTREF(((PyObject *)__pyx_t_2));
      __Pyx_INCREF(__pyx_v_strdump);
      PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_v_strdump);
      __Pyx_GIVEREF(__pyx_v_strdump);
      __pyx_t_4 = PyObject_Call(__pyx_t_1, ((PyObject *)__pyx_t_2), NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 571; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
      __Pyx_DECREF(__pyx_v_tmp);
      __pyx_v_tmp = __pyx_t_4;
      __pyx_t_4 = 0;

      /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":572
 *             # tmp needed to not be garbage collected
 *             tmp = zlib.decompress(strdump)
 *             if PyObject_AsReadBuffer(tmp, &buf, &size) < 0:             # <<<<<<<<<<<<<<
 *                 raise Exception()
 *             intBitSetResetFromBuffer((<intbitset> self).bitset, buf, size)
 */
      __pyx_t_3 = (PyObject_AsReadBuffer(__pyx_v_tmp, (&__pyx_v_buf), (&__pyx_v_size)) < 0);
      if (__pyx_t_3) {

        /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":573
 *             tmp = zlib.decompress(strdump)
 *             if PyObject_AsReadBuffer(tmp, &buf, &size) < 0:
 *                 raise Exception()             # <<<<<<<<<<<<<<
 *             intBitSetResetFromBuffer((<intbitset> self).bitset, buf, size)
 *         except:
 */
        __pyx_t_4 = PyObject_Call(__pyx_builtin_Exception, ((PyObject *)__pyx_empty_tuple), NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 573; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_Raise(__pyx_t_4, 0, 0);
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
        {__pyx_filename = __pyx_f[0]; __pyx_lineno = 573; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
        goto __pyx_L14;
      }
      __pyx_L14:;

      /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":574
 *             if PyObject_AsReadBuffer(tmp, &buf, &size) < 0:
 *                 raise Exception()
 *             intBitSetResetFromBuffer((<intbitset> self).bitset, buf, size)             # <<<<<<<<<<<<<<
 *         except:
 *             raise ValueError("strdump is corrupted")
 */
      intBitSetResetFromBuffer(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset, __pyx_v_buf, __pyx_v_size);
    }
    __Pyx_XDECREF(__pyx_save_exc_type); __pyx_save_exc_type = 0;
    __Pyx_XDECREF(__pyx_save_exc_value); __pyx_save_exc_value = 0;
    __Pyx_XDECREF(__pyx_save_exc_tb); __pyx_save_exc_tb = 0;
    goto __pyx_L12_try_end;
    __pyx_L5_error:;
    __Pyx_XDECREF(__pyx_1); __pyx_1 = 0;
    __Pyx_XDECREF(__pyx_t_1); __pyx_t_1 = 0;
    __Pyx_XDECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":575
 *                 raise Exception()
 *             intBitSetResetFromBuffer((<intbitset> self).bitset, buf, size)
 *         except:             # <<<<<<<<<<<<<<
 *             raise ValueError("strdump is corrupted")
 *         return self
 */
    /*except:*/ {
      __Pyx_AddTraceback("lib.intbitset.fastload");
      if (__Pyx_GetException(&__pyx_t_4, &__pyx_t_2, &__pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 575; __pyx_clineno = __LINE__; goto __pyx_L7_except_error;}
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_GOTREF(__pyx_t_1);

      /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":576
 *             intBitSetResetFromBuffer((<intbitset> self).bitset, buf, size)
 *         except:
 *             raise ValueError("strdump is corrupted")             # <<<<<<<<<<<<<<
 *         return self
 * 
 */
      __pyx_t_5 = PyTuple_New(1); if (unlikely(!__pyx_t_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 576; __pyx_clineno = __LINE__; goto __pyx_L7_except_error;}
      __Pyx_GOTREF(((PyObject *)__pyx_t_5));
      __Pyx_INCREF(__pyx_kp_60);
      PyTuple_SET_ITEM(__pyx_t_5, 0, __pyx_kp_60);
      __Pyx_GIVEREF(__pyx_kp_60);
      __pyx_t_6 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_t_5), NULL); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 576; __pyx_clineno = __LINE__; goto __pyx_L7_except_error;}
      __Pyx_GOTREF(__pyx_t_6);
      __Pyx_DECREF(((PyObject *)__pyx_t_5)); __pyx_t_5 = 0;
      __Pyx_Raise(__pyx_t_6, 0, 0);
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 576; __pyx_clineno = __LINE__; goto __pyx_L7_except_error;}
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;
      goto __pyx_L6_exception_handled;
    }
    __pyx_L7_except_error:;
    __Pyx_XDECREF(__pyx_save_exc_type);
    __Pyx_XDECREF(__pyx_save_exc_value);
    __Pyx_XDECREF(__pyx_save_exc_tb);
    goto __pyx_L1_error;
    __pyx_L6_exception_handled:;
    __Pyx_XGIVEREF(__pyx_save_exc_type);
    __Pyx_XGIVEREF(__pyx_save_exc_value);
    __Pyx_XGIVEREF(__pyx_save_exc_tb);
    __Pyx_ExceptionReset(__pyx_save_exc_type, __pyx_save_exc_value, __pyx_save_exc_tb);
    __pyx_L12_try_end:;
  }

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":577
 *         except:
 *             raise ValueError("strdump is corrupted")
 *         return self             # <<<<<<<<<<<<<<
 * 
 *     def copy(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_self);
  __pyx_r = __pyx_v_self;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_1);
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_5);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("lib.intbitset.intbitset.fastload");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_tmp);
  __Pyx_DECREF(__pyx_v_strdump);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_FinishRefcountContext();
  return __pyx_r;
}

/* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":579
 *         return self
 * 
 *     def copy(self):             # <<<<<<<<<<<<<<
 *         """Return a shallow copy of a set."""
 *         return intbitset(self)
 */

static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_copy(PyObject *__pyx_v_self, PyObject *unused); /*proto*/
static char __pyx_doc_3lib_9intbitset_9intbitset_copy[] = "Return a shallow copy of a set.";
static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_copy(PyObject *__pyx_v_self, PyObject *unused) {
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  PyObject *__pyx_t_2 = NULL;
  __Pyx_SetupRefcountContext("copy");

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":581
 *     def copy(self):
 *         """Return a shallow copy of a set."""
 *         return intbitset(self)             # <<<<<<<<<<<<<<
 * 
 *     def pop(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyTuple_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 581; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(((PyObject *)__pyx_t_1));
  __Pyx_INCREF(__pyx_v_self);
  PyTuple_SET_ITEM(__pyx_t_1, 0, __pyx_v_self);
  __Pyx_GIVEREF(__pyx_v_self);
  __pyx_t_2 = PyObject_Call(((PyObject *)((PyObject*)__pyx_ptype_3lib_9intbitset_intbitset)), ((PyObject *)__pyx_t_1), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 581; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_AddTraceback("lib.intbitset.intbitset.copy");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_FinishRefcountContext();
  return __pyx_r;
}

/* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":583
 *         return intbitset(self)
 * 
 *     def pop(self):             # <<<<<<<<<<<<<<
 *         """Remove and return an arbitrary set element."""
 *         cdef int ret
 */

static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_pop(PyObject *__pyx_v_self, PyObject *unused); /*proto*/
static char __pyx_doc_3lib_9intbitset_9intbitset_pop[] = "Remove and return an arbitrary set element.";
static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_pop(PyObject *__pyx_v_self, PyObject *unused) {
  int __pyx_v_ret;
  PyObject *__pyx_r = NULL;
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_SetupRefcountContext("pop");

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":586
 *         """Remove and return an arbitrary set element."""
 *         cdef int ret
 *         ret = intBitSetGetNext(self.bitset, -1)             # <<<<<<<<<<<<<<
 *         if ret < 0:
 *             raise KeyError("pop from an empty intbitset")
 */
  __pyx_v_ret = intBitSetGetNext(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset, -1);

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":587
 *         cdef int ret
 *         ret = intBitSetGetNext(self.bitset, -1)
 *         if ret < 0:             # <<<<<<<<<<<<<<
 *             raise KeyError("pop from an empty intbitset")
 *         intBitSetDelElem(self.bitset, ret)
 */
  __pyx_t_1 = (__pyx_v_ret < 0);
  if (__pyx_t_1) {

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":588
 *         ret = intBitSetGetNext(self.bitset, -1)
 *         if ret < 0:
 *             raise KeyError("pop from an empty intbitset")             # <<<<<<<<<<<<<<
 *         intBitSetDelElem(self.bitset, ret)
 *         return ret
 */
    __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 588; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(((PyObject *)__pyx_t_2));
    __Pyx_INCREF(__pyx_kp_61);
    PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_kp_61);
    __Pyx_GIVEREF(__pyx_kp_61);
    __pyx_t_3 = PyObject_Call(__pyx_builtin_KeyError, ((PyObject *)__pyx_t_2), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 588; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
    __Pyx_Raise(__pyx_t_3, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 588; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":589
 *         if ret < 0:
 *             raise KeyError("pop from an empty intbitset")
 *         intBitSetDelElem(self.bitset, ret)             # <<<<<<<<<<<<<<
 *         return ret
 * 
 */
  intBitSetDelElem(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset, __pyx_v_ret);

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":590
 *             raise KeyError("pop from an empty intbitset")
 *         intBitSetDelElem(self.bitset, ret)
 *         return ret             # <<<<<<<<<<<<<<
 * 
 *     def remove(self, int elem):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_3 = PyInt_FromLong(__pyx_v_ret); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 590; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("lib.intbitset.intbitset.pop");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_FinishRefcountContext();
  return __pyx_r;
}

/* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":592
 *         return ret
 * 
 *     def remove(self, int elem):             # <<<<<<<<<<<<<<
 *         """Remove an element from a set; it must be a member.
 *         If the element is not a member, raise a KeyError.
 */

static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_remove(PyObject *__pyx_v_self, PyObject *__pyx_arg_elem); /*proto*/
static char __pyx_doc_3lib_9intbitset_9intbitset_remove[] = "Remove an element from a set; it must be a member.\n        If the element is not a member, raise a KeyError.\n        ";
static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_remove(PyObject *__pyx_v_self, PyObject *__pyx_arg_elem) {
  int __pyx_v_elem;
  PyObject *__pyx_r = NULL;
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_SetupRefcountContext("remove");
  assert(__pyx_arg_elem); {
    __pyx_v_elem = __Pyx_PyInt_AsInt(__pyx_arg_elem); if (unlikely((__pyx_v_elem == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 592; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("lib.intbitset.intbitset.remove");
  return NULL;
  __pyx_L4_argument_unpacking_done:;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":596
 *         If the element is not a member, raise a KeyError.
 *         """
 *         if self.sanity_checks:             # <<<<<<<<<<<<<<
 *             if elem < 0:
 *                 raise ValueError("Negative numbers, not allowed")
 */
  __pyx_t_1 = ((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->sanity_checks;
  if (__pyx_t_1) {

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":597
 *         """
 *         if self.sanity_checks:
 *             if elem < 0:             # <<<<<<<<<<<<<<
 *                 raise ValueError("Negative numbers, not allowed")
 *             elif elem > maxelem:
 */
    __pyx_t_1 = (__pyx_v_elem < 0);
    if (__pyx_t_1) {

      /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":598
 *         if self.sanity_checks:
 *             if elem < 0:
 *                 raise ValueError("Negative numbers, not allowed")             # <<<<<<<<<<<<<<
 *             elif elem > maxelem:
 *                 raise OverflowError("Elements must be <= %s" % maxelem)
 */
      __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 598; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(((PyObject *)__pyx_t_2));
      __Pyx_INCREF(__pyx_kp_62);
      PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_kp_62);
      __Pyx_GIVEREF(__pyx_kp_62);
      __pyx_t_3 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_t_2), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 598; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
      __Pyx_Raise(__pyx_t_3, 0, 0);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 598; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      goto __pyx_L6;
    }

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":599
 *             if elem < 0:
 *                 raise ValueError("Negative numbers, not allowed")
 *             elif elem > maxelem:             # <<<<<<<<<<<<<<
 *                 raise OverflowError("Elements must be <= %s" % maxelem)
 *         if intBitSetIsInElem(self.bitset, elem):
 */
    __pyx_t_1 = (__pyx_v_elem > maxelem);
    if (__pyx_t_1) {

      /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":600
 *                 raise ValueError("Negative numbers, not allowed")
 *             elif elem > maxelem:
 *                 raise OverflowError("Elements must be <= %s" % maxelem)             # <<<<<<<<<<<<<<
 *         if intBitSetIsInElem(self.bitset, elem):
 *             intBitSetDelElem(self.bitset, elem)
 */
      __pyx_t_3 = PyInt_FromLong(maxelem); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 600; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __pyx_t_2 = PyNumber_Remainder(__pyx_kp_63, __pyx_t_3); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 600; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 600; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(((PyObject *)__pyx_t_3));
      PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_2);
      __Pyx_GIVEREF(__pyx_t_2);
      __pyx_t_2 = 0;
      __pyx_t_2 = PyObject_Call(__pyx_builtin_OverflowError, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 600; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_2);
      __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
      __Pyx_Raise(__pyx_t_2, 0, 0);
      __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 600; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      goto __pyx_L6;
    }
    __pyx_L6:;
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":601
 *             elif elem > maxelem:
 *                 raise OverflowError("Elements must be <= %s" % maxelem)
 *         if intBitSetIsInElem(self.bitset, elem):             # <<<<<<<<<<<<<<
 *             intBitSetDelElem(self.bitset, elem)
 *         else:
 */
  __pyx_t_1 = intBitSetIsInElem(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset, __pyx_v_elem);
  if (__pyx_t_1) {

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":602
 *                 raise OverflowError("Elements must be <= %s" % maxelem)
 *         if intBitSetIsInElem(self.bitset, elem):
 *             intBitSetDelElem(self.bitset, elem)             # <<<<<<<<<<<<<<
 *         else:
 *             raise KeyError(elem)
 */
    intBitSetDelElem(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset, __pyx_v_elem);
    goto __pyx_L7;
  }
  /*else*/ {

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":604
 *             intBitSetDelElem(self.bitset, elem)
 *         else:
 *             raise KeyError(elem)             # <<<<<<<<<<<<<<
 * 
 *     def strbits(self):
 */
    __pyx_t_2 = PyInt_FromLong(__pyx_v_elem); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 604; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 604; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(((PyObject *)__pyx_t_3));
    PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_t_2);
    __Pyx_GIVEREF(__pyx_t_2);
    __pyx_t_2 = 0;
    __pyx_t_2 = PyObject_Call(__pyx_builtin_KeyError, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 604; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
    __Pyx_Raise(__pyx_t_2, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 604; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L7:;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("lib.intbitset.intbitset.remove");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_FinishRefcountContext();
  return __pyx_r;
}

/* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":606
 *             raise KeyError(elem)
 * 
 *     def strbits(self):             # <<<<<<<<<<<<<<
 *         """Return a string of 0s and 1s representing the content in memory
 *         of the intbitset.
 */

static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_strbits(PyObject *__pyx_v_self, PyObject *unused); /*proto*/
static char __pyx_doc_3lib_9intbitset_9intbitset_strbits[] = "Return a string of 0s and 1s representing the content in memory\n        of the intbitset.\n        ";
static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_strbits(PyObject *__pyx_v_self, PyObject *unused) {
  int __pyx_v_i;
  int __pyx_v_last;
  PyObject *__pyx_v_ret;
  PyObject *__pyx_r = NULL;
  word_t __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  Py_ssize_t __pyx_t_4;
  int __pyx_t_5;
  PyObject *__pyx_t_6 = NULL;
  __Pyx_SetupRefcountContext("strbits");
  __pyx_v_ret = Py_None; __Pyx_INCREF(Py_None);

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":612
 *         cdef int i
 *         cdef int last
 *         if (<intbitset> self).bitset.trailing_bits:             # <<<<<<<<<<<<<<
 *             raise OverflowError("It's impossible to print an infinite set.")
 *         last = 0
 */
  __pyx_t_1 = ((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset->trailing_bits;
  if (__pyx_t_1) {

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":613
 *         cdef int last
 *         if (<intbitset> self).bitset.trailing_bits:
 *             raise OverflowError("It's impossible to print an infinite set.")             # <<<<<<<<<<<<<<
 *         last = 0
 *         ret = ''
 */
    __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 613; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(((PyObject *)__pyx_t_2));
    __Pyx_INCREF(__pyx_kp_64);
    PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_kp_64);
    __Pyx_GIVEREF(__pyx_kp_64);
    __pyx_t_3 = PyObject_Call(__pyx_builtin_OverflowError, ((PyObject *)__pyx_t_2), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 613; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
    __Pyx_Raise(__pyx_t_3, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 613; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":614
 *         if (<intbitset> self).bitset.trailing_bits:
 *             raise OverflowError("It's impossible to print an infinite set.")
 *         last = 0             # <<<<<<<<<<<<<<
 *         ret = ''
 *         for i in self:
 */
  __pyx_v_last = 0;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":615
 *             raise OverflowError("It's impossible to print an infinite set.")
 *         last = 0
 *         ret = ''             # <<<<<<<<<<<<<<
 *         for i in self:
 *             ret = ret + '0'*(i-last)+'1'
 */
  __Pyx_INCREF(__pyx_kp_65);
  __Pyx_DECREF(__pyx_v_ret);
  __pyx_v_ret = __pyx_kp_65;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":616
 *         last = 0
 *         ret = ''
 *         for i in self:             # <<<<<<<<<<<<<<
 *             ret = ret + '0'*(i-last)+'1'
 *             last = i+1
 */
  if (PyList_CheckExact(__pyx_v_self) || PyTuple_CheckExact(__pyx_v_self)) {
    __pyx_t_4 = 0; __pyx_t_3 = __pyx_v_self; __Pyx_INCREF(__pyx_t_3);
  } else {
    __pyx_t_4 = -1; __pyx_t_3 = PyObject_GetIter(__pyx_v_self); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 616; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
  }
  for (;;) {
    if (likely(PyList_CheckExact(__pyx_t_3))) {
      if (__pyx_t_4 >= PyList_GET_SIZE(__pyx_t_3)) break;
      __pyx_t_2 = PyList_GET_ITEM(__pyx_t_3, __pyx_t_4); __Pyx_INCREF(__pyx_t_2); __pyx_t_4++;
    } else if (likely(PyTuple_CheckExact(__pyx_t_3))) {
      if (__pyx_t_4 >= PyTuple_GET_SIZE(__pyx_t_3)) break;
      __pyx_t_2 = PyTuple_GET_ITEM(__pyx_t_3, __pyx_t_4); __Pyx_INCREF(__pyx_t_2); __pyx_t_4++;
    } else {
      __pyx_t_2 = PyIter_Next(__pyx_t_3);
      if (!__pyx_t_2) {
        if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 616; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
        break;
      }
      __Pyx_GOTREF(__pyx_t_2);
    }
    __pyx_t_5 = __Pyx_PyInt_AsInt(__pyx_t_2); if (unlikely((__pyx_t_5 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 616; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_v_i = __pyx_t_5;

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":617
 *         ret = ''
 *         for i in self:
 *             ret = ret + '0'*(i-last)+'1'             # <<<<<<<<<<<<<<
 *             last = i+1
 *         return ret
 */
    __pyx_t_2 = PyInt_FromLong((__pyx_v_i - __pyx_v_last)); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 617; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_6 = PyNumber_Multiply(__pyx_kp_66, __pyx_t_2); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 617; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_2 = PyNumber_Add(__pyx_v_ret, __pyx_t_6); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 617; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
    __pyx_t_6 = PyNumber_Add(__pyx_t_2, __pyx_kp_67); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 617; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_6);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_DECREF(__pyx_v_ret);
    __pyx_v_ret = __pyx_t_6;
    __pyx_t_6 = 0;

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":618
 *         for i in self:
 *             ret = ret + '0'*(i-last)+'1'
 *             last = i+1             # <<<<<<<<<<<<<<
 *         return ret
 * 
 */
    __pyx_v_last = (__pyx_v_i + 1);
  }
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":619
 *             ret = ret + '0'*(i-last)+'1'
 *             last = i+1
 *         return ret             # <<<<<<<<<<<<<<
 * 
 *     def update_with_signs(self, rhs):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_ret);
  __pyx_r = __pyx_v_ret;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_AddTraceback("lib.intbitset.intbitset.strbits");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_ret);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_FinishRefcountContext();
  return __pyx_r;
}

/* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":621
 *         return ret
 * 
 *     def update_with_signs(self, rhs):             # <<<<<<<<<<<<<<
 *         """Given a dictionary rhs whose keys are integers, remove all the integers
 *         whose value are less than 0 and add every integer whose value is 0 or more"""
 */

static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_update_with_signs(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs); /*proto*/
static char __pyx_doc_3lib_9intbitset_9intbitset_update_with_signs[] = "Given a dictionary rhs whose keys are integers, remove all the integers\n        whose value are less than 0 and add every integer whose value is 0 or more";
static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_update_with_signs(PyObject *__pyx_v_self, PyObject *__pyx_v_rhs) {
  int __pyx_v_value;
  PyObject *__pyx_v_sign;
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_1 = 0;
  PyObject *__pyx_2 = 0;
  int __pyx_3;
  int __pyx_t_1;
  Py_ssize_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  PyObject *__pyx_t_6 = NULL;
  PyObject *__pyx_t_7 = NULL;
  PyObject *__pyx_t_8 = NULL;
  __Pyx_SetupRefcountContext("update_with_signs");
  __pyx_v_sign = Py_None; __Pyx_INCREF(Py_None);

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":625
 *         whose value are less than 0 and add every integer whose value is 0 or more"""
 *         cdef int value
 *         try:             # <<<<<<<<<<<<<<
 *             if self.sanity_checks:
 *                 for value, sign in rhs.iteritems():
 */
  {
    PyObject *__pyx_save_exc_type, *__pyx_save_exc_value, *__pyx_save_exc_tb;
    __Pyx_ExceptionSave(&__pyx_save_exc_type, &__pyx_save_exc_value, &__pyx_save_exc_tb);
    __Pyx_XGOTREF(__pyx_save_exc_type);
    __Pyx_XGOTREF(__pyx_save_exc_value);
    __Pyx_XGOTREF(__pyx_save_exc_tb);
    /*try:*/ {

      /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":626
 *         cdef int value
 *         try:
 *             if self.sanity_checks:             # <<<<<<<<<<<<<<
 *                 for value, sign in rhs.iteritems():
 *                     if value < 0:
 */
      __pyx_t_1 = ((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->sanity_checks;
      if (__pyx_t_1) {

        /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":627
 *         try:
 *             if self.sanity_checks:
 *                 for value, sign in rhs.iteritems():             # <<<<<<<<<<<<<<
 *                     if value < 0:
 *                         raise ValueError("Negative numbers, not allowed")
 */
        __pyx_t_3 = PyObject_GetAttr(__pyx_v_rhs, __pyx_kp_iteritems); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 627; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
        __Pyx_GOTREF(__pyx_t_3);
        __pyx_t_4 = PyObject_Call(__pyx_t_3, ((PyObject *)__pyx_empty_tuple), NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 627; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        if (PyList_CheckExact(__pyx_t_4) || PyTuple_CheckExact(__pyx_t_4)) {
          __pyx_t_2 = 0; __pyx_t_3 = __pyx_t_4; __Pyx_INCREF(__pyx_t_3);
        } else {
          __pyx_t_2 = -1; __pyx_t_3 = PyObject_GetIter(__pyx_t_4); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 627; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
          __Pyx_GOTREF(__pyx_t_3);
        }
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
        for (;;) {
          if (likely(PyList_CheckExact(__pyx_t_3))) {
            if (__pyx_t_2 >= PyList_GET_SIZE(__pyx_t_3)) break;
            __pyx_t_4 = PyList_GET_ITEM(__pyx_t_3, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++;
          } else if (likely(PyTuple_CheckExact(__pyx_t_3))) {
            if (__pyx_t_2 >= PyTuple_GET_SIZE(__pyx_t_3)) break;
            __pyx_t_4 = PyTuple_GET_ITEM(__pyx_t_3, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++;
          } else {
            __pyx_t_4 = PyIter_Next(__pyx_t_3);
            if (!__pyx_t_4) {
              if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 627; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
              break;
            }
            __Pyx_GOTREF(__pyx_t_4);
          }
          if (PyTuple_CheckExact(__pyx_t_4) && likely(PyTuple_GET_SIZE(__pyx_t_4) == 2)) {
            PyObject* tuple = __pyx_t_4;
            __pyx_2 = PyTuple_GET_ITEM(tuple, 0); __Pyx_INCREF(__pyx_2);
            __pyx_t_5 = __Pyx_PyInt_AsInt(__pyx_2); if (unlikely((__pyx_t_5 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 627; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
            __Pyx_DECREF(__pyx_2); __pyx_2 = 0;
            __pyx_2 = PyTuple_GET_ITEM(tuple, 1); __Pyx_INCREF(__pyx_2);
            __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
            __pyx_v_value = __pyx_t_5;
            __Pyx_DECREF(__pyx_v_sign);
            __pyx_v_sign = __pyx_2;
            __pyx_2 = 0;
          } else {
            __pyx_1 = PyObject_GetIter(__pyx_t_4); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 627; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
            __Pyx_GOTREF(__pyx_1);
            __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
            __pyx_2 = __Pyx_UnpackItem(__pyx_1, 0); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 627; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
            __Pyx_GOTREF(__pyx_2);
            __pyx_t_5 = __Pyx_PyInt_AsInt(__pyx_2); if (unlikely((__pyx_t_5 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 627; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
            __Pyx_DECREF(__pyx_2); __pyx_2 = 0;
            __pyx_2 = __Pyx_UnpackItem(__pyx_1, 1); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 627; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
            __Pyx_GOTREF(__pyx_2);
            if (__Pyx_EndUnpack(__pyx_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 627; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
            __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
            __pyx_v_value = __pyx_t_5;
            __Pyx_DECREF(__pyx_v_sign);
            __pyx_v_sign = __pyx_2;
            __pyx_2 = 0;
          }

          /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":628
 *             if self.sanity_checks:
 *                 for value, sign in rhs.iteritems():
 *                     if value < 0:             # <<<<<<<<<<<<<<
 *                         raise ValueError("Negative numbers, not allowed")
 *                     elif value > maxelem:
 */
          __pyx_t_1 = (__pyx_v_value < 0);
          if (__pyx_t_1) {

            /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":629
 *                 for value, sign in rhs.iteritems():
 *                     if value < 0:
 *                         raise ValueError("Negative numbers, not allowed")             # <<<<<<<<<<<<<<
 *                     elif value > maxelem:
 *                         raise OverflowError("Elements must <= %s" % maxelem)
 */
            __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 629; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
            __Pyx_GOTREF(((PyObject *)__pyx_t_4));
            __Pyx_INCREF(__pyx_kp_68);
            PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_kp_68);
            __Pyx_GIVEREF(__pyx_kp_68);
            __pyx_t_6 = PyObject_Call(__pyx_builtin_ValueError, ((PyObject *)__pyx_t_4), NULL); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 629; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
            __Pyx_GOTREF(__pyx_t_6);
            __Pyx_DECREF(((PyObject *)__pyx_t_4)); __pyx_t_4 = 0;
            __Pyx_Raise(__pyx_t_6, 0, 0);
            __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
            {__pyx_filename = __pyx_f[0]; __pyx_lineno = 629; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
            goto __pyx_L16;
          }

          /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":630
 *                     if value < 0:
 *                         raise ValueError("Negative numbers, not allowed")
 *                     elif value > maxelem:             # <<<<<<<<<<<<<<
 *                         raise OverflowError("Elements must <= %s" % maxelem)
 *                     if sign < 0:
 */
          __pyx_t_1 = (__pyx_v_value > maxelem);
          if (__pyx_t_1) {

            /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":631
 *                         raise ValueError("Negative numbers, not allowed")
 *                     elif value > maxelem:
 *                         raise OverflowError("Elements must <= %s" % maxelem)             # <<<<<<<<<<<<<<
 *                     if sign < 0:
 *                         intBitSetDelElem(self.bitset, value)
 */
            __pyx_t_6 = PyInt_FromLong(maxelem); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 631; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
            __Pyx_GOTREF(__pyx_t_6);
            __pyx_t_4 = PyNumber_Remainder(__pyx_kp_69, __pyx_t_6); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 631; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
            __Pyx_GOTREF(__pyx_t_4);
            __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
            __pyx_t_6 = PyTuple_New(1); if (unlikely(!__pyx_t_6)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 631; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
            __Pyx_GOTREF(((PyObject *)__pyx_t_6));
            PyTuple_SET_ITEM(__pyx_t_6, 0, __pyx_t_4);
            __Pyx_GIVEREF(__pyx_t_4);
            __pyx_t_4 = 0;
            __pyx_t_4 = PyObject_Call(__pyx_builtin_OverflowError, ((PyObject *)__pyx_t_6), NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 631; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
            __Pyx_GOTREF(__pyx_t_4);
            __Pyx_DECREF(((PyObject *)__pyx_t_6)); __pyx_t_6 = 0;
            __Pyx_Raise(__pyx_t_4, 0, 0);
            __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
            {__pyx_filename = __pyx_f[0]; __pyx_lineno = 631; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
            goto __pyx_L16;
          }
          __pyx_L16:;

          /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":632
 *                     elif value > maxelem:
 *                         raise OverflowError("Elements must <= %s" % maxelem)
 *                     if sign < 0:             # <<<<<<<<<<<<<<
 *                         intBitSetDelElem(self.bitset, value)
 *                     else:
 */
          __pyx_t_4 = PyObject_RichCompare(__pyx_v_sign, __pyx_int_0, Py_LT); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 632; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
          __Pyx_GOTREF(__pyx_t_4);
          __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_1 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 632; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
          __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
          if (__pyx_t_1) {

            /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":633
 *                         raise OverflowError("Elements must <= %s" % maxelem)
 *                     if sign < 0:
 *                         intBitSetDelElem(self.bitset, value)             # <<<<<<<<<<<<<<
 *                     else:
 *                         intBitSetAddElem(self.bitset, value)
 */
            intBitSetDelElem(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset, __pyx_v_value);
            goto __pyx_L17;
          }
          /*else*/ {

            /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":635
 *                         intBitSetDelElem(self.bitset, value)
 *                     else:
 *                         intBitSetAddElem(self.bitset, value)             # <<<<<<<<<<<<<<
 *             else:
 *                 for value, sign in rhs.iteritems():
 */
            intBitSetAddElem(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset, __pyx_v_value);
          }
          __pyx_L17:;
        }
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        goto __pyx_L13;
      }
      /*else*/ {

        /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":637
 *                         intBitSetAddElem(self.bitset, value)
 *             else:
 *                 for value, sign in rhs.iteritems():             # <<<<<<<<<<<<<<
 *                     if sign < 0:
 *                         intBitSetDelElem(self.bitset, value)
 */
        __pyx_t_3 = PyObject_GetAttr(__pyx_v_rhs, __pyx_kp_iteritems); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 637; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
        __Pyx_GOTREF(__pyx_t_3);
        __pyx_t_4 = PyObject_Call(__pyx_t_3, ((PyObject *)__pyx_empty_tuple), NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 637; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
        __Pyx_GOTREF(__pyx_t_4);
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
        if (PyList_CheckExact(__pyx_t_4) || PyTuple_CheckExact(__pyx_t_4)) {
          __pyx_t_2 = 0; __pyx_t_3 = __pyx_t_4; __Pyx_INCREF(__pyx_t_3);
        } else {
          __pyx_t_2 = -1; __pyx_t_3 = PyObject_GetIter(__pyx_t_4); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 637; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
          __Pyx_GOTREF(__pyx_t_3);
        }
        __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
        for (;;) {
          if (likely(PyList_CheckExact(__pyx_t_3))) {
            if (__pyx_t_2 >= PyList_GET_SIZE(__pyx_t_3)) break;
            __pyx_t_4 = PyList_GET_ITEM(__pyx_t_3, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++;
          } else if (likely(PyTuple_CheckExact(__pyx_t_3))) {
            if (__pyx_t_2 >= PyTuple_GET_SIZE(__pyx_t_3)) break;
            __pyx_t_4 = PyTuple_GET_ITEM(__pyx_t_3, __pyx_t_2); __Pyx_INCREF(__pyx_t_4); __pyx_t_2++;
          } else {
            __pyx_t_4 = PyIter_Next(__pyx_t_3);
            if (!__pyx_t_4) {
              if (unlikely(PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 637; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
              break;
            }
            __Pyx_GOTREF(__pyx_t_4);
          }
          if (PyTuple_CheckExact(__pyx_t_4) && likely(PyTuple_GET_SIZE(__pyx_t_4) == 2)) {
            PyObject* tuple = __pyx_t_4;
            __pyx_2 = PyTuple_GET_ITEM(tuple, 0); __Pyx_INCREF(__pyx_2);
            __pyx_t_5 = __Pyx_PyInt_AsInt(__pyx_2); if (unlikely((__pyx_t_5 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 637; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
            __Pyx_DECREF(__pyx_2); __pyx_2 = 0;
            __pyx_2 = PyTuple_GET_ITEM(tuple, 1); __Pyx_INCREF(__pyx_2);
            __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
            __pyx_v_value = __pyx_t_5;
            __Pyx_DECREF(__pyx_v_sign);
            __pyx_v_sign = __pyx_2;
            __pyx_2 = 0;
          } else {
            __pyx_1 = PyObject_GetIter(__pyx_t_4); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 637; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
            __Pyx_GOTREF(__pyx_1);
            __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
            __pyx_2 = __Pyx_UnpackItem(__pyx_1, 0); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 637; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
            __Pyx_GOTREF(__pyx_2);
            __pyx_t_5 = __Pyx_PyInt_AsInt(__pyx_2); if (unlikely((__pyx_t_5 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 637; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
            __Pyx_DECREF(__pyx_2); __pyx_2 = 0;
            __pyx_2 = __Pyx_UnpackItem(__pyx_1, 1); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 637; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
            __Pyx_GOTREF(__pyx_2);
            if (__Pyx_EndUnpack(__pyx_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 637; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
            __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
            __pyx_v_value = __pyx_t_5;
            __Pyx_DECREF(__pyx_v_sign);
            __pyx_v_sign = __pyx_2;
            __pyx_2 = 0;
          }

          /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":638
 *             else:
 *                 for value, sign in rhs.iteritems():
 *                     if sign < 0:             # <<<<<<<<<<<<<<
 *                         intBitSetDelElem(self.bitset, value)
 *                     else:
 */
          __pyx_t_4 = PyObject_RichCompare(__pyx_v_sign, __pyx_int_0, Py_LT); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 638; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
          __Pyx_GOTREF(__pyx_t_4);
          __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_t_4); if (unlikely(__pyx_t_1 < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 638; __pyx_clineno = __LINE__; goto __pyx_L5_error;}
          __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
          if (__pyx_t_1) {

            /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":639
 *                 for value, sign in rhs.iteritems():
 *                     if sign < 0:
 *                         intBitSetDelElem(self.bitset, value)             # <<<<<<<<<<<<<<
 *                     else:
 *                         intBitSetAddElem(self.bitset, value)
 */
            intBitSetDelElem(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset, __pyx_v_value);
            goto __pyx_L20;
          }
          /*else*/ {

            /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":641
 *                         intBitSetDelElem(self.bitset, value)
 *                     else:
 *                         intBitSetAddElem(self.bitset, value)             # <<<<<<<<<<<<<<
 *         except AttributeError:
 *             raise TypeError("rhs should be a valid dictionary with integers keys and integer values")
 */
            intBitSetAddElem(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset, __pyx_v_value);
          }
          __pyx_L20:;
        }
        __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      }
      __pyx_L13:;
    }
    __Pyx_XDECREF(__pyx_save_exc_type); __pyx_save_exc_type = 0;
    __Pyx_XDECREF(__pyx_save_exc_value); __pyx_save_exc_value = 0;
    __Pyx_XDECREF(__pyx_save_exc_tb); __pyx_save_exc_tb = 0;
    goto __pyx_L12_try_end;
    __pyx_L5_error:;
    __Pyx_XDECREF(__pyx_1); __pyx_1 = 0;
    __Pyx_XDECREF(__pyx_2); __pyx_2 = 0;
    __Pyx_XDECREF(__pyx_t_6); __pyx_t_6 = 0;
    __Pyx_XDECREF(__pyx_t_4); __pyx_t_4 = 0;
    __Pyx_XDECREF(__pyx_t_3); __pyx_t_3 = 0;

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":642
 *                     else:
 *                         intBitSetAddElem(self.bitset, value)
 *         except AttributeError:             # <<<<<<<<<<<<<<
 *             raise TypeError("rhs should be a valid dictionary with integers keys and integer values")
 * 
 */
    __pyx_3 = PyErr_ExceptionMatches(__pyx_builtin_AttributeError);
    if (__pyx_3) {
      __Pyx_AddTraceback("lib.intbitset.update_with_signs");
      if (__Pyx_GetException(&__pyx_t_3, &__pyx_t_4, &__pyx_t_6) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 642; __pyx_clineno = __LINE__; goto __pyx_L7_except_error;}
      __Pyx_GOTREF(__pyx_t_3);
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_GOTREF(__pyx_t_6);

      /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":643
 *                         intBitSetAddElem(self.bitset, value)
 *         except AttributeError:
 *             raise TypeError("rhs should be a valid dictionary with integers keys and integer values")             # <<<<<<<<<<<<<<
 * 
 *     def get_size(self):
 */
      __pyx_t_7 = PyTuple_New(1); if (unlikely(!__pyx_t_7)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 643; __pyx_clineno = __LINE__; goto __pyx_L7_except_error;}
      __Pyx_GOTREF(((PyObject *)__pyx_t_7));
      __Pyx_INCREF(__pyx_kp_70);
      PyTuple_SET_ITEM(__pyx_t_7, 0, __pyx_kp_70);
      __Pyx_GIVEREF(__pyx_kp_70);
      __pyx_t_8 = PyObject_Call(__pyx_builtin_TypeError, ((PyObject *)__pyx_t_7), NULL); if (unlikely(!__pyx_t_8)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 643; __pyx_clineno = __LINE__; goto __pyx_L7_except_error;}
      __Pyx_GOTREF(__pyx_t_8);
      __Pyx_DECREF(((PyObject *)__pyx_t_7)); __pyx_t_7 = 0;
      __Pyx_Raise(__pyx_t_8, 0, 0);
      __Pyx_DECREF(__pyx_t_8); __pyx_t_8 = 0;
      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 643; __pyx_clineno = __LINE__; goto __pyx_L7_except_error;}
      __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      __Pyx_DECREF(__pyx_t_6); __pyx_t_6 = 0;
      goto __pyx_L6_exception_handled;
    }
    __pyx_L7_except_error:;
    __Pyx_XDECREF(__pyx_save_exc_type);
    __Pyx_XDECREF(__pyx_save_exc_value);
    __Pyx_XDECREF(__pyx_save_exc_tb);
    goto __pyx_L1_error;
    __pyx_L6_exception_handled:;
    __Pyx_XGIVEREF(__pyx_save_exc_type);
    __Pyx_XGIVEREF(__pyx_save_exc_value);
    __Pyx_XGIVEREF(__pyx_save_exc_tb);
    __Pyx_ExceptionReset(__pyx_save_exc_type, __pyx_save_exc_value, __pyx_save_exc_tb);
    __pyx_L12_try_end:;
  }

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_1);
  __Pyx_XDECREF(__pyx_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_XDECREF(__pyx_t_6);
  __Pyx_XDECREF(__pyx_t_7);
  __Pyx_XDECREF(__pyx_t_8);
  __Pyx_AddTraceback("lib.intbitset.intbitset.update_with_signs");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_sign);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_FinishRefcountContext();
  return __pyx_r;
}

/* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":645
 *             raise TypeError("rhs should be a valid dictionary with integers keys and integer values")
 * 
 *     def get_size(self):             # <<<<<<<<<<<<<<
 *         return intBitSetGetSize(self.bitset)
 * 
 */

static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_get_size(PyObject *__pyx_v_self, PyObject *unused); /*proto*/
static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_get_size(PyObject *__pyx_v_self, PyObject *unused) {
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  __Pyx_SetupRefcountContext("get_size");

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":646
 * 
 *     def get_size(self):
 *         return intBitSetGetSize(self.bitset)             # <<<<<<<<<<<<<<
 * 
 *     def get_allocated(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyInt_FromLong(intBitSetGetSize(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 646; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("lib.intbitset.intbitset.get_size");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_FinishRefcountContext();
  return __pyx_r;
}

/* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":648
 *         return intBitSetGetSize(self.bitset)
 * 
 *     def get_allocated(self):             # <<<<<<<<<<<<<<
 *         return intBitSetGetAllocated(self.bitset)
 * 
 */

static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_get_allocated(PyObject *__pyx_v_self, PyObject *unused); /*proto*/
static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_get_allocated(PyObject *__pyx_v_self, PyObject *unused) {
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  __Pyx_SetupRefcountContext("get_allocated");

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":649
 * 
 *     def get_allocated(self):
 *         return intBitSetGetAllocated(self.bitset)             # <<<<<<<<<<<<<<
 * 
 *     def get_sorted_element(self, int index):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyInt_FromLong(intBitSetGetAllocated(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 649; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("lib.intbitset.intbitset.get_allocated");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_FinishRefcountContext();
  return __pyx_r;
}

/* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":651
 *         return intBitSetGetAllocated(self.bitset)
 * 
 *     def get_sorted_element(self, int index):             # <<<<<<<<<<<<<<
 *         """Return element at position index in the sorted representation of the
 *         set. Note that index must be less than len(self)"""
 */

static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_get_sorted_element(PyObject *__pyx_v_self, PyObject *__pyx_arg_index); /*proto*/
static char __pyx_doc_3lib_9intbitset_9intbitset_get_sorted_element[] = "Return element at position index in the sorted representation of the\n        set. Note that index must be less than len(self)";
static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_get_sorted_element(PyObject *__pyx_v_self, PyObject *__pyx_arg_index) {
  int __pyx_v_index;
  int __pyx_v_l;
  int __pyx_v_last;
  int __pyx_v_i;
  PyObject *__pyx_r = NULL;
  int __pyx_t_1;
  word_t __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  __Pyx_SetupRefcountContext("get_sorted_element");
  assert(__pyx_arg_index); {
    __pyx_v_index = __Pyx_PyInt_AsInt(__pyx_arg_index); if (unlikely((__pyx_v_index == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 651; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L3_error:;
  __Pyx_AddTraceback("lib.intbitset.intbitset.get_sorted_element");
  return NULL;
  __pyx_L4_argument_unpacking_done:;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":657
 *         cdef int last
 *         cdef int i
 *         l = intBitSetGetTot(self.bitset)             # <<<<<<<<<<<<<<
 *         if index < 0:
 *             if self.bitset.trailing_bits:
 */
  __pyx_v_l = intBitSetGetTot(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset);

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":658
 *         cdef int i
 *         l = intBitSetGetTot(self.bitset)
 *         if index < 0:             # <<<<<<<<<<<<<<
 *             if self.bitset.trailing_bits:
 *                 raise OverflowError("It's impossible to retrieve a negative item from an infinite set.")
 */
  __pyx_t_1 = (__pyx_v_index < 0);
  if (__pyx_t_1) {

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":659
 *         l = intBitSetGetTot(self.bitset)
 *         if index < 0:
 *             if self.bitset.trailing_bits:             # <<<<<<<<<<<<<<
 *                 raise OverflowError("It's impossible to retrieve a negative item from an infinite set.")
 *             index = index + l
 */
    __pyx_t_2 = ((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset->trailing_bits;
    if (__pyx_t_2) {

      /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":660
 *         if index < 0:
 *             if self.bitset.trailing_bits:
 *                 raise OverflowError("It's impossible to retrieve a negative item from an infinite set.")             # <<<<<<<<<<<<<<
 *             index = index + l
 *         elif index > maxelem:
 */
      __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 660; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(((PyObject *)__pyx_t_3));
      __Pyx_INCREF(__pyx_kp_71);
      PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_kp_71);
      __Pyx_GIVEREF(__pyx_kp_71);
      __pyx_t_4 = PyObject_Call(__pyx_builtin_OverflowError, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 660; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      __Pyx_GOTREF(__pyx_t_4);
      __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
      __Pyx_Raise(__pyx_t_4, 0, 0);
      __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
      {__pyx_filename = __pyx_f[0]; __pyx_lineno = 660; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
      goto __pyx_L6;
    }
    __pyx_L6:;

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":661
 *             if self.bitset.trailing_bits:
 *                 raise OverflowError("It's impossible to retrieve a negative item from an infinite set.")
 *             index = index + l             # <<<<<<<<<<<<<<
 *         elif index > maxelem:
 *             raise OverflowError("Index must be <= %s" % maxelem)
 */
    __pyx_v_index = (__pyx_v_index + __pyx_v_l);
    goto __pyx_L5;
  }

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":662
 *                 raise OverflowError("It's impossible to retrieve a negative item from an infinite set.")
 *             index = index + l
 *         elif index > maxelem:             # <<<<<<<<<<<<<<
 *             raise OverflowError("Index must be <= %s" % maxelem)
 *         if 0 <= index < l:
 */
  __pyx_t_1 = (__pyx_v_index > maxelem);
  if (__pyx_t_1) {

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":663
 *             index = index + l
 *         elif index > maxelem:
 *             raise OverflowError("Index must be <= %s" % maxelem)             # <<<<<<<<<<<<<<
 *         if 0 <= index < l:
 *             last = intBitSetGetNext(self.bitset, -1)
 */
    __pyx_t_4 = PyInt_FromLong(maxelem); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 663; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_3 = PyNumber_Remainder(__pyx_kp_72, __pyx_t_4); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 663; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 663; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(((PyObject *)__pyx_t_4));
    PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_3);
    __Pyx_GIVEREF(__pyx_t_3);
    __pyx_t_3 = 0;
    __pyx_t_3 = PyObject_Call(__pyx_builtin_OverflowError, ((PyObject *)__pyx_t_4), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 663; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(((PyObject *)__pyx_t_4)); __pyx_t_4 = 0;
    __Pyx_Raise(__pyx_t_3, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 663; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":664
 *         elif index > maxelem:
 *             raise OverflowError("Index must be <= %s" % maxelem)
 *         if 0 <= index < l:             # <<<<<<<<<<<<<<
 *             last = intBitSetGetNext(self.bitset, -1)
 *             for i from 0 <= i < index:
 */
  __pyx_t_1 = (0 <= __pyx_v_index);
  if (__pyx_t_1) {
    __pyx_t_1 = (__pyx_v_index < __pyx_v_l);
  }
  if (__pyx_t_1) {

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":665
 *             raise OverflowError("Index must be <= %s" % maxelem)
 *         if 0 <= index < l:
 *             last = intBitSetGetNext(self.bitset, -1)             # <<<<<<<<<<<<<<
 *             for i from 0 <= i < index:
 *                 last = intBitSetGetNext(self.bitset, last)
 */
    __pyx_v_last = intBitSetGetNext(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset, -1);

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":666
 *         if 0 <= index < l:
 *             last = intBitSetGetNext(self.bitset, -1)
 *             for i from 0 <= i < index:             # <<<<<<<<<<<<<<
 *                 last = intBitSetGetNext(self.bitset, last)
 *         else:
 */
    __pyx_t_5 = __pyx_v_index;
    for (__pyx_v_i = 0; __pyx_v_i < __pyx_t_5; __pyx_v_i++) {

      /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":667
 *             last = intBitSetGetNext(self.bitset, -1)
 *             for i from 0 <= i < index:
 *                 last = intBitSetGetNext(self.bitset, last)             # <<<<<<<<<<<<<<
 *         else:
 *             raise IndexError("intbitset index out of range")
 */
      __pyx_v_last = intBitSetGetNext(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset, __pyx_v_last);
    }
    goto __pyx_L7;
  }
  /*else*/ {

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":669
 *                 last = intBitSetGetNext(self.bitset, last)
 *         else:
 *             raise IndexError("intbitset index out of range")             # <<<<<<<<<<<<<<
 *         return last
 * 
 */
    __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 669; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(((PyObject *)__pyx_t_3));
    __Pyx_INCREF(__pyx_kp_73);
    PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_kp_73);
    __Pyx_GIVEREF(__pyx_kp_73);
    __pyx_t_4 = PyObject_Call(__pyx_builtin_IndexError, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 669; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
    __Pyx_Raise(__pyx_t_4, 0, 0);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 669; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  }
  __pyx_L7:;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":670
 *         else:
 *             raise IndexError("intbitset index out of range")
 *         return last             # <<<<<<<<<<<<<<
 * 
 *     def to_sorted_list(self, int i, int j):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_4 = PyInt_FromLong(__pyx_v_last); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 670; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __pyx_r = __pyx_t_4;
  __pyx_t_4 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("lib.intbitset.intbitset.get_sorted_element");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_FinishRefcountContext();
  return __pyx_r;
}

/* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":672
 *         return last
 * 
 *     def to_sorted_list(self, int i, int j):             # <<<<<<<<<<<<<<
 *         """Return a sublist of the sorted representation of the set.
 *         Note, negative indices are not supported."""
 */

static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_to_sorted_list(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_3lib_9intbitset_9intbitset_to_sorted_list[] = "Return a sublist of the sorted representation of the set.\n        Note, negative indices are not supported.";
static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_to_sorted_list(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  int __pyx_v_i;
  int __pyx_v_j;
  int __pyx_v_l;
  int __pyx_v_last;
  int __pyx_v_cnt;
  PyObject *__pyx_v_ret;
  PyObject *__pyx_r = NULL;
  int __pyx_t_1;
  int __pyx_t_2;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  static PyObject **__pyx_pyargnames[] = {&__pyx_kp_i,&__pyx_kp_j,0};
  __Pyx_SetupRefcountContext("to_sorted_list");
  if (unlikely(__pyx_kwds)) {
    Py_ssize_t kw_args = PyDict_Size(__pyx_kwds);
    PyObject* values[2] = {0,0};
    switch (PyTuple_GET_SIZE(__pyx_args)) {
      case  2: values[1] = PyTuple_GET_ITEM(__pyx_args, 1);
      case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      case  0: break;
      default: goto __pyx_L5_argtuple_error;
    }
    switch (PyTuple_GET_SIZE(__pyx_args)) {
      case  0:
      values[0] = PyDict_GetItem(__pyx_kwds, __pyx_kp_i);
      if (likely(values[0])) kw_args--;
      else goto __pyx_L5_argtuple_error;
      case  1:
      values[1] = PyDict_GetItem(__pyx_kwds, __pyx_kp_j);
      if (likely(values[1])) kw_args--;
      else {
        __Pyx_RaiseArgtupleInvalid("to_sorted_list", 1, 2, 2, 1); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 672; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      }
    }
    if (unlikely(kw_args > 0)) {
      if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, PyTuple_GET_SIZE(__pyx_args), "to_sorted_list") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 672; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    }
    __pyx_v_i = __Pyx_PyInt_AsInt(values[0]); if (unlikely((__pyx_v_i == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 672; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_j = __Pyx_PyInt_AsInt(values[1]); if (unlikely((__pyx_v_j == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 672; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  } else if (PyTuple_GET_SIZE(__pyx_args) != 2) {
    goto __pyx_L5_argtuple_error;
  } else {
    __pyx_v_i = __Pyx_PyInt_AsInt(PyTuple_GET_ITEM(__pyx_args, 0)); if (unlikely((__pyx_v_i == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 672; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    __pyx_v_j = __Pyx_PyInt_AsInt(PyTuple_GET_ITEM(__pyx_args, 1)); if (unlikely((__pyx_v_j == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 672; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("to_sorted_list", 1, 2, 2, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 672; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("lib.intbitset.intbitset.to_sorted_list");
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_v_ret = Py_None; __Pyx_INCREF(Py_None);

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":678
 *         cdef int last
 *         cdef int cnt
 *         if self.bitset.trailing_bits and (i < 0 or j < 0):             # <<<<<<<<<<<<<<
 *             raise OverflowError("It's impossible to retrieve a sublist using negative indices from an infinite set.")
 *         elif (i > maxelem or j > maxelem):
 */
  if (((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset->trailing_bits) {
    if (!(__pyx_v_i < 0)) {
      __pyx_t_1 = (__pyx_v_j < 0);
    } else {
      __pyx_t_1 = (__pyx_v_i < 0);
    }
    __pyx_t_2 = __pyx_t_1;
  } else {
    __pyx_t_2 = ((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset->trailing_bits;
  }
  if (__pyx_t_2) {

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":679
 *         cdef int cnt
 *         if self.bitset.trailing_bits and (i < 0 or j < 0):
 *             raise OverflowError("It's impossible to retrieve a sublist using negative indices from an infinite set.")             # <<<<<<<<<<<<<<
 *         elif (i > maxelem or j > maxelem):
 *             raise OverflowError("Indexes must be <= %s" % maxelem)
 */
    __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 679; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(((PyObject *)__pyx_t_3));
    __Pyx_INCREF(__pyx_kp_74);
    PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_kp_74);
    __Pyx_GIVEREF(__pyx_kp_74);
    __pyx_t_4 = PyObject_Call(__pyx_builtin_OverflowError, ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 679; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
    __Pyx_Raise(__pyx_t_4, 0, 0);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 679; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    goto __pyx_L6;
  }

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":680
 *         if self.bitset.trailing_bits and (i < 0 or j < 0):
 *             raise OverflowError("It's impossible to retrieve a sublist using negative indices from an infinite set.")
 *         elif (i > maxelem or j > maxelem):             # <<<<<<<<<<<<<<
 *             raise OverflowError("Indexes must be <= %s" % maxelem)
 *         l = intBitSetGetTot(self.bitset)
 */
  if (!(__pyx_v_i > maxelem)) {
    __pyx_t_2 = (__pyx_v_j > maxelem);
  } else {
    __pyx_t_2 = (__pyx_v_i > maxelem);
  }
  if (__pyx_t_2) {

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":681
 *             raise OverflowError("It's impossible to retrieve a sublist using negative indices from an infinite set.")
 *         elif (i > maxelem or j > maxelem):
 *             raise OverflowError("Indexes must be <= %s" % maxelem)             # <<<<<<<<<<<<<<
 *         l = intBitSetGetTot(self.bitset)
 *         if i == 0 and j == -1:
 */
    __pyx_t_4 = PyInt_FromLong(maxelem); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 681; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __pyx_t_3 = PyNumber_Remainder(__pyx_kp_75, __pyx_t_4); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 681; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
    __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 681; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(((PyObject *)__pyx_t_4));
    PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_3);
    __Pyx_GIVEREF(__pyx_t_3);
    __pyx_t_3 = 0;
    __pyx_t_3 = PyObject_Call(__pyx_builtin_OverflowError, ((PyObject *)__pyx_t_4), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 681; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(((PyObject *)__pyx_t_4)); __pyx_t_4 = 0;
    __Pyx_Raise(__pyx_t_3, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 681; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":682
 *         elif (i > maxelem or j > maxelem):
 *             raise OverflowError("Indexes must be <= %s" % maxelem)
 *         l = intBitSetGetTot(self.bitset)             # <<<<<<<<<<<<<<
 *         if i == 0 and j == -1:
 *             return intbitset(self)
 */
  __pyx_v_l = intBitSetGetTot(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset);

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":683
 *             raise OverflowError("Indexes must be <= %s" % maxelem)
 *         l = intBitSetGetTot(self.bitset)
 *         if i == 0 and j == -1:             # <<<<<<<<<<<<<<
 *             return intbitset(self)
 *         ret = intbitset()
 */
  if ((__pyx_v_i == 0)) {
    __pyx_t_2 = (__pyx_v_j == -1);
  } else {
    __pyx_t_2 = (__pyx_v_i == 0);
  }
  if (__pyx_t_2) {

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":684
 *         l = intBitSetGetTot(self.bitset)
 *         if i == 0 and j == -1:
 *             return intbitset(self)             # <<<<<<<<<<<<<<
 *         ret = intbitset()
 *         if i < 0:
 */
    __Pyx_XDECREF(__pyx_r);
    __pyx_t_3 = PyTuple_New(1); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 684; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(((PyObject *)__pyx_t_3));
    __Pyx_INCREF(__pyx_v_self);
    PyTuple_SET_ITEM(__pyx_t_3, 0, __pyx_v_self);
    __Pyx_GIVEREF(__pyx_v_self);
    __pyx_t_4 = PyObject_Call(((PyObject *)((PyObject*)__pyx_ptype_3lib_9intbitset_intbitset)), ((PyObject *)__pyx_t_3), NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 684; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(((PyObject *)__pyx_t_3)); __pyx_t_3 = 0;
    __pyx_r = __pyx_t_4;
    __pyx_t_4 = 0;
    goto __pyx_L0;
    goto __pyx_L7;
  }
  __pyx_L7:;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":685
 *         if i == 0 and j == -1:
 *             return intbitset(self)
 *         ret = intbitset()             # <<<<<<<<<<<<<<
 *         if i < 0:
 *             i = i + l
 */
  __pyx_t_4 = PyObject_Call(((PyObject *)((PyObject*)__pyx_ptype_3lib_9intbitset_intbitset)), ((PyObject *)__pyx_empty_tuple), NULL); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 685; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_4);
  __Pyx_DECREF(__pyx_v_ret);
  __pyx_v_ret = __pyx_t_4;
  __pyx_t_4 = 0;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":686
 *             return intbitset(self)
 *         ret = intbitset()
 *         if i < 0:             # <<<<<<<<<<<<<<
 *             i = i + l
 *         if j < 0:
 */
  __pyx_t_2 = (__pyx_v_i < 0);
  if (__pyx_t_2) {

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":687
 *         ret = intbitset()
 *         if i < 0:
 *             i = i + l             # <<<<<<<<<<<<<<
 *         if j < 0:
 *             j = j + l
 */
    __pyx_v_i = (__pyx_v_i + __pyx_v_l);
    goto __pyx_L8;
  }
  __pyx_L8:;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":688
 *         if i < 0:
 *             i = i + l
 *         if j < 0:             # <<<<<<<<<<<<<<
 *             j = j + l
 *         if i >= l:
 */
  __pyx_t_2 = (__pyx_v_j < 0);
  if (__pyx_t_2) {

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":689
 *             i = i + l
 *         if j < 0:
 *             j = j + l             # <<<<<<<<<<<<<<
 *         if i >= l:
 *             i = l
 */
    __pyx_v_j = (__pyx_v_j + __pyx_v_l);
    goto __pyx_L9;
  }
  __pyx_L9:;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":690
 *         if j < 0:
 *             j = j + l
 *         if i >= l:             # <<<<<<<<<<<<<<
 *             i = l
 *         if j >= l:
 */
  __pyx_t_2 = (__pyx_v_i >= __pyx_v_l);
  if (__pyx_t_2) {

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":691
 *             j = j + l
 *         if i >= l:
 *             i = l             # <<<<<<<<<<<<<<
 *         if j >= l:
 *             j = l
 */
    __pyx_v_i = __pyx_v_l;
    goto __pyx_L10;
  }
  __pyx_L10:;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":692
 *         if i >= l:
 *             i = l
 *         if j >= l:             # <<<<<<<<<<<<<<
 *             j = l
 *         last = -1
 */
  __pyx_t_2 = (__pyx_v_j >= __pyx_v_l);
  if (__pyx_t_2) {

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":693
 *             i = l
 *         if j >= l:
 *             j = l             # <<<<<<<<<<<<<<
 *         last = -1
 *         for cnt from 0 <= cnt < i:
 */
    __pyx_v_j = __pyx_v_l;
    goto __pyx_L11;
  }
  __pyx_L11:;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":694
 *         if j >= l:
 *             j = l
 *         last = -1             # <<<<<<<<<<<<<<
 *         for cnt from 0 <= cnt < i:
 *             last = intBitSetGetNext(self.bitset, last)
 */
  __pyx_v_last = -1;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":695
 *             j = l
 *         last = -1
 *         for cnt from 0 <= cnt < i:             # <<<<<<<<<<<<<<
 *             last = intBitSetGetNext(self.bitset, last)
 *         for cnt from i <= cnt < j:
 */
  __pyx_t_5 = __pyx_v_i;
  for (__pyx_v_cnt = 0; __pyx_v_cnt < __pyx_t_5; __pyx_v_cnt++) {

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":696
 *         last = -1
 *         for cnt from 0 <= cnt < i:
 *             last = intBitSetGetNext(self.bitset, last)             # <<<<<<<<<<<<<<
 *         for cnt from i <= cnt < j:
 *             last = intBitSetGetNext(self.bitset, last)
 */
    __pyx_v_last = intBitSetGetNext(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset, __pyx_v_last);
  }

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":697
 *         for cnt from 0 <= cnt < i:
 *             last = intBitSetGetNext(self.bitset, last)
 *         for cnt from i <= cnt < j:             # <<<<<<<<<<<<<<
 *             last = intBitSetGetNext(self.bitset, last)
 *             intBitSetAddElem((<intbitset> ret).bitset, last)
 */
  __pyx_t_5 = __pyx_v_j;
  for (__pyx_v_cnt = __pyx_v_i; __pyx_v_cnt < __pyx_t_5; __pyx_v_cnt++) {

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":698
 *             last = intBitSetGetNext(self.bitset, last)
 *         for cnt from i <= cnt < j:
 *             last = intBitSetGetNext(self.bitset, last)             # <<<<<<<<<<<<<<
 *             intBitSetAddElem((<intbitset> ret).bitset, last)
 *         return ret
 */
    __pyx_v_last = intBitSetGetNext(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset, __pyx_v_last);

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":699
 *         for cnt from i <= cnt < j:
 *             last = intBitSetGetNext(self.bitset, last)
 *             intBitSetAddElem((<intbitset> ret).bitset, last)             # <<<<<<<<<<<<<<
 *         return ret
 * 
 */
    intBitSetAddElem(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_ret)->bitset, __pyx_v_last);
  }

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":700
 *             last = intBitSetGetNext(self.bitset, last)
 *             intBitSetAddElem((<intbitset> ret).bitset, last)
 *         return ret             # <<<<<<<<<<<<<<
 * 
 *     def is_infinite(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_ret);
  __pyx_r = __pyx_v_ret;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("lib.intbitset.intbitset.to_sorted_list");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_ret);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_FinishRefcountContext();
  return __pyx_r;
}

/* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":702
 *         return ret
 * 
 *     def is_infinite(self):             # <<<<<<<<<<<<<<
 *         """Return True if the intbitset is infinite. (i.e. trailing_bits=True
 *         was used in the constructor.)"""
 */

static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_is_infinite(PyObject *__pyx_v_self, PyObject *unused); /*proto*/
static char __pyx_doc_3lib_9intbitset_9intbitset_is_infinite[] = "Return True if the intbitset is infinite. (i.e. trailing_bits=True\n        was used in the constructor.)";
static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_is_infinite(PyObject *__pyx_v_self, PyObject *unused) {
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  __Pyx_SetupRefcountContext("is_infinite");

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":705
 *         """Return True if the intbitset is infinite. (i.e. trailing_bits=True
 *         was used in the constructor.)"""
 *         return self.bitset.trailing_bits != 0             # <<<<<<<<<<<<<<
 * 
 *     def extract_finite_list(self, int up_to=-1):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = __Pyx_PyBool_FromLong((((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset->trailing_bits != 0)); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 705; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("lib.intbitset.intbitset.is_infinite");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_FinishRefcountContext();
  return __pyx_r;
}

/* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":707
 *         return self.bitset.trailing_bits != 0
 * 
 *     def extract_finite_list(self, int up_to=-1):             # <<<<<<<<<<<<<<
 *         """Return a finite list of elements sufficient to be passed to intbitset
 *         constructor toghether with the proper value of trailing_bits in order
 */

static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_extract_finite_list(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static char __pyx_doc_3lib_9intbitset_9intbitset_extract_finite_list[] = "Return a finite list of elements sufficient to be passed to intbitset\n        constructor toghether with the proper value of trailing_bits in order\n        to reproduce this intbitset. At least up_to integer are looked for when\n        they are inside the intbitset but not necessarily needed to build the\n        intbitset";
static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_extract_finite_list(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  int __pyx_v_up_to;
  int __pyx_v_true_up_to;
  int __pyx_v_last;
  PyObject *__pyx_v_ret;
  PyObject *__pyx_r = NULL;
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  int __pyx_t_5;
  static PyObject **__pyx_pyargnames[] = {&__pyx_kp_up_to,0};
  __Pyx_SetupRefcountContext("extract_finite_list");
  if (unlikely(__pyx_kwds)) {
    Py_ssize_t kw_args = PyDict_Size(__pyx_kwds);
    PyObject* values[1] = {0};
    switch (PyTuple_GET_SIZE(__pyx_args)) {
      case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      case  0: break;
      default: goto __pyx_L5_argtuple_error;
    }
    switch (PyTuple_GET_SIZE(__pyx_args)) {
      case  0:
      if (kw_args > 1) {
        PyObject* value = PyDict_GetItem(__pyx_kwds, __pyx_kp_up_to);
        if (unlikely(value)) { values[0] = value; kw_args--; }
      }
    }
    if (unlikely(kw_args > 0)) {
      if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, PyTuple_GET_SIZE(__pyx_args), "extract_finite_list") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 707; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    }
    if (values[0]) {
      __pyx_v_up_to = __Pyx_PyInt_AsInt(values[0]); if (unlikely((__pyx_v_up_to == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 707; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    } else {
      __pyx_v_up_to = -1;
    }
  } else {
    __pyx_v_up_to = -1;
    switch (PyTuple_GET_SIZE(__pyx_args)) {
      case  1: __pyx_v_up_to = __Pyx_PyInt_AsInt(PyTuple_GET_ITEM(__pyx_args, 0)); if (unlikely((__pyx_v_up_to == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 707; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
      case  0: break;
      default: goto __pyx_L5_argtuple_error;
    }
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("extract_finite_list", 0, 0, 1, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 707; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("lib.intbitset.intbitset.extract_finite_list");
  return NULL;
  __pyx_L4_argument_unpacking_done:;
  __pyx_v_ret = Py_None; __Pyx_INCREF(Py_None);

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":715
 *         cdef int true_up_to
 *         cdef int last
 *         if self.sanity_checks and up_to > maxelem:             # <<<<<<<<<<<<<<
 *             raise OverflowError("up_to must be <= %s" % maxelem)
 *         ret = []
 */
  if (((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->sanity_checks) {
    __pyx_t_1 = (__pyx_v_up_to > maxelem);
  } else {
    __pyx_t_1 = ((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->sanity_checks;
  }
  if (__pyx_t_1) {

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":716
 *         cdef int last
 *         if self.sanity_checks and up_to > maxelem:
 *             raise OverflowError("up_to must be <= %s" % maxelem)             # <<<<<<<<<<<<<<
 *         ret = []
 *         true_up_to = max(up_to, (intBitSetGetSize(self.bitset)) * wordbitsize)
 */
    __pyx_t_2 = PyInt_FromLong(maxelem); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 716; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_3 = PyNumber_Remainder(__pyx_kp_76, __pyx_t_2); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 716; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 716; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(((PyObject *)__pyx_t_2));
    PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_t_3);
    __Pyx_GIVEREF(__pyx_t_3);
    __pyx_t_3 = 0;
    __pyx_t_3 = PyObject_Call(__pyx_builtin_OverflowError, ((PyObject *)__pyx_t_2), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 716; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
    __Pyx_Raise(__pyx_t_3, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 716; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":717
 *         if self.sanity_checks and up_to > maxelem:
 *             raise OverflowError("up_to must be <= %s" % maxelem)
 *         ret = []             # <<<<<<<<<<<<<<
 *         true_up_to = max(up_to, (intBitSetGetSize(self.bitset)) * wordbitsize)
 *         last = -1
 */
  __pyx_t_3 = PyList_New(0); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 717; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(((PyObject *)__pyx_t_3));
  __Pyx_DECREF(__pyx_v_ret);
  __pyx_v_ret = ((PyObject *)__pyx_t_3);
  __pyx_t_3 = 0;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":718
 *             raise OverflowError("up_to must be <= %s" % maxelem)
 *         ret = []
 *         true_up_to = max(up_to, (intBitSetGetSize(self.bitset)) * wordbitsize)             # <<<<<<<<<<<<<<
 *         last = -1
 *         while last < true_up_to:
 */
  __pyx_t_3 = PyInt_FromLong(__pyx_v_up_to); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 718; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyInt_FromLong((intBitSetGetSize(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset) * wordbitsize)); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 718; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __pyx_t_4 = PyTuple_New(2); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 718; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(((PyObject *)__pyx_t_4));
  PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_3);
  __Pyx_GIVEREF(__pyx_t_3);
  PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_2);
  __Pyx_GIVEREF(__pyx_t_2);
  __pyx_t_3 = 0;
  __pyx_t_2 = 0;
  __pyx_t_2 = PyObject_Call(__pyx_builtin_max, ((PyObject *)__pyx_t_4), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 718; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(((PyObject *)__pyx_t_4)); __pyx_t_4 = 0;
  __pyx_t_5 = __Pyx_PyInt_AsInt(__pyx_t_2); if (unlikely((__pyx_t_5 == (int)-1) && PyErr_Occurred())) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 718; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
  __pyx_v_true_up_to = __pyx_t_5;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":719
 *         ret = []
 *         true_up_to = max(up_to, (intBitSetGetSize(self.bitset)) * wordbitsize)
 *         last = -1             # <<<<<<<<<<<<<<
 *         while last < true_up_to:
 *             last = intBitSetGetNext(self.bitset, last)
 */
  __pyx_v_last = -1;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":720
 *         true_up_to = max(up_to, (intBitSetGetSize(self.bitset)) * wordbitsize)
 *         last = -1
 *         while last < true_up_to:             # <<<<<<<<<<<<<<
 *             last = intBitSetGetNext(self.bitset, last)
 *             if last == -2:
 */
  while (1) {
    __pyx_t_1 = (__pyx_v_last < __pyx_v_true_up_to);
    if (!__pyx_t_1) break;

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":721
 *         last = -1
 *         while last < true_up_to:
 *             last = intBitSetGetNext(self.bitset, last)             # <<<<<<<<<<<<<<
 *             if last == -2:
 *                 break
 */
    __pyx_v_last = intBitSetGetNext(((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset, __pyx_v_last);

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":722
 *         while last < true_up_to:
 *             last = intBitSetGetNext(self.bitset, last)
 *             if last == -2:             # <<<<<<<<<<<<<<
 *                 break
 *             ret.append(last)
 */
    __pyx_t_1 = (__pyx_v_last == -2);
    if (__pyx_t_1) {

      /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":723
 *             last = intBitSetGetNext(self.bitset, last)
 *             if last == -2:
 *                 break             # <<<<<<<<<<<<<<
 *             ret.append(last)
 *         return ret
 */
      goto __pyx_L8_break;
      goto __pyx_L9;
    }
    __pyx_L9:;

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":724
 *             if last == -2:
 *                 break
 *             ret.append(last)             # <<<<<<<<<<<<<<
 *         return ret
 * 
 */
    __pyx_t_2 = PyInt_FromLong(__pyx_v_last); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 724; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_4 = __Pyx_PyObject_Append(__pyx_v_ret, __pyx_t_2); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 724; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_4);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    __Pyx_DECREF(__pyx_t_4); __pyx_t_4 = 0;
  }
  __pyx_L8_break:;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":725
 *                 break
 *             ret.append(last)
 *         return ret             # <<<<<<<<<<<<<<
 * 
 *     def get_wordbitsize(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_ret);
  __pyx_r = __pyx_v_ret;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("lib.intbitset.intbitset.extract_finite_list");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_DECREF(__pyx_v_ret);
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_FinishRefcountContext();
  return __pyx_r;
}

/* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":727
 *         return ret
 * 
 *     def get_wordbitsize(self):             # <<<<<<<<<<<<<<
 *         return wordbitsize
 * 
 */

static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_get_wordbitsize(PyObject *__pyx_v_self, PyObject *unused); /*proto*/
static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_get_wordbitsize(PyObject *__pyx_v_self, PyObject *unused) {
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  __Pyx_SetupRefcountContext("get_wordbitsize");

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":728
 * 
 *     def get_wordbitsize(self):
 *         return wordbitsize             # <<<<<<<<<<<<<<
 * 
 *     def get_wordbytsize(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyInt_FromLong(wordbitsize); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 728; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("lib.intbitset.intbitset.get_wordbitsize");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_FinishRefcountContext();
  return __pyx_r;
}

/* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":730
 *         return wordbitsize
 * 
 *     def get_wordbytsize(self):             # <<<<<<<<<<<<<<
 *         return wordbytesize
 * 
 */

static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_get_wordbytsize(PyObject *__pyx_v_self, PyObject *unused); /*proto*/
static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_get_wordbytsize(PyObject *__pyx_v_self, PyObject *unused) {
  PyObject *__pyx_r = NULL;
  PyObject *__pyx_t_1 = NULL;
  __Pyx_SetupRefcountContext("get_wordbytsize");

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":731
 * 
 *     def get_wordbytsize(self):
 *         return wordbytesize             # <<<<<<<<<<<<<<
 * 
 *     def tolist(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_1 = PyInt_FromLong(wordbytesize); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 731; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  __pyx_r = __pyx_t_1;
  __pyx_t_1 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("lib.intbitset.intbitset.get_wordbytsize");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_FinishRefcountContext();
  return __pyx_r;
}

/* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":733
 *         return wordbytesize
 * 
 *     def tolist(self):             # <<<<<<<<<<<<<<
 *         """Legacy method to retrieve a list of all the elements inside an
 *         intbitset.
 */

static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_tolist(PyObject *__pyx_v_self, PyObject *unused); /*proto*/
static char __pyx_doc_3lib_9intbitset_9intbitset_tolist[] = "Legacy method to retrieve a list of all the elements inside an\n        intbitset.\n        ";
static PyObject *__pyx_pf_3lib_9intbitset_9intbitset_tolist(PyObject *__pyx_v_self, PyObject *unused) {
  PyObject *__pyx_r = NULL;
  word_t __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  __Pyx_SetupRefcountContext("tolist");

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":737
 *         intbitset.
 *         """
 *         if self.bitset.trailing_bits:             # <<<<<<<<<<<<<<
 *             raise OverflowError("It's impossible to retrieve a list of an infinite set")
 *         return self.extract_finite_list()
 */
  __pyx_t_1 = ((struct __pyx_obj_3lib_9intbitset_intbitset *)__pyx_v_self)->bitset->trailing_bits;
  if (__pyx_t_1) {

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":738
 *         """
 *         if self.bitset.trailing_bits:
 *             raise OverflowError("It's impossible to retrieve a list of an infinite set")             # <<<<<<<<<<<<<<
 *         return self.extract_finite_list()
 * 
 */
    __pyx_t_2 = PyTuple_New(1); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 738; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(((PyObject *)__pyx_t_2));
    __Pyx_INCREF(__pyx_kp_77);
    PyTuple_SET_ITEM(__pyx_t_2, 0, __pyx_kp_77);
    __Pyx_GIVEREF(__pyx_kp_77);
    __pyx_t_3 = PyObject_Call(__pyx_builtin_OverflowError, ((PyObject *)__pyx_t_2), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 738; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(((PyObject *)__pyx_t_2)); __pyx_t_2 = 0;
    __Pyx_Raise(__pyx_t_3, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 738; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":739
 *         if self.bitset.trailing_bits:
 *             raise OverflowError("It's impossible to retrieve a list of an infinite set")
 *         return self.extract_finite_list()             # <<<<<<<<<<<<<<
 * 
 * cdef class intbitset_iterator:
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_3 = PyObject_GetAttr(__pyx_v_self, __pyx_kp_extract_finite_list); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 739; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_t_2 = PyObject_Call(__pyx_t_3, ((PyObject *)__pyx_empty_tuple), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 739; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_2);
  __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
  __pyx_r = __pyx_t_2;
  __pyx_t_2 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_AddTraceback("lib.intbitset.intbitset.tolist");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_FinishRefcountContext();
  return __pyx_r;
}

/* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":746
 *     cdef bint sanity_checks
 * 
 *     def __cinit__(self, intbitset bitset not None):             # <<<<<<<<<<<<<<
 *         self.last = -1
 *         ## A copy should be performed, in case the original bitset disappears
 */

static int __pyx_pf_3lib_9intbitset_18intbitset_iterator___cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds); /*proto*/
static int __pyx_pf_3lib_9intbitset_18intbitset_iterator___cinit__(PyObject *__pyx_v_self, PyObject *__pyx_args, PyObject *__pyx_kwds) {
  struct __pyx_obj_3lib_9intbitset_intbitset *__pyx_v_bitset = 0;
  int __pyx_r;
  PyObject *__pyx_1 = 0;
  int __pyx_t_1;
  static PyObject **__pyx_pyargnames[] = {&__pyx_kp_bitset,0};
  __Pyx_SetupRefcountContext("__cinit__");
  if (unlikely(__pyx_kwds)) {
    Py_ssize_t kw_args = PyDict_Size(__pyx_kwds);
    PyObject* values[1] = {0};
    switch (PyTuple_GET_SIZE(__pyx_args)) {
      case  1: values[0] = PyTuple_GET_ITEM(__pyx_args, 0);
      case  0: break;
      default: goto __pyx_L5_argtuple_error;
    }
    switch (PyTuple_GET_SIZE(__pyx_args)) {
      case  0:
      values[0] = PyDict_GetItem(__pyx_kwds, __pyx_kp_bitset);
      if (likely(values[0])) kw_args--;
      else goto __pyx_L5_argtuple_error;
    }
    if (unlikely(kw_args > 0)) {
      if (unlikely(__Pyx_ParseOptionalKeywords(__pyx_kwds, __pyx_pyargnames, 0, values, PyTuple_GET_SIZE(__pyx_args), "__cinit__") < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 746; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
    }
    __pyx_v_bitset = ((struct __pyx_obj_3lib_9intbitset_intbitset *)values[0]);
  } else if (PyTuple_GET_SIZE(__pyx_args) != 1) {
    goto __pyx_L5_argtuple_error;
  } else {
    __pyx_v_bitset = ((struct __pyx_obj_3lib_9intbitset_intbitset *)PyTuple_GET_ITEM(__pyx_args, 0));
  }
  goto __pyx_L4_argument_unpacking_done;
  __pyx_L5_argtuple_error:;
  __Pyx_RaiseArgtupleInvalid("__cinit__", 1, 1, 1, PyTuple_GET_SIZE(__pyx_args)); {__pyx_filename = __pyx_f[0]; __pyx_lineno = 746; __pyx_clineno = __LINE__; goto __pyx_L3_error;}
  __pyx_L3_error:;
  __Pyx_AddTraceback("lib.intbitset.intbitset_iterator.__cinit__");
  return -1;
  __pyx_L4_argument_unpacking_done:;
  if (unlikely(!__Pyx_ArgTypeTest(((PyObject *)__pyx_v_bitset), __pyx_ptype_3lib_9intbitset_intbitset, 0, "bitset", 0))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 746; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":747
 * 
 *     def __cinit__(self, intbitset bitset not None):
 *         self.last = -1             # <<<<<<<<<<<<<<
 *         ## A copy should be performed, in case the original bitset disappears
 *         ## as in "for x in intbitset([1,2,3])"!
 */
  ((struct __pyx_obj_3lib_9intbitset_intbitset_iterator *)__pyx_v_self)->last = -1;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":750
 *         ## A copy should be performed, in case the original bitset disappears
 *         ## as in "for x in intbitset([1,2,3])"!
 *         self.bitset = intBitSetClone(bitset.bitset)             # <<<<<<<<<<<<<<
 *         self.sanity_checks = CFG_INTBITSET_ENABLE_SANITY_CHECKS
 * 
 */
  ((struct __pyx_obj_3lib_9intbitset_intbitset_iterator *)__pyx_v_self)->bitset = intBitSetClone(__pyx_v_bitset->bitset);

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":751
 *         ## as in "for x in intbitset([1,2,3])"!
 *         self.bitset = intBitSetClone(bitset.bitset)
 *         self.sanity_checks = CFG_INTBITSET_ENABLE_SANITY_CHECKS             # <<<<<<<<<<<<<<
 * 
 *     def __dealloc__(self):
 */
  __pyx_1 = __Pyx_GetName(__pyx_m, __pyx_kp_5); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 751; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_1);
  __pyx_t_1 = __Pyx_PyObject_IsTrue(__pyx_1); if (unlikely((__pyx_t_1 == (int)-1))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 751; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
  ((struct __pyx_obj_3lib_9intbitset_intbitset_iterator *)__pyx_v_self)->sanity_checks = __pyx_t_1;

  __pyx_r = 0;
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_1);
  __Pyx_AddTraceback("lib.intbitset.intbitset_iterator.__cinit__");
  __pyx_r = -1;
  __pyx_L0:;
  __Pyx_FinishRefcountContext();
  return __pyx_r;
}

/* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":753
 *         self.sanity_checks = CFG_INTBITSET_ENABLE_SANITY_CHECKS
 * 
 *     def __dealloc__(self):             # <<<<<<<<<<<<<<
 *         if self.bitset:
 *             intBitSetDestroy(self.bitset)
 */

static void __pyx_pf_3lib_9intbitset_18intbitset_iterator___dealloc__(PyObject *__pyx_v_self); /*proto*/
static void __pyx_pf_3lib_9intbitset_18intbitset_iterator___dealloc__(PyObject *__pyx_v_self) {
  int __pyx_t_1;
  __Pyx_SetupRefcountContext("__dealloc__");

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":754
 * 
 *     def __dealloc__(self):
 *         if self.bitset:             # <<<<<<<<<<<<<<
 *             intBitSetDestroy(self.bitset)
 * 
 */
  __pyx_t_1 = (((struct __pyx_obj_3lib_9intbitset_intbitset_iterator *)__pyx_v_self)->bitset != 0);
  if (__pyx_t_1) {

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":755
 *     def __dealloc__(self):
 *         if self.bitset:
 *             intBitSetDestroy(self.bitset)             # <<<<<<<<<<<<<<
 * 
 *     def __next__(self):
 */
    intBitSetDestroy(((struct __pyx_obj_3lib_9intbitset_intbitset_iterator *)__pyx_v_self)->bitset);
    goto __pyx_L5;
  }
  __pyx_L5:;

  __Pyx_FinishRefcountContext();
}

/* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":757
 *             intBitSetDestroy(self.bitset)
 * 
 *     def __next__(self):             # <<<<<<<<<<<<<<
 *         if self.last == -2:
 *             raise StopIteration()
 */

static PyObject *__pyx_pf_3lib_9intbitset_18intbitset_iterator___next__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pf_3lib_9intbitset_18intbitset_iterator___next__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  int __pyx_t_1;
  PyObject *__pyx_t_2 = NULL;
  PyObject *__pyx_t_3 = NULL;
  PyObject *__pyx_t_4 = NULL;
  __Pyx_SetupRefcountContext("__next__");

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":758
 * 
 *     def __next__(self):
 *         if self.last == -2:             # <<<<<<<<<<<<<<
 *             raise StopIteration()
 *         self.last = intBitSetGetNext(self.bitset, self.last)
 */
  __pyx_t_1 = (((struct __pyx_obj_3lib_9intbitset_intbitset_iterator *)__pyx_v_self)->last == -2);
  if (__pyx_t_1) {

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":759
 *     def __next__(self):
 *         if self.last == -2:
 *             raise StopIteration()             # <<<<<<<<<<<<<<
 *         self.last = intBitSetGetNext(self.bitset, self.last)
 *         if self.sanity_checks and (self.bitset.allocated < self.bitset.size):
 */
    __pyx_t_2 = PyObject_Call(__pyx_builtin_StopIteration, ((PyObject *)__pyx_empty_tuple), NULL); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 759; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __Pyx_Raise(__pyx_t_2, 0, 0);
    __Pyx_DECREF(__pyx_t_2); __pyx_t_2 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 759; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    goto __pyx_L5;
  }
  __pyx_L5:;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":760
 *         if self.last == -2:
 *             raise StopIteration()
 *         self.last = intBitSetGetNext(self.bitset, self.last)             # <<<<<<<<<<<<<<
 *         if self.sanity_checks and (self.bitset.allocated < self.bitset.size):
 *             raise MemoryError("intbitset corrupted: allocated: %s, size: %s" % (self.bitset.allocated, self.bitset.size))
 */
  ((struct __pyx_obj_3lib_9intbitset_intbitset_iterator *)__pyx_v_self)->last = intBitSetGetNext(((struct __pyx_obj_3lib_9intbitset_intbitset_iterator *)__pyx_v_self)->bitset, ((struct __pyx_obj_3lib_9intbitset_intbitset_iterator *)__pyx_v_self)->last);

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":761
 *             raise StopIteration()
 *         self.last = intBitSetGetNext(self.bitset, self.last)
 *         if self.sanity_checks and (self.bitset.allocated < self.bitset.size):             # <<<<<<<<<<<<<<
 *             raise MemoryError("intbitset corrupted: allocated: %s, size: %s" % (self.bitset.allocated, self.bitset.size))
 *         if self.last < 0:
 */
  if (((struct __pyx_obj_3lib_9intbitset_intbitset_iterator *)__pyx_v_self)->sanity_checks) {
    __pyx_t_1 = (((struct __pyx_obj_3lib_9intbitset_intbitset_iterator *)__pyx_v_self)->bitset->allocated < ((struct __pyx_obj_3lib_9intbitset_intbitset_iterator *)__pyx_v_self)->bitset->size);
  } else {
    __pyx_t_1 = ((struct __pyx_obj_3lib_9intbitset_intbitset_iterator *)__pyx_v_self)->sanity_checks;
  }
  if (__pyx_t_1) {

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":762
 *         self.last = intBitSetGetNext(self.bitset, self.last)
 *         if self.sanity_checks and (self.bitset.allocated < self.bitset.size):
 *             raise MemoryError("intbitset corrupted: allocated: %s, size: %s" % (self.bitset.allocated, self.bitset.size))             # <<<<<<<<<<<<<<
 *         if self.last < 0:
 *             self.last = -2
 */
    __pyx_t_2 = PyInt_FromLong(((struct __pyx_obj_3lib_9intbitset_intbitset_iterator *)__pyx_v_self)->bitset->allocated); if (unlikely(!__pyx_t_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 762; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_2);
    __pyx_t_3 = PyInt_FromLong(((struct __pyx_obj_3lib_9intbitset_intbitset_iterator *)__pyx_v_self)->bitset->size); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 762; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __pyx_t_4 = PyTuple_New(2); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 762; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(((PyObject *)__pyx_t_4));
    PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_2);
    __Pyx_GIVEREF(__pyx_t_2);
    PyTuple_SET_ITEM(__pyx_t_4, 1, __pyx_t_3);
    __Pyx_GIVEREF(__pyx_t_3);
    __pyx_t_2 = 0;
    __pyx_t_3 = 0;
    __pyx_t_3 = PyNumber_Remainder(__pyx_kp_78, ((PyObject *)__pyx_t_4)); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 762; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(((PyObject *)__pyx_t_4)); __pyx_t_4 = 0;
    __pyx_t_4 = PyTuple_New(1); if (unlikely(!__pyx_t_4)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 762; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(((PyObject *)__pyx_t_4));
    PyTuple_SET_ITEM(__pyx_t_4, 0, __pyx_t_3);
    __Pyx_GIVEREF(__pyx_t_3);
    __pyx_t_3 = 0;
    __pyx_t_3 = PyObject_Call(__pyx_builtin_MemoryError, ((PyObject *)__pyx_t_4), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 762; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_DECREF(((PyObject *)__pyx_t_4)); __pyx_t_4 = 0;
    __Pyx_Raise(__pyx_t_3, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 762; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    goto __pyx_L6;
  }
  __pyx_L6:;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":763
 *         if self.sanity_checks and (self.bitset.allocated < self.bitset.size):
 *             raise MemoryError("intbitset corrupted: allocated: %s, size: %s" % (self.bitset.allocated, self.bitset.size))
 *         if self.last < 0:             # <<<<<<<<<<<<<<
 *             self.last = -2
 *             raise StopIteration()
 */
  __pyx_t_1 = (((struct __pyx_obj_3lib_9intbitset_intbitset_iterator *)__pyx_v_self)->last < 0);
  if (__pyx_t_1) {

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":764
 *             raise MemoryError("intbitset corrupted: allocated: %s, size: %s" % (self.bitset.allocated, self.bitset.size))
 *         if self.last < 0:
 *             self.last = -2             # <<<<<<<<<<<<<<
 *             raise StopIteration()
 *         return self.last
 */
    ((struct __pyx_obj_3lib_9intbitset_intbitset_iterator *)__pyx_v_self)->last = -2;

    /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":765
 *         if self.last < 0:
 *             self.last = -2
 *             raise StopIteration()             # <<<<<<<<<<<<<<
 *         return self.last
 * 
 */
    __pyx_t_3 = PyObject_Call(__pyx_builtin_StopIteration, ((PyObject *)__pyx_empty_tuple), NULL); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 765; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    __Pyx_GOTREF(__pyx_t_3);
    __Pyx_Raise(__pyx_t_3, 0, 0);
    __Pyx_DECREF(__pyx_t_3); __pyx_t_3 = 0;
    {__pyx_filename = __pyx_f[0]; __pyx_lineno = 765; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
    goto __pyx_L7;
  }
  __pyx_L7:;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":766
 *             self.last = -2
 *             raise StopIteration()
 *         return self.last             # <<<<<<<<<<<<<<
 * 
 *     def __iter__(self):
 */
  __Pyx_XDECREF(__pyx_r);
  __pyx_t_3 = PyInt_FromLong(((struct __pyx_obj_3lib_9intbitset_intbitset_iterator *)__pyx_v_self)->last); if (unlikely(!__pyx_t_3)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 766; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_3);
  __pyx_r = __pyx_t_3;
  __pyx_t_3 = 0;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_t_2);
  __Pyx_XDECREF(__pyx_t_3);
  __Pyx_XDECREF(__pyx_t_4);
  __Pyx_AddTraceback("lib.intbitset.intbitset_iterator.__next__");
  __pyx_r = NULL;
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_FinishRefcountContext();
  return __pyx_r;
}

/* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":768
 *         return self.last
 * 
 *     def __iter__(self):             # <<<<<<<<<<<<<<
 *         return self
 */

static PyObject *__pyx_pf_3lib_9intbitset_18intbitset_iterator___iter__(PyObject *__pyx_v_self); /*proto*/
static PyObject *__pyx_pf_3lib_9intbitset_18intbitset_iterator___iter__(PyObject *__pyx_v_self) {
  PyObject *__pyx_r = NULL;
  __Pyx_SetupRefcountContext("__iter__");

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":769
 * 
 *     def __iter__(self):
 *         return self             # <<<<<<<<<<<<<<
 */
  __Pyx_XDECREF(__pyx_r);
  __Pyx_INCREF(__pyx_v_self);
  __pyx_r = __pyx_v_self;
  goto __pyx_L0;

  __pyx_r = Py_None; __Pyx_INCREF(Py_None);
  __pyx_L0:;
  __Pyx_XGIVEREF(__pyx_r);
  __Pyx_FinishRefcountContext();
  return __pyx_r;
}

static PyObject *__pyx_tp_new_3lib_9intbitset_intbitset(PyTypeObject *t, PyObject *a, PyObject *k) {
  PyObject *o = (*t->tp_alloc)(t, 0);
  if (!o) return 0;
  if (__pyx_pf_3lib_9intbitset_9intbitset___cinit__(o, a, k) < 0) {
    Py_DECREF(o); o = 0;
  }
  return o;
}

static void __pyx_tp_dealloc_3lib_9intbitset_intbitset(PyObject *o) {
  {
    PyObject *etype, *eval, *etb;
    PyErr_Fetch(&etype, &eval, &etb);
    ++Py_REFCNT(o);
    __pyx_pf_3lib_9intbitset_9intbitset___dealloc__(o);
    if (PyErr_Occurred()) PyErr_WriteUnraisable(o);
    --Py_REFCNT(o);
    PyErr_Restore(etype, eval, etb);
  }
  (*Py_TYPE(o)->tp_free)(o);
}

static struct PyMethodDef __pyx_methods_3lib_9intbitset_intbitset[] = {
  {__Pyx_NAMESTR("__iadd__"), (PyCFunction)__pyx_pf_3lib_9intbitset_9intbitset___iadd__, METH_O|METH_COEXIST, __Pyx_DOCSTR(0)},
  {__Pyx_NAMESTR("__isub__"), (PyCFunction)__pyx_pf_3lib_9intbitset_9intbitset___isub__, METH_O|METH_COEXIST, __Pyx_DOCSTR(0)},
  {__Pyx_NAMESTR("__deepcopy__"), (PyCFunction)__pyx_pf_3lib_9intbitset_9intbitset___deepcopy__, METH_O, __Pyx_DOCSTR(0)},
  {__Pyx_NAMESTR("__del__"), (PyCFunction)__pyx_pf_3lib_9intbitset_9intbitset___del__, METH_O, __Pyx_DOCSTR(0)},
  {__Pyx_NAMESTR("__and__"), (PyCFunction)__pyx_pf_3lib_9intbitset_9intbitset___and__, METH_O|METH_COEXIST, __Pyx_DOCSTR(0)},
  {__Pyx_NAMESTR("__or__"), (PyCFunction)__pyx_pf_3lib_9intbitset_9intbitset___or__, METH_O|METH_COEXIST, __Pyx_DOCSTR(0)},
  {__Pyx_NAMESTR("__xor__"), (PyCFunction)__pyx_pf_3lib_9intbitset_9intbitset___xor__, METH_O|METH_COEXIST, __Pyx_DOCSTR(0)},
  {__Pyx_NAMESTR("__sub__"), (PyCFunction)__pyx_pf_3lib_9intbitset_9intbitset___sub__, METH_O|METH_COEXIST, __Pyx_DOCSTR(0)},
  {__Pyx_NAMESTR("__iand__"), (PyCFunction)__pyx_pf_3lib_9intbitset_9intbitset___iand__, METH_O|METH_COEXIST, __Pyx_DOCSTR(0)},
  {__Pyx_NAMESTR("__ior__"), (PyCFunction)__pyx_pf_3lib_9intbitset_9intbitset___ior__, METH_O|METH_COEXIST, __Pyx_DOCSTR(0)},
  {__Pyx_NAMESTR("__ixor__"), (PyCFunction)__pyx_pf_3lib_9intbitset_9intbitset___ixor__, METH_O|METH_COEXIST, __Pyx_DOCSTR(0)},
  {__Pyx_NAMESTR("__repr__"), (PyCFunction)__pyx_pf_3lib_9intbitset_9intbitset___repr__, METH_NOARGS|METH_COEXIST, __Pyx_DOCSTR(0)},
  {__Pyx_NAMESTR("__str__"), (PyCFunction)__pyx_pf_3lib_9intbitset_9intbitset___str__, METH_NOARGS|METH_COEXIST, __Pyx_DOCSTR(0)},
  {__Pyx_NAMESTR("__iter__"), (PyCFunction)__pyx_pf_3lib_9intbitset_9intbitset___iter__, METH_NOARGS|METH_COEXIST, __Pyx_DOCSTR(0)},
  {__Pyx_NAMESTR("add"), (PyCFunction)__pyx_pf_3lib_9intbitset_9intbitset_add, METH_O, __Pyx_DOCSTR(__pyx_doc_3lib_9intbitset_9intbitset_add)},
  {__Pyx_NAMESTR("clear"), (PyCFunction)__pyx_pf_3lib_9intbitset_9intbitset_clear, METH_NOARGS, __Pyx_DOCSTR(0)},
  {__Pyx_NAMESTR("difference"), (PyCFunction)__pyx_pf_3lib_9intbitset_9intbitset_difference, METH_O, __Pyx_DOCSTR(__pyx_doc_3lib_9intbitset_9intbitset_difference)},
  {__Pyx_NAMESTR("difference_update"), (PyCFunction)__pyx_pf_3lib_9intbitset_9intbitset_difference_update, METH_O, __Pyx_DOCSTR(__pyx_doc_3lib_9intbitset_9intbitset_difference_update)},
  {__Pyx_NAMESTR("discard"), (PyCFunction)__pyx_pf_3lib_9intbitset_9intbitset_discard, METH_O, __Pyx_DOCSTR(__pyx_doc_3lib_9intbitset_9intbitset_discard)},
  {__Pyx_NAMESTR("intersection"), (PyCFunction)__pyx_pf_3lib_9intbitset_9intbitset_intersection, METH_O, __Pyx_DOCSTR(__pyx_doc_3lib_9intbitset_9intbitset_intersection)},
  {__Pyx_NAMESTR("intersection_update"), (PyCFunction)__pyx_pf_3lib_9intbitset_9intbitset_intersection_update, METH_O, __Pyx_DOCSTR(__pyx_doc_3lib_9intbitset_9intbitset_intersection_update)},
  {__Pyx_NAMESTR("union"), (PyCFunction)__pyx_pf_3lib_9intbitset_9intbitset_union, METH_O, __Pyx_DOCSTR(__pyx_doc_3lib_9intbitset_9intbitset_union)},
  {__Pyx_NAMESTR("union_update"), (PyCFunction)__pyx_pf_3lib_9intbitset_9intbitset_union_update, METH_O, __Pyx_DOCSTR(__pyx_doc_3lib_9intbitset_9intbitset_union_update)},
  {__Pyx_NAMESTR("issubset"), (PyCFunction)__pyx_pf_3lib_9intbitset_9intbitset_issubset, METH_O, __Pyx_DOCSTR(__pyx_doc_3lib_9intbitset_9intbitset_issubset)},
  {__Pyx_NAMESTR("issuperset"), (PyCFunction)__pyx_pf_3lib_9intbitset_9intbitset_issuperset, METH_O, __Pyx_DOCSTR(__pyx_doc_3lib_9intbitset_9intbitset_issuperset)},
  {__Pyx_NAMESTR("symmetric_difference"), (PyCFunction)__pyx_pf_3lib_9intbitset_9intbitset_symmetric_difference, METH_O, __Pyx_DOCSTR(__pyx_doc_3lib_9intbitset_9intbitset_symmetric_difference)},
  {__Pyx_NAMESTR("symmetric_difference_update"), (PyCFunction)__pyx_pf_3lib_9intbitset_9intbitset_symmetric_difference_update, METH_O, __Pyx_DOCSTR(__pyx_doc_3lib_9intbitset_9intbitset_symmetric_difference_update)},
  {__Pyx_NAMESTR("fastdump"), (PyCFunction)__pyx_pf_3lib_9intbitset_9intbitset_fastdump, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_3lib_9intbitset_9intbitset_fastdump)},
  {__Pyx_NAMESTR("fastload"), (PyCFunction)__pyx_pf_3lib_9intbitset_9intbitset_fastload, METH_O, __Pyx_DOCSTR(__pyx_doc_3lib_9intbitset_9intbitset_fastload)},
  {__Pyx_NAMESTR("copy"), (PyCFunction)__pyx_pf_3lib_9intbitset_9intbitset_copy, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_3lib_9intbitset_9intbitset_copy)},
  {__Pyx_NAMESTR("pop"), (PyCFunction)__pyx_pf_3lib_9intbitset_9intbitset_pop, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_3lib_9intbitset_9intbitset_pop)},
  {__Pyx_NAMESTR("remove"), (PyCFunction)__pyx_pf_3lib_9intbitset_9intbitset_remove, METH_O, __Pyx_DOCSTR(__pyx_doc_3lib_9intbitset_9intbitset_remove)},
  {__Pyx_NAMESTR("strbits"), (PyCFunction)__pyx_pf_3lib_9intbitset_9intbitset_strbits, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_3lib_9intbitset_9intbitset_strbits)},
  {__Pyx_NAMESTR("update_with_signs"), (PyCFunction)__pyx_pf_3lib_9intbitset_9intbitset_update_with_signs, METH_O, __Pyx_DOCSTR(__pyx_doc_3lib_9intbitset_9intbitset_update_with_signs)},
  {__Pyx_NAMESTR("get_size"), (PyCFunction)__pyx_pf_3lib_9intbitset_9intbitset_get_size, METH_NOARGS, __Pyx_DOCSTR(0)},
  {__Pyx_NAMESTR("get_allocated"), (PyCFunction)__pyx_pf_3lib_9intbitset_9intbitset_get_allocated, METH_NOARGS, __Pyx_DOCSTR(0)},
  {__Pyx_NAMESTR("get_sorted_element"), (PyCFunction)__pyx_pf_3lib_9intbitset_9intbitset_get_sorted_element, METH_O, __Pyx_DOCSTR(__pyx_doc_3lib_9intbitset_9intbitset_get_sorted_element)},
  {__Pyx_NAMESTR("to_sorted_list"), (PyCFunction)__pyx_pf_3lib_9intbitset_9intbitset_to_sorted_list, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_3lib_9intbitset_9intbitset_to_sorted_list)},
  {__Pyx_NAMESTR("is_infinite"), (PyCFunction)__pyx_pf_3lib_9intbitset_9intbitset_is_infinite, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_3lib_9intbitset_9intbitset_is_infinite)},
  {__Pyx_NAMESTR("extract_finite_list"), (PyCFunction)__pyx_pf_3lib_9intbitset_9intbitset_extract_finite_list, METH_VARARGS|METH_KEYWORDS, __Pyx_DOCSTR(__pyx_doc_3lib_9intbitset_9intbitset_extract_finite_list)},
  {__Pyx_NAMESTR("get_wordbitsize"), (PyCFunction)__pyx_pf_3lib_9intbitset_9intbitset_get_wordbitsize, METH_NOARGS, __Pyx_DOCSTR(0)},
  {__Pyx_NAMESTR("get_wordbytsize"), (PyCFunction)__pyx_pf_3lib_9intbitset_9intbitset_get_wordbytsize, METH_NOARGS, __Pyx_DOCSTR(0)},
  {__Pyx_NAMESTR("tolist"), (PyCFunction)__pyx_pf_3lib_9intbitset_9intbitset_tolist, METH_NOARGS, __Pyx_DOCSTR(__pyx_doc_3lib_9intbitset_9intbitset_tolist)},
  {0, 0, 0, 0}
};

static PyNumberMethods __pyx_tp_as_number_intbitset = {
  0, /*nb_add*/
  __pyx_pf_3lib_9intbitset_9intbitset___sub__, /*nb_subtract*/
  0, /*nb_multiply*/
  #if PY_MAJOR_VERSION < 3
  0, /*nb_divide*/
  #endif
  0, /*nb_remainder*/
  0, /*nb_divmod*/
  0, /*nb_power*/
  0, /*nb_negative*/
  0, /*nb_positive*/
  0, /*nb_absolute*/
  __pyx_pf_3lib_9intbitset_9intbitset___nonzero__, /*nb_nonzero*/
  0, /*nb_invert*/
  0, /*nb_lshift*/
  0, /*nb_rshift*/
  __pyx_pf_3lib_9intbitset_9intbitset___and__, /*nb_and*/
  __pyx_pf_3lib_9intbitset_9intbitset___xor__, /*nb_xor*/
  __pyx_pf_3lib_9intbitset_9intbitset___or__, /*nb_or*/
  #if PY_MAJOR_VERSION < 3
  0, /*nb_coerce*/
  #endif
  0, /*nb_int*/
  #if PY_MAJOR_VERSION >= 3
  0, /*reserved*/
  #else
  0, /*nb_long*/
  #endif
  0, /*nb_float*/
  #if PY_MAJOR_VERSION < 3
  0, /*nb_oct*/
  #endif
  #if PY_MAJOR_VERSION < 3
  0, /*nb_hex*/
  #endif
  __pyx_pf_3lib_9intbitset_9intbitset___iadd__, /*nb_inplace_add*/
  __pyx_pf_3lib_9intbitset_9intbitset___isub__, /*nb_inplace_subtract*/
  0, /*nb_inplace_multiply*/
  #if PY_MAJOR_VERSION < 3
  0, /*nb_inplace_divide*/
  #endif
  0, /*nb_inplace_remainder*/
  0, /*nb_inplace_power*/
  0, /*nb_inplace_lshift*/
  0, /*nb_inplace_rshift*/
  __pyx_pf_3lib_9intbitset_9intbitset___iand__, /*nb_inplace_and*/
  __pyx_pf_3lib_9intbitset_9intbitset___ixor__, /*nb_inplace_xor*/
  __pyx_pf_3lib_9intbitset_9intbitset___ior__, /*nb_inplace_or*/
  0, /*nb_floor_divide*/
  0, /*nb_true_divide*/
  0, /*nb_inplace_floor_divide*/
  0, /*nb_inplace_true_divide*/
  #if (PY_MAJOR_VERSION >= 3) || (Py_TPFLAGS_DEFAULT & Py_TPFLAGS_HAVE_INDEX)
  0, /*nb_index*/
  #endif
};

static PySequenceMethods __pyx_tp_as_sequence_intbitset = {
  __pyx_pf_3lib_9intbitset_9intbitset___len__, /*sq_length*/
  0, /*sq_concat*/
  0, /*sq_repeat*/
  0, /*sq_item*/
  0, /*sq_slice*/
  0, /*sq_ass_item*/
  0, /*sq_ass_slice*/
  __pyx_pf_3lib_9intbitset_9intbitset___contains__, /*sq_contains*/
  0, /*sq_inplace_concat*/
  0, /*sq_inplace_repeat*/
};

static PyMappingMethods __pyx_tp_as_mapping_intbitset = {
  __pyx_pf_3lib_9intbitset_9intbitset___len__, /*mp_length*/
  0, /*mp_subscript*/
  0, /*mp_ass_subscript*/
};

static PyBufferProcs __pyx_tp_as_buffer_intbitset = {
  #if PY_MAJOR_VERSION < 3
  0, /*bf_getreadbuffer*/
  #endif
  #if PY_MAJOR_VERSION < 3
  0, /*bf_getwritebuffer*/
  #endif
  #if PY_MAJOR_VERSION < 3
  0, /*bf_getsegcount*/
  #endif
  #if PY_MAJOR_VERSION < 3
  0, /*bf_getcharbuffer*/
  #endif
  #if PY_VERSION_HEX >= 0x02060000
  0, /*bf_getbuffer*/
  #endif
  #if PY_VERSION_HEX >= 0x02060000
  0, /*bf_releasebuffer*/
  #endif
};

PyTypeObject __pyx_type_3lib_9intbitset_intbitset = {
  PyVarObject_HEAD_INIT(0, 0)
  __Pyx_NAMESTR("lib.intbitset.intbitset"), /*tp_name*/
  sizeof(struct __pyx_obj_3lib_9intbitset_intbitset), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_3lib_9intbitset_intbitset, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  __pyx_pf_3lib_9intbitset_9intbitset___cmp__, /*tp_compare*/
  __pyx_pf_3lib_9intbitset_9intbitset___repr__, /*tp_repr*/
  &__pyx_tp_as_number_intbitset, /*tp_as_number*/
  &__pyx_tp_as_sequence_intbitset, /*tp_as_sequence*/
  &__pyx_tp_as_mapping_intbitset, /*tp_as_mapping*/
  __pyx_pf_3lib_9intbitset_9intbitset___hash__, /*tp_hash*/
  0, /*tp_call*/
  __pyx_pf_3lib_9intbitset_9intbitset___str__, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  &__pyx_tp_as_buffer_intbitset, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_NEWBUFFER, /*tp_flags*/
  __Pyx_DOCSTR("\n    Defines an intbitset data object to hold unordered sets of\n    unsigned integers with ultra fast set operations, implemented via\n    bit vectors and Python C extension to optimize speed and memory\n    usage.\n\n    Emulates the Python built-in set class interface with some\n    additional specific methods such as its own fast dump and load\n    marshalling functions.  Uses real bits to optimize memory usage,\n    so may have issues with endianness if you transport serialized\n    bitsets between various machine architectures.\n\n    The constructor accept the following parameters:\n        rhs=0, int preallocate=-1, int trailing_bits=0,\n        bint sanity_checks=CFG_INTBITSET_ENABLE_SANITY_CHECKS,\n        int no_allocate=0:\n\n    where:\n        * rhs can be:\n            - int/long for creating allocating empty intbitset that will hold at least\n            rhs elements, before being resized\n            - intbitset for cloning\n            - str for retrieving an intbitset that was dumped into a string\n            - array for retrieving an intbitset that was dumped into a string stored\n            in an array\n            - sequence made of integers for copying all the elements from the\n            sequence. If minsize is specified than it is initially allocated\n            enough space to hold up to minsize integers, otherwise the biggest\n            element of the sequence will be used.\n            - sequence made of tuples: then the first element of each tuple\n            is considered as an integer (as in the sequence made of integers).\n        * preallocate is a suggested initial upper bound on the numbers that will be\n            stored, by looking at rhs a sequence of number.\n        * trailing_bits is 1, then the set will contain \"all\" the positive integers\n        * no_allocate is used internally and should never be set.\n        after the biggest one added with rhs.\n    "), /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  __pyx_pf_3lib_9intbitset_9intbitset___richcmp__, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  __pyx_pf_3lib_9intbitset_9intbitset___iter__, /*tp_iter*/
  0, /*tp_iternext*/
  __pyx_methods_3lib_9intbitset_intbitset, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_3lib_9intbitset_intbitset, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
};

static PyObject *__pyx_tp_new_3lib_9intbitset_intbitset_iterator(PyTypeObject *t, PyObject *a, PyObject *k) {
  PyObject *o = (*t->tp_alloc)(t, 0);
  if (!o) return 0;
  if (__pyx_pf_3lib_9intbitset_18intbitset_iterator___cinit__(o, a, k) < 0) {
    Py_DECREF(o); o = 0;
  }
  return o;
}

static void __pyx_tp_dealloc_3lib_9intbitset_intbitset_iterator(PyObject *o) {
  {
    PyObject *etype, *eval, *etb;
    PyErr_Fetch(&etype, &eval, &etb);
    ++Py_REFCNT(o);
    __pyx_pf_3lib_9intbitset_18intbitset_iterator___dealloc__(o);
    if (PyErr_Occurred()) PyErr_WriteUnraisable(o);
    --Py_REFCNT(o);
    PyErr_Restore(etype, eval, etb);
  }
  (*Py_TYPE(o)->tp_free)(o);
}

static struct PyMethodDef __pyx_methods_3lib_9intbitset_intbitset_iterator[] = {
  {__Pyx_NAMESTR("__next__"), (PyCFunction)__pyx_pf_3lib_9intbitset_18intbitset_iterator___next__, METH_NOARGS|METH_COEXIST, __Pyx_DOCSTR(0)},
  {__Pyx_NAMESTR("__iter__"), (PyCFunction)__pyx_pf_3lib_9intbitset_18intbitset_iterator___iter__, METH_NOARGS|METH_COEXIST, __Pyx_DOCSTR(0)},
  {0, 0, 0, 0}
};

static PyNumberMethods __pyx_tp_as_number_intbitset_iterator = {
  0, /*nb_add*/
  0, /*nb_subtract*/
  0, /*nb_multiply*/
  #if PY_MAJOR_VERSION < 3
  0, /*nb_divide*/
  #endif
  0, /*nb_remainder*/
  0, /*nb_divmod*/
  0, /*nb_power*/
  0, /*nb_negative*/
  0, /*nb_positive*/
  0, /*nb_absolute*/
  0, /*nb_nonzero*/
  0, /*nb_invert*/
  0, /*nb_lshift*/
  0, /*nb_rshift*/
  0, /*nb_and*/
  0, /*nb_xor*/
  0, /*nb_or*/
  #if PY_MAJOR_VERSION < 3
  0, /*nb_coerce*/
  #endif
  0, /*nb_int*/
  #if PY_MAJOR_VERSION >= 3
  0, /*reserved*/
  #else
  0, /*nb_long*/
  #endif
  0, /*nb_float*/
  #if PY_MAJOR_VERSION < 3
  0, /*nb_oct*/
  #endif
  #if PY_MAJOR_VERSION < 3
  0, /*nb_hex*/
  #endif
  0, /*nb_inplace_add*/
  0, /*nb_inplace_subtract*/
  0, /*nb_inplace_multiply*/
  #if PY_MAJOR_VERSION < 3
  0, /*nb_inplace_divide*/
  #endif
  0, /*nb_inplace_remainder*/
  0, /*nb_inplace_power*/
  0, /*nb_inplace_lshift*/
  0, /*nb_inplace_rshift*/
  0, /*nb_inplace_and*/
  0, /*nb_inplace_xor*/
  0, /*nb_inplace_or*/
  0, /*nb_floor_divide*/
  0, /*nb_true_divide*/
  0, /*nb_inplace_floor_divide*/
  0, /*nb_inplace_true_divide*/
  #if (PY_MAJOR_VERSION >= 3) || (Py_TPFLAGS_DEFAULT & Py_TPFLAGS_HAVE_INDEX)
  0, /*nb_index*/
  #endif
};

static PySequenceMethods __pyx_tp_as_sequence_intbitset_iterator = {
  0, /*sq_length*/
  0, /*sq_concat*/
  0, /*sq_repeat*/
  0, /*sq_item*/
  0, /*sq_slice*/
  0, /*sq_ass_item*/
  0, /*sq_ass_slice*/
  0, /*sq_contains*/
  0, /*sq_inplace_concat*/
  0, /*sq_inplace_repeat*/
};

static PyMappingMethods __pyx_tp_as_mapping_intbitset_iterator = {
  0, /*mp_length*/
  0, /*mp_subscript*/
  0, /*mp_ass_subscript*/
};

static PyBufferProcs __pyx_tp_as_buffer_intbitset_iterator = {
  #if PY_MAJOR_VERSION < 3
  0, /*bf_getreadbuffer*/
  #endif
  #if PY_MAJOR_VERSION < 3
  0, /*bf_getwritebuffer*/
  #endif
  #if PY_MAJOR_VERSION < 3
  0, /*bf_getsegcount*/
  #endif
  #if PY_MAJOR_VERSION < 3
  0, /*bf_getcharbuffer*/
  #endif
  #if PY_VERSION_HEX >= 0x02060000
  0, /*bf_getbuffer*/
  #endif
  #if PY_VERSION_HEX >= 0x02060000
  0, /*bf_releasebuffer*/
  #endif
};

PyTypeObject __pyx_type_3lib_9intbitset_intbitset_iterator = {
  PyVarObject_HEAD_INIT(0, 0)
  __Pyx_NAMESTR("lib.intbitset.intbitset_iterator"), /*tp_name*/
  sizeof(struct __pyx_obj_3lib_9intbitset_intbitset_iterator), /*tp_basicsize*/
  0, /*tp_itemsize*/
  __pyx_tp_dealloc_3lib_9intbitset_intbitset_iterator, /*tp_dealloc*/
  0, /*tp_print*/
  0, /*tp_getattr*/
  0, /*tp_setattr*/
  0, /*tp_compare*/
  0, /*tp_repr*/
  &__pyx_tp_as_number_intbitset_iterator, /*tp_as_number*/
  &__pyx_tp_as_sequence_intbitset_iterator, /*tp_as_sequence*/
  &__pyx_tp_as_mapping_intbitset_iterator, /*tp_as_mapping*/
  0, /*tp_hash*/
  0, /*tp_call*/
  0, /*tp_str*/
  0, /*tp_getattro*/
  0, /*tp_setattro*/
  &__pyx_tp_as_buffer_intbitset_iterator, /*tp_as_buffer*/
  Py_TPFLAGS_DEFAULT|Py_TPFLAGS_CHECKTYPES|Py_TPFLAGS_BASETYPE|Py_TPFLAGS_HAVE_NEWBUFFER, /*tp_flags*/
  0, /*tp_doc*/
  0, /*tp_traverse*/
  0, /*tp_clear*/
  0, /*tp_richcompare*/
  0, /*tp_weaklistoffset*/
  __pyx_pf_3lib_9intbitset_18intbitset_iterator___iter__, /*tp_iter*/
  __pyx_pf_3lib_9intbitset_18intbitset_iterator___next__, /*tp_iternext*/
  __pyx_methods_3lib_9intbitset_intbitset_iterator, /*tp_methods*/
  0, /*tp_members*/
  0, /*tp_getset*/
  0, /*tp_base*/
  0, /*tp_dict*/
  0, /*tp_descr_get*/
  0, /*tp_descr_set*/
  0, /*tp_dictoffset*/
  0, /*tp_init*/
  0, /*tp_alloc*/
  __pyx_tp_new_3lib_9intbitset_intbitset_iterator, /*tp_new*/
  0, /*tp_free*/
  0, /*tp_is_gc*/
  0, /*tp_bases*/
  0, /*tp_mro*/
  0, /*tp_cache*/
  0, /*tp_subclasses*/
  0, /*tp_weaklist*/
};

static struct PyMethodDef __pyx_methods[] = {
  {0, 0, 0, 0}
};

static void __pyx_init_filenames(void); /*proto*/

#if PY_MAJOR_VERSION >= 3
static struct PyModuleDef __pyx_moduledef = {
    PyModuleDef_HEAD_INIT,
    __Pyx_NAMESTR("intbitset"),
    0, /* m_doc */
    -1, /* m_size */
    __pyx_methods /* m_methods */,
    NULL, /* m_reload */
    NULL, /* m_traverse */
    NULL, /* m_clear */
    NULL /* m_free */
};
#endif

static __Pyx_StringTabEntry __pyx_string_tab[] = {
  {&__pyx_kp___main__, __pyx_k___main__, sizeof(__pyx_k___main__), 1, 1, 1},
  {&__pyx_kp___cinit__, __pyx_k___cinit__, sizeof(__pyx_k___cinit__), 1, 1, 1},
  {&__pyx_kp___dealloc__, __pyx_k___dealloc__, sizeof(__pyx_k___dealloc__), 1, 1, 1},
  {&__pyx_kp___contains__, __pyx_k___contains__, sizeof(__pyx_k___contains__), 1, 1, 1},
  {&__pyx_kp___cmp__, __pyx_k___cmp__, sizeof(__pyx_k___cmp__), 1, 1, 1},
  {&__pyx_kp___richcmp__, __pyx_k___richcmp__, sizeof(__pyx_k___richcmp__), 1, 1, 1},
  {&__pyx_kp___len__, __pyx_k___len__, sizeof(__pyx_k___len__), 1, 1, 1},
  {&__pyx_kp___hash__, __pyx_k___hash__, sizeof(__pyx_k___hash__), 1, 1, 1},
  {&__pyx_kp___nonzero__, __pyx_k___nonzero__, sizeof(__pyx_k___nonzero__), 1, 1, 1},
  {&__pyx_kp___iadd__, __pyx_k___iadd__, sizeof(__pyx_k___iadd__), 1, 1, 1},
  {&__pyx_kp___isub__, __pyx_k___isub__, sizeof(__pyx_k___isub__), 1, 1, 1},
  {&__pyx_kp___deepcopy__, __pyx_k___deepcopy__, sizeof(__pyx_k___deepcopy__), 1, 1, 1},
  {&__pyx_kp___del__, __pyx_k___del__, sizeof(__pyx_k___del__), 1, 1, 1},
  {&__pyx_kp___and__, __pyx_k___and__, sizeof(__pyx_k___and__), 1, 1, 1},
  {&__pyx_kp___or__, __pyx_k___or__, sizeof(__pyx_k___or__), 1, 1, 1},
  {&__pyx_kp___xor__, __pyx_k___xor__, sizeof(__pyx_k___xor__), 1, 1, 1},
  {&__pyx_kp___sub__, __pyx_k___sub__, sizeof(__pyx_k___sub__), 1, 1, 1},
  {&__pyx_kp___iand__, __pyx_k___iand__, sizeof(__pyx_k___iand__), 1, 1, 1},
  {&__pyx_kp___ior__, __pyx_k___ior__, sizeof(__pyx_k___ior__), 1, 1, 1},
  {&__pyx_kp___ixor__, __pyx_k___ixor__, sizeof(__pyx_k___ixor__), 1, 1, 1},
  {&__pyx_kp___repr__, __pyx_k___repr__, sizeof(__pyx_k___repr__), 1, 1, 1},
  {&__pyx_kp___str__, __pyx_k___str__, sizeof(__pyx_k___str__), 1, 1, 1},
  {&__pyx_kp___iter__, __pyx_k___iter__, sizeof(__pyx_k___iter__), 1, 1, 1},
  {&__pyx_kp_add, __pyx_k_add, sizeof(__pyx_k_add), 1, 1, 1},
  {&__pyx_kp_clear, __pyx_k_clear, sizeof(__pyx_k_clear), 1, 1, 1},
  {&__pyx_kp_difference, __pyx_k_difference, sizeof(__pyx_k_difference), 1, 1, 1},
  {&__pyx_kp_difference_update, __pyx_k_difference_update, sizeof(__pyx_k_difference_update), 1, 1, 1},
  {&__pyx_kp_discard, __pyx_k_discard, sizeof(__pyx_k_discard), 1, 1, 1},
  {&__pyx_kp_intersection, __pyx_k_intersection, sizeof(__pyx_k_intersection), 1, 1, 1},
  {&__pyx_kp_intersection_update, __pyx_k_intersection_update, sizeof(__pyx_k_intersection_update), 1, 1, 1},
  {&__pyx_kp_union, __pyx_k_union, sizeof(__pyx_k_union), 1, 1, 1},
  {&__pyx_kp_union_update, __pyx_k_union_update, sizeof(__pyx_k_union_update), 1, 1, 1},
  {&__pyx_kp_issubset, __pyx_k_issubset, sizeof(__pyx_k_issubset), 1, 1, 1},
  {&__pyx_kp_issuperset, __pyx_k_issuperset, sizeof(__pyx_k_issuperset), 1, 1, 1},
  {&__pyx_kp_1, __pyx_k_1, sizeof(__pyx_k_1), 1, 1, 1},
  {&__pyx_kp_2, __pyx_k_2, sizeof(__pyx_k_2), 1, 1, 1},
  {&__pyx_kp_fastdump, __pyx_k_fastdump, sizeof(__pyx_k_fastdump), 1, 1, 1},
  {&__pyx_kp_fastload, __pyx_k_fastload, sizeof(__pyx_k_fastload), 1, 1, 1},
  {&__pyx_kp_copy, __pyx_k_copy, sizeof(__pyx_k_copy), 1, 1, 1},
  {&__pyx_kp_pop, __pyx_k_pop, sizeof(__pyx_k_pop), 1, 1, 1},
  {&__pyx_kp_remove, __pyx_k_remove, sizeof(__pyx_k_remove), 1, 1, 1},
  {&__pyx_kp_strbits, __pyx_k_strbits, sizeof(__pyx_k_strbits), 1, 1, 1},
  {&__pyx_kp_update_with_signs, __pyx_k_update_with_signs, sizeof(__pyx_k_update_with_signs), 1, 1, 1},
  {&__pyx_kp_get_size, __pyx_k_get_size, sizeof(__pyx_k_get_size), 1, 1, 1},
  {&__pyx_kp_get_allocated, __pyx_k_get_allocated, sizeof(__pyx_k_get_allocated), 1, 1, 1},
  {&__pyx_kp_get_sorted_element, __pyx_k_get_sorted_element, sizeof(__pyx_k_get_sorted_element), 1, 1, 1},
  {&__pyx_kp_to_sorted_list, __pyx_k_to_sorted_list, sizeof(__pyx_k_to_sorted_list), 1, 1, 1},
  {&__pyx_kp_is_infinite, __pyx_k_is_infinite, sizeof(__pyx_k_is_infinite), 1, 1, 1},
  {&__pyx_kp_extract_finite_list, __pyx_k_extract_finite_list, sizeof(__pyx_k_extract_finite_list), 1, 1, 1},
  {&__pyx_kp_get_wordbitsize, __pyx_k_get_wordbitsize, sizeof(__pyx_k_get_wordbitsize), 1, 1, 1},
  {&__pyx_kp_get_wordbytsize, __pyx_k_get_wordbytsize, sizeof(__pyx_k_get_wordbytsize), 1, 1, 1},
  {&__pyx_kp_tolist, __pyx_k_tolist, sizeof(__pyx_k_tolist), 1, 1, 1},
  {&__pyx_kp___next__, __pyx_k___next__, sizeof(__pyx_k___next__), 1, 1, 1},
  {&__pyx_kp_rhs, __pyx_k_rhs, sizeof(__pyx_k_rhs), 1, 1, 1},
  {&__pyx_kp_preallocate, __pyx_k_preallocate, sizeof(__pyx_k_preallocate), 1, 1, 1},
  {&__pyx_kp_trailing_bits, __pyx_k_trailing_bits, sizeof(__pyx_k_trailing_bits), 1, 1, 1},
  {&__pyx_kp_sanity_checks, __pyx_k_sanity_checks, sizeof(__pyx_k_sanity_checks), 1, 1, 1},
  {&__pyx_kp_no_allocate, __pyx_k_no_allocate, sizeof(__pyx_k_no_allocate), 1, 1, 1},
  {&__pyx_kp_elem, __pyx_k_elem, sizeof(__pyx_k_elem), 1, 1, 1},
  {&__pyx_kp_self, __pyx_k_self, sizeof(__pyx_k_self), 1, 1, 1},
  {&__pyx_kp_op, __pyx_k_op, sizeof(__pyx_k_op), 1, 1, 1},
  {&__pyx_kp_memo, __pyx_k_memo, sizeof(__pyx_k_memo), 1, 1, 1},
  {&__pyx_kp_strdump, __pyx_k_strdump, sizeof(__pyx_k_strdump), 1, 1, 1},
  {&__pyx_kp_index, __pyx_k_index, sizeof(__pyx_k_index), 1, 1, 1},
  {&__pyx_kp_i, __pyx_k_i, sizeof(__pyx_k_i), 1, 1, 1},
  {&__pyx_kp_j, __pyx_k_j, sizeof(__pyx_k_j), 1, 1, 1},
  {&__pyx_kp_up_to, __pyx_k_up_to, sizeof(__pyx_k_up_to), 1, 1, 1},
  {&__pyx_kp_bitset, __pyx_k_bitset, sizeof(__pyx_k_bitset), 1, 1, 1},
  {&__pyx_kp___revision__, __pyx_k___revision__, sizeof(__pyx_k___revision__), 1, 1, 1},
  {&__pyx_kp___apilevel__, __pyx_k___apilevel__, sizeof(__pyx_k___apilevel__), 1, 1, 1},
  {&__pyx_kp_zlib, __pyx_k_zlib, sizeof(__pyx_k_zlib), 1, 1, 1},
  {&__pyx_kp_array, __pyx_k_array, sizeof(__pyx_k_array), 1, 1, 1},
  {&__pyx_kp_4, __pyx_k_4, sizeof(__pyx_k_4), 1, 1, 1},
  {&__pyx_kp_5, __pyx_k_5, sizeof(__pyx_k_5), 1, 1, 1},
  {&__pyx_kp_6, __pyx_k_6, sizeof(__pyx_k_6), 0, 1, 0},
  {&__pyx_kp___all__, __pyx_k___all__, sizeof(__pyx_k___all__), 1, 1, 1},
  {&__pyx_kp___maxelem__, __pyx_k___maxelem__, sizeof(__pyx_k___maxelem__), 1, 1, 1},
  {&__pyx_kp_8, __pyx_k_8, sizeof(__pyx_k_8), 0, 1, 0},
  {&__pyx_kp_ValueError, __pyx_k_ValueError, sizeof(__pyx_k_ValueError), 1, 1, 1},
  {&__pyx_kp_tostring, __pyx_k_tostring, sizeof(__pyx_k_tostring), 1, 1, 1},
  {&__pyx_kp_decompress, __pyx_k_decompress, sizeof(__pyx_k_decompress), 1, 1, 1},
  {&__pyx_kp_Exception, __pyx_k_Exception, sizeof(__pyx_k_Exception), 1, 1, 1},
  {&__pyx_kp_12, __pyx_k_12, sizeof(__pyx_k_12), 0, 1, 0},
  {&__pyx_kp_max, __pyx_k_max, sizeof(__pyx_k_max), 1, 1, 1},
  {&__pyx_kp_OverflowError, __pyx_k_OverflowError, sizeof(__pyx_k_OverflowError), 1, 1, 1},
  {&__pyx_kp_TypeError, __pyx_k_TypeError, sizeof(__pyx_k_TypeError), 1, 1, 1},
  {&__pyx_kp_endswith, __pyx_k_endswith, sizeof(__pyx_k_endswith), 1, 1, 1},
  {&__pyx_kp___le__, __pyx_k___le__, sizeof(__pyx_k___le__), 1, 1, 1},
  {&__pyx_kp___ge__, __pyx_k___ge__, sizeof(__pyx_k___ge__), 1, 1, 1},
  {&__pyx_kp_compress, __pyx_k_compress, sizeof(__pyx_k_compress), 1, 1, 1},
  {&__pyx_kp_KeyError, __pyx_k_KeyError, sizeof(__pyx_k_KeyError), 1, 1, 1},
  {&__pyx_kp_iteritems, __pyx_k_iteritems, sizeof(__pyx_k_iteritems), 1, 1, 1},
  {&__pyx_kp_AttributeError, __pyx_k_AttributeError, sizeof(__pyx_k_AttributeError), 1, 1, 1},
  {&__pyx_kp_IndexError, __pyx_k_IndexError, sizeof(__pyx_k_IndexError), 1, 1, 1},
  {&__pyx_kp_append, __pyx_k_append, sizeof(__pyx_k_append), 1, 1, 1},
  {&__pyx_kp_StopIteration, __pyx_k_StopIteration, sizeof(__pyx_k_StopIteration), 1, 1, 1},
  {&__pyx_kp_MemoryError, __pyx_k_MemoryError, sizeof(__pyx_k_MemoryError), 1, 1, 1},
  {&__pyx_kp_3, __pyx_k_3, sizeof(__pyx_k_3), 0, 0, 0},
  {&__pyx_kp_9, __pyx_k_9, sizeof(__pyx_k_9), 0, 0, 0},
  {&__pyx_kp_10, __pyx_k_10, sizeof(__pyx_k_10), 0, 0, 0},
  {&__pyx_kp_11, __pyx_k_11, sizeof(__pyx_k_11), 0, 0, 0},
  {&__pyx_kp_13, __pyx_k_13, sizeof(__pyx_k_13), 0, 0, 0},
  {&__pyx_kp_14, __pyx_k_14, sizeof(__pyx_k_14), 0, 0, 0},
  {&__pyx_kp_15, __pyx_k_15, sizeof(__pyx_k_15), 0, 0, 0},
  {&__pyx_kp_16, __pyx_k_16, sizeof(__pyx_k_16), 0, 0, 0},
  {&__pyx_kp_17, __pyx_k_17, sizeof(__pyx_k_17), 0, 0, 0},
  {&__pyx_kp_18, __pyx_k_18, sizeof(__pyx_k_18), 0, 0, 0},
  {&__pyx_kp_19, __pyx_k_19, sizeof(__pyx_k_19), 0, 0, 0},
  {&__pyx_kp_20, __pyx_k_20, sizeof(__pyx_k_20), 0, 0, 0},
  {&__pyx_kp_21, __pyx_k_21, sizeof(__pyx_k_21), 0, 0, 0},
  {&__pyx_kp_22, __pyx_k_22, sizeof(__pyx_k_22), 0, 0, 0},
  {&__pyx_kp_23, __pyx_k_23, sizeof(__pyx_k_23), 0, 0, 0},
  {&__pyx_kp_24, __pyx_k_24, sizeof(__pyx_k_24), 0, 0, 0},
  {&__pyx_kp_25, __pyx_k_25, sizeof(__pyx_k_25), 0, 0, 0},
  {&__pyx_kp_26, __pyx_k_26, sizeof(__pyx_k_26), 0, 0, 0},
  {&__pyx_kp_27, __pyx_k_27, sizeof(__pyx_k_27), 0, 0, 0},
  {&__pyx_kp_28, __pyx_k_28, sizeof(__pyx_k_28), 0, 0, 0},
  {&__pyx_kp_29, __pyx_k_29, sizeof(__pyx_k_29), 0, 0, 0},
  {&__pyx_kp_30, __pyx_k_30, sizeof(__pyx_k_30), 0, 0, 0},
  {&__pyx_kp_31, __pyx_k_31, sizeof(__pyx_k_31), 0, 0, 0},
  {&__pyx_kp_32, __pyx_k_32, sizeof(__pyx_k_32), 0, 0, 0},
  {&__pyx_kp_33, __pyx_k_33, sizeof(__pyx_k_33), 0, 0, 0},
  {&__pyx_kp_34, __pyx_k_34, sizeof(__pyx_k_34), 0, 0, 0},
  {&__pyx_kp_35, __pyx_k_35, sizeof(__pyx_k_35), 0, 0, 0},
  {&__pyx_kp_36, __pyx_k_36, sizeof(__pyx_k_36), 0, 0, 0},
  {&__pyx_kp_37, __pyx_k_37, sizeof(__pyx_k_37), 0, 0, 0},
  {&__pyx_kp_38, __pyx_k_38, sizeof(__pyx_k_38), 0, 0, 0},
  {&__pyx_kp_39, __pyx_k_39, sizeof(__pyx_k_39), 0, 0, 0},
  {&__pyx_kp_40, __pyx_k_40, sizeof(__pyx_k_40), 0, 0, 0},
  {&__pyx_kp_41, __pyx_k_41, sizeof(__pyx_k_41), 0, 0, 0},
  {&__pyx_kp_42, __pyx_k_42, sizeof(__pyx_k_42), 0, 0, 0},
  {&__pyx_kp_43, __pyx_k_43, sizeof(__pyx_k_43), 0, 0, 0},
  {&__pyx_kp_44, __pyx_k_44, sizeof(__pyx_k_44), 0, 0, 0},
  {&__pyx_kp_45, __pyx_k_45, sizeof(__pyx_k_45), 0, 0, 0},
  {&__pyx_kp_46, __pyx_k_46, sizeof(__pyx_k_46), 0, 0, 0},
  {&__pyx_kp_47, __pyx_k_47, sizeof(__pyx_k_47), 0, 0, 0},
  {&__pyx_kp_48, __pyx_k_48, sizeof(__pyx_k_48), 0, 0, 0},
  {&__pyx_kp_49, __pyx_k_49, sizeof(__pyx_k_49), 0, 0, 0},
  {&__pyx_kp_50, __pyx_k_50, sizeof(__pyx_k_50), 0, 0, 0},
  {&__pyx_kp_51, __pyx_k_51, sizeof(__pyx_k_51), 0, 0, 0},
  {&__pyx_kp_52, __pyx_k_52, sizeof(__pyx_k_52), 0, 0, 0},
  {&__pyx_kp_53, __pyx_k_53, sizeof(__pyx_k_53), 0, 0, 0},
  {&__pyx_kp_54, __pyx_k_54, sizeof(__pyx_k_54), 0, 0, 0},
  {&__pyx_kp_55, __pyx_k_55, sizeof(__pyx_k_55), 0, 0, 0},
  {&__pyx_kp_56, __pyx_k_56, sizeof(__pyx_k_56), 0, 0, 0},
  {&__pyx_kp_57, __pyx_k_57, sizeof(__pyx_k_57), 0, 0, 0},
  {&__pyx_kp_58, __pyx_k_58, sizeof(__pyx_k_58), 0, 0, 0},
  {&__pyx_kp_59, __pyx_k_59, sizeof(__pyx_k_59), 0, 0, 0},
  {&__pyx_kp_60, __pyx_k_60, sizeof(__pyx_k_60), 0, 0, 0},
  {&__pyx_kp_61, __pyx_k_61, sizeof(__pyx_k_61), 0, 0, 0},
  {&__pyx_kp_62, __pyx_k_62, sizeof(__pyx_k_62), 0, 0, 0},
  {&__pyx_kp_63, __pyx_k_63, sizeof(__pyx_k_63), 0, 0, 0},
  {&__pyx_kp_64, __pyx_k_64, sizeof(__pyx_k_64), 0, 0, 0},
  {&__pyx_kp_65, __pyx_k_65, sizeof(__pyx_k_65), 0, 0, 0},
  {&__pyx_kp_66, __pyx_k_66, sizeof(__pyx_k_66), 0, 0, 0},
  {&__pyx_kp_67, __pyx_k_67, sizeof(__pyx_k_67), 0, 0, 0},
  {&__pyx_kp_68, __pyx_k_68, sizeof(__pyx_k_68), 0, 0, 0},
  {&__pyx_kp_69, __pyx_k_69, sizeof(__pyx_k_69), 0, 0, 0},
  {&__pyx_kp_70, __pyx_k_70, sizeof(__pyx_k_70), 0, 0, 0},
  {&__pyx_kp_71, __pyx_k_71, sizeof(__pyx_k_71), 0, 0, 0},
  {&__pyx_kp_72, __pyx_k_72, sizeof(__pyx_k_72), 0, 0, 0},
  {&__pyx_kp_73, __pyx_k_73, sizeof(__pyx_k_73), 0, 0, 0},
  {&__pyx_kp_74, __pyx_k_74, sizeof(__pyx_k_74), 0, 0, 0},
  {&__pyx_kp_75, __pyx_k_75, sizeof(__pyx_k_75), 0, 0, 0},
  {&__pyx_kp_76, __pyx_k_76, sizeof(__pyx_k_76), 0, 0, 0},
  {&__pyx_kp_77, __pyx_k_77, sizeof(__pyx_k_77), 0, 0, 0},
  {&__pyx_kp_78, __pyx_k_78, sizeof(__pyx_k_78), 0, 0, 0},
  {0, 0, 0, 0, 0, 0}
};
static int __Pyx_InitCachedBuiltins(void) {
  __pyx_builtin_ValueError = __Pyx_GetName(__pyx_b, __pyx_kp_ValueError); if (!__pyx_builtin_ValueError) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 170; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_builtin_Exception = __Pyx_GetName(__pyx_b, __pyx_kp_Exception); if (!__pyx_builtin_Exception) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 180; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_builtin_max = __Pyx_GetName(__pyx_b, __pyx_kp_max); if (!__pyx_builtin_max) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 189; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_builtin_OverflowError = __Pyx_GetName(__pyx_b, __pyx_kp_OverflowError); if (!__pyx_builtin_OverflowError) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 194; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_builtin_TypeError = __Pyx_GetName(__pyx_b, __pyx_kp_TypeError); if (!__pyx_builtin_TypeError) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 259; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_builtin_KeyError = __Pyx_GetName(__pyx_b, __pyx_kp_KeyError); if (!__pyx_builtin_KeyError) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 588; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_builtin_AttributeError = __Pyx_GetName(__pyx_b, __pyx_kp_AttributeError); if (!__pyx_builtin_AttributeError) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 642; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_builtin_IndexError = __Pyx_GetName(__pyx_b, __pyx_kp_IndexError); if (!__pyx_builtin_IndexError) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 669; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_builtin_StopIteration = __Pyx_GetName(__pyx_b, __pyx_kp_StopIteration); if (!__pyx_builtin_StopIteration) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 759; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_builtin_MemoryError = __Pyx_GetName(__pyx_b, __pyx_kp_MemoryError); if (!__pyx_builtin_MemoryError) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 762; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  return 0;
  __pyx_L1_error:;
  return -1;
}

static int __Pyx_InitGlobals(void) {
  __pyx_int_0 = PyInt_FromLong(0); if (unlikely(!__pyx_int_0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  __pyx_int_1 = PyInt_FromLong(1); if (unlikely(!__pyx_int_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  __pyx_int_10 = PyInt_FromLong(10); if (unlikely(!__pyx_int_10)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  __pyx_int_5 = PyInt_FromLong(5); if (unlikely(!__pyx_int_5)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  if (__Pyx_InitStrings(__pyx_string_tab) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  return 0;
  __pyx_L1_error:;
  return -1;
}

#if PY_MAJOR_VERSION < 3
PyMODINIT_FUNC initintbitset(void); /*proto*/
PyMODINIT_FUNC initintbitset(void)
#else
PyMODINIT_FUNC PyInit_intbitset(void); /*proto*/
PyMODINIT_FUNC PyInit_intbitset(void)
#endif
{
  PyObject *__pyx_1 = 0;
  PyObject *__pyx_2 = 0;
  PyObject *__pyx_t_1 = NULL;
  int __pyx_t_2;
  #ifdef CYTHON_REFNANNY
  void* __pyx_refchk = NULL;
  __Pyx_Refnanny = __Pyx_ImportRefcountAPI("refnanny");
  if (!__Pyx_Refnanny) {
      PyErr_Clear();
      __Pyx_Refnanny = __Pyx_ImportRefcountAPI("Cython.Runtime.refnanny");
      if (!__Pyx_Refnanny)
          Py_FatalError("failed to import refnanny module");
  }
  __pyx_refchk = __Pyx_Refnanny->NewContext("PyMODINIT_FUNC PyInit_intbitset(void)", __LINE__, __FILE__);
  #endif
  __pyx_empty_tuple = PyTuple_New(0); if (unlikely(!__pyx_empty_tuple)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  /*--- Library function declarations ---*/
  __pyx_init_filenames();
  /*--- Threads initialization code ---*/
  #if defined(__PYX_FORCE_INIT_THREADS) && __PYX_FORCE_INIT_THREADS
  #ifdef WITH_THREAD /* Python build with threading support? */
  PyEval_InitThreads();
  #endif
  #endif
  /*--- Initialize various global constants etc. ---*/
  if (unlikely(__Pyx_InitGlobals() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  /*--- Module creation code ---*/
  #if PY_MAJOR_VERSION < 3
  __pyx_m = Py_InitModule4(__Pyx_NAMESTR("intbitset"), __pyx_methods, 0, 0, PYTHON_API_VERSION);
  #else
  __pyx_m = PyModule_Create(&__pyx_moduledef);
  #endif
  if (!__pyx_m) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  #if PY_MAJOR_VERSION < 3
  Py_INCREF(__pyx_m);
  #endif
  __pyx_b = PyImport_AddModule(__Pyx_NAMESTR(__Pyx_BUILTIN_MODULE_NAME));
  if (!__pyx_b) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  if (__Pyx_SetAttrString(__pyx_m, "__builtins__", __pyx_b) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  if (__pyx_module_is_main_lib__intbitset) {
    if (__Pyx_SetAttrString(__pyx_m, "__name__", __pyx_kp___main__) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;};
  }
  /*--- Builtin init code ---*/
  if (unlikely(__Pyx_InitCachedBuiltins() < 0)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 1; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_skip_dispatch = 0;
  /*--- Global init code ---*/
  /*--- Function export code ---*/
  /*--- Type init code ---*/
  if (PyType_Ready(&__pyx_type_3lib_9intbitset_intbitset) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 94; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__Pyx_SetAttrString(__pyx_m, "intbitset", (PyObject *)&__pyx_type_3lib_9intbitset_intbitset) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 94; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_3lib_9intbitset_intbitset = &__pyx_type_3lib_9intbitset_intbitset;
  if (PyType_Ready(&__pyx_type_3lib_9intbitset_intbitset_iterator) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 741; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  if (__Pyx_SetAttrString(__pyx_m, "intbitset_iterator", (PyObject *)&__pyx_type_3lib_9intbitset_intbitset_iterator) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 741; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __pyx_ptype_3lib_9intbitset_intbitset_iterator = &__pyx_type_3lib_9intbitset_intbitset_iterator;
  /*--- Type import code ---*/
  /*--- Function import code ---*/
  /*--- Execution code ---*/

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":18
 * ## 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.
 * 
 * __revision__ = "$Id$"             # <<<<<<<<<<<<<<
 * __apilevel__ = 1.03
 * 
 */
  if (PyObject_SetAttr(__pyx_m, __pyx_kp___revision__, __pyx_kp_3) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 18; __pyx_clineno = __LINE__; goto __pyx_L1_error;}

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":19
 * 
 * __revision__ = "$Id$"
 * __apilevel__ = 1.03             # <<<<<<<<<<<<<<
 * 
 * """
 */
  __pyx_t_1 = PyFloat_FromDouble(1.03); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 19; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyObject_SetAttr(__pyx_m, __pyx_kp___apilevel__, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 19; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":42
 * """
 * 
 * import zlib             # <<<<<<<<<<<<<<
 * from array import array
 * from invenio.config import CFG_INTBITSET_ENABLE_SANITY_CHECKS
 */
  __pyx_1 = __Pyx_Import(__pyx_kp_zlib, 0); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 42; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_1);
  if (PyObject_SetAttr(__pyx_m, __pyx_kp_zlib, __pyx_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 42; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_1); __pyx_1 = 0;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":43
 * 
 * import zlib
 * from array import array             # <<<<<<<<<<<<<<
 * from invenio.config import CFG_INTBITSET_ENABLE_SANITY_CHECKS
 * 
 */
  __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 43; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(((PyObject *)__pyx_t_1));
  __Pyx_INCREF(__pyx_kp_array);
  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_kp_array);
  __Pyx_GIVEREF(__pyx_kp_array);
  __pyx_1 = __Pyx_Import(__pyx_kp_array, ((PyObject *)__pyx_t_1)); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 43; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_1);
  __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
  __pyx_2 = PyObject_GetAttr(__pyx_1, __pyx_kp_array); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 43; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_2);
  if (PyObject_SetAttr(__pyx_m, __pyx_kp_array, __pyx_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 43; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_2); __pyx_2 = 0;
  __Pyx_DECREF(__pyx_1); __pyx_1 = 0;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":44
 * import zlib
 * from array import array
 * from invenio.config import CFG_INTBITSET_ENABLE_SANITY_CHECKS             # <<<<<<<<<<<<<<
 * 
 * __all__ = ['intbitset']
 */
  __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 44; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(((PyObject *)__pyx_t_1));
  __Pyx_INCREF(__pyx_kp_5);
  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_kp_5);
  __Pyx_GIVEREF(__pyx_kp_5);
  __pyx_1 = __Pyx_Import(__pyx_kp_4, ((PyObject *)__pyx_t_1)); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 44; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_1);
  __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;
  __pyx_2 = PyObject_GetAttr(__pyx_1, __pyx_kp_5); if (unlikely(!__pyx_2)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 44; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_2);
  if (PyObject_SetAttr(__pyx_m, __pyx_kp_5, __pyx_2) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 44; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_2); __pyx_2 = 0;
  __Pyx_DECREF(__pyx_1); __pyx_1 = 0;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":46
 * from invenio.config import CFG_INTBITSET_ENABLE_SANITY_CHECKS
 * 
 * __all__ = ['intbitset']             # <<<<<<<<<<<<<<
 * 
 * cdef extern from "intbitset.h":
 */
  __pyx_t_1 = PyList_New(1); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 46; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(((PyObject *)__pyx_t_1));
  __Pyx_INCREF(__pyx_kp_6);
  PyList_SET_ITEM(__pyx_t_1, 0, __pyx_kp_6);
  __Pyx_GIVEREF(__pyx_kp_6);
  if (PyObject_SetAttr(__pyx_m, __pyx_kp___all__, ((PyObject *)__pyx_t_1)) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 46; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(((PyObject *)__pyx_t_1)); __pyx_t_1 = 0;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":92
 *     unsigned char intBitSetCmp(IntBitSet *x, IntBitSet *y)
 * 
 * __maxelem__ = maxelem             # <<<<<<<<<<<<<<
 * 
 * cdef class intbitset:
 */
  __pyx_t_1 = PyInt_FromLong(maxelem); if (unlikely(!__pyx_t_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 92; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_t_1);
  if (PyObject_SetAttr(__pyx_m, __pyx_kp___maxelem__, __pyx_t_1) < 0) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 92; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_t_1); __pyx_t_1 = 0;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":135
 *     cdef bint sanity_checks
 * 
 *     def __cinit__(self, rhs=0, int preallocate=-1, int trailing_bits=0, bint sanity_checks=CFG_INTBITSET_ENABLE_SANITY_CHECKS, int no_allocate=0):             # <<<<<<<<<<<<<<
 *         """
 *         Initialize intbitset.
 */
  __pyx_1 = __Pyx_GetName(__pyx_m, __pyx_kp_5); if (unlikely(!__pyx_1)) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 135; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_GOTREF(__pyx_1);
  __pyx_t_2 = __Pyx_PyObject_IsTrue(__pyx_1); if (unlikely((__pyx_t_2 == (int)-1))) {__pyx_filename = __pyx_f[0]; __pyx_lineno = 135; __pyx_clineno = __LINE__; goto __pyx_L1_error;}
  __Pyx_DECREF(__pyx_1); __pyx_1 = 0;
  __pyx_k_7 = __pyx_t_2;

  /* "/mnt/disk1/build/cds-invenio/modules/miscutil/lib/intbitset.pyx":768
 *         return self.last
 * 
 *     def __iter__(self):             # <<<<<<<<<<<<<<
 *         return self
 */
  goto __pyx_L0;
  __pyx_L1_error:;
  __Pyx_XDECREF(__pyx_1);
  __Pyx_XDECREF(__pyx_2);
  __Pyx_XDECREF(__pyx_t_1);
  __Pyx_AddTraceback("lib.intbitset");
  Py_DECREF(__pyx_m); __pyx_m = 0;
  __pyx_L0:;
  __Pyx_FinishRefcountContext();
  #if PY_MAJOR_VERSION < 3
  return;
  #else
  return __pyx_m;
  #endif
}

static const char *__pyx_filenames[] = {
  "intbitset.pyx",
};

/* Runtime support code */

static void __pyx_init_filenames(void) {
  __pyx_f = __pyx_filenames;
}

static void __Pyx_RaiseDoubleKeywordsError(
    const char* func_name,
    PyObject* kw_name)
{
    PyErr_Format(PyExc_TypeError,
        #if PY_MAJOR_VERSION >= 3
        "%s() got multiple values for keyword argument '%U'", func_name, kw_name);
        #else
        "%s() got multiple values for keyword argument '%s'", func_name,
        PyString_AS_STRING(kw_name));
        #endif
}

static void __Pyx_RaiseArgtupleInvalid(
    const char* func_name,
    int exact,
    Py_ssize_t num_min,
    Py_ssize_t num_max,
    Py_ssize_t num_found)
{
    Py_ssize_t num_expected;
    const char *number, *more_or_less;

    if (num_found < num_min) {
        num_expected = num_min;
        more_or_less = "at least";
    } else {
        num_expected = num_max;
        more_or_less = "at most";
    }
    if (exact) {
        more_or_less = "exactly";
    }
    number = (num_expected == 1) ? "" : "s";
    PyErr_Format(PyExc_TypeError,
        #if PY_VERSION_HEX < 0x02050000
            "%s() takes %s %d positional argument%s (%d given)",
        #else
            "%s() takes %s %zd positional argument%s (%zd given)",
        #endif
        func_name, more_or_less, num_expected, number, num_found);
}

static int __Pyx_ParseOptionalKeywords(
    PyObject *kwds,
    PyObject **argnames[],
    PyObject *kwds2,
    PyObject *values[],
    Py_ssize_t num_pos_args,
    const char* function_name)
{
    PyObject *key = 0, *value = 0;
    Py_ssize_t pos = 0;
    PyObject*** name;
    PyObject*** first_kw_arg = argnames + num_pos_args;

    while (PyDict_Next(kwds, &pos, &key, &value)) {
        name = first_kw_arg;
        while (*name && (**name != key)) name++;
        if (*name) {
            values[name-argnames] = value;
        } else {
            #if PY_MAJOR_VERSION < 3
            if (unlikely(!PyString_CheckExact(key)) && unlikely(!PyString_Check(key))) {
            #else
            if (unlikely(!PyUnicode_CheckExact(key)) && unlikely(!PyUnicode_Check(key))) {
            #endif
                goto invalid_keyword_type;
            } else {
                for (name = first_kw_arg; *name; name++) {
                    #if PY_MAJOR_VERSION >= 3
                    if (PyUnicode_GET_SIZE(**name) == PyUnicode_GET_SIZE(key) &&
                        PyUnicode_Compare(**name, key) == 0) break;
                    #else
                    if (PyString_GET_SIZE(**name) == PyString_GET_SIZE(key) &&
                        _PyString_Eq(**name, key)) break;
                    #endif
                }
                if (*name) {
                    values[name-argnames] = value;
                } else {
                    /* unexpected keyword found */
                    for (name=argnames; name != first_kw_arg; name++) {
                        if (**name == key) goto arg_passed_twice;
                        #if PY_MAJOR_VERSION >= 3
                        if (PyUnicode_GET_SIZE(**name) == PyUnicode_GET_SIZE(key) &&
                            PyUnicode_Compare(**name, key) == 0) goto arg_passed_twice;
                        #else
                        if (PyString_GET_SIZE(**name) == PyString_GET_SIZE(key) &&
                            _PyString_Eq(**name, key)) goto arg_passed_twice;
                        #endif
                    }
                    if (kwds2) {
                        if (unlikely(PyDict_SetItem(kwds2, key, value))) goto bad;
                    } else {
                        goto invalid_keyword;
                    }
                }
            }
        }
    }
    return 0;
arg_passed_twice:
    __Pyx_RaiseDoubleKeywordsError(function_name, **name);
    goto bad;
invalid_keyword_type:
    PyErr_Format(PyExc_TypeError,
        "%s() keywords must be strings", function_name);
    goto bad;
invalid_keyword:
    PyErr_Format(PyExc_TypeError,
    #if PY_MAJOR_VERSION < 3
        "%s() got an unexpected keyword argument '%s'",
        function_name, PyString_AsString(key));
    #else
        "%s() got an unexpected keyword argument '%U'",
        function_name, key);
    #endif
bad:
    return -1;
}

static int __Pyx_GetException(PyObject **type, PyObject **value, PyObject **tb) {
    PyObject *tmp_type, *tmp_value, *tmp_tb;
    PyThreadState *tstate = PyThreadState_GET();
    *type = tstate->curexc_type;
    *value = tstate->curexc_value;
    *tb = tstate->curexc_traceback;
    tstate->curexc_type = 0;
    tstate->curexc_value = 0;
    tstate->curexc_traceback = 0;
    PyErr_NormalizeException(type, value, tb);
    if (PyErr_Occurred())
        goto bad;
    Py_INCREF(*type);
    Py_INCREF(*value);
    Py_INCREF(*tb);
    tmp_type = tstate->exc_type;
    tmp_value = tstate->exc_value;
    tmp_tb = tstate->exc_traceback;
    tstate->exc_type = *type;
    tstate->exc_value = *value;
    tstate->exc_traceback = *tb;
    /* Make sure tstate is in a consistent state when we XDECREF
    these objects (XDECREF may run arbitrary code). */
    Py_XDECREF(tmp_type);
    Py_XDECREF(tmp_value);
    Py_XDECREF(tmp_tb);
    return 0;
bad:
    Py_XDECREF(*type);
    Py_XDECREF(*value);
    Py_XDECREF(*tb);
    return -1;
}



static int __Pyx_ArgTypeTest(PyObject *obj, PyTypeObject *type, int none_allowed,
    const char *name, int exact)
{
    if (!type) {
        PyErr_Format(PyExc_SystemError, "Missing type object");
        return 0;
    }
    if (none_allowed && obj == Py_None) return 1;
    else if (exact) {
        if (Py_TYPE(obj) == type) return 1;
    }
    else {
        if (PyObject_TypeCheck(obj, type)) return 1;
    }
    PyErr_Format(PyExc_TypeError,
        "Argument '%s' has incorrect type (expected %s, got %s)",
        name, type->tp_name, Py_TYPE(obj)->tp_name);
    return 0;
}

static INLINE void __Pyx_ExceptionSave(PyObject **type, PyObject **value, PyObject **tb) {
    PyThreadState *tstate = PyThreadState_GET();
    *type = tstate->exc_type;
    *value = tstate->exc_value;
    *tb = tstate->exc_traceback;
    Py_XINCREF(*type);
    Py_XINCREF(*value);
    Py_XINCREF(*tb);
}

static void __Pyx_ExceptionReset(PyObject *type, PyObject *value, PyObject *tb) {
    PyObject *tmp_type, *tmp_value, *tmp_tb;
    PyThreadState *tstate = PyThreadState_GET();
    tmp_type = tstate->exc_type;
    tmp_value = tstate->exc_value;
    tmp_tb = tstate->exc_traceback;
    tstate->exc_type = type;
    tstate->exc_value = value;
    tstate->exc_traceback = tb;
    Py_XDECREF(tmp_type);
    Py_XDECREF(tmp_value);
    Py_XDECREF(tmp_tb);
}

static PyObject *__Pyx_Import(PyObject *name, PyObject *from_list) {
    PyObject *__import__ = 0;
    PyObject *empty_list = 0;
    PyObject *module = 0;
    PyObject *global_dict = 0;
    PyObject *empty_dict = 0;
    PyObject *list;
    __import__ = __Pyx_GetAttrString(__pyx_b, "__import__");
    if (!__import__)
        goto bad;
    if (from_list)
        list = from_list;
    else {
        empty_list = PyList_New(0);
        if (!empty_list)
            goto bad;
        list = empty_list;
    }
    global_dict = PyModule_GetDict(__pyx_m);
    if (!global_dict)
        goto bad;
    empty_dict = PyDict_New();
    if (!empty_dict)
        goto bad;
    module = PyObject_CallFunctionObjArgs(__import__,
        name, global_dict, empty_dict, list, NULL);
bad:
    Py_XDECREF(empty_list);
    Py_XDECREF(__import__);
    Py_XDECREF(empty_dict);
    return module;
}

static PyObject *__Pyx_GetName(PyObject *dict, PyObject *name) {
    PyObject *result;
    result = PyObject_GetAttr(dict, name);
    if (!result)
        PyErr_SetObject(PyExc_NameError, name);
    return result;
}

static void __Pyx_Raise(PyObject *type, PyObject *value, PyObject *tb) {
    Py_XINCREF(type);
    Py_XINCREF(value);
    Py_XINCREF(tb);
    /* First, check the traceback argument, replacing None with NULL. */
    if (tb == Py_None) {
        Py_DECREF(tb);
        tb = 0;
    }
    else if (tb != NULL && !PyTraceBack_Check(tb)) {
        PyErr_SetString(PyExc_TypeError,
            "raise: arg 3 must be a traceback or None");
        goto raise_error;
    }
    /* Next, replace a missing value with None */
    if (value == NULL) {
        value = Py_None;
        Py_INCREF(value);
    }
    #if PY_VERSION_HEX < 0x02050000
    if (!PyClass_Check(type))
    #else
    if (!PyType_Check(type))
    #endif
    {
        /* Raising an instance.  The value should be a dummy. */
        if (value != Py_None) {
            PyErr_SetString(PyExc_TypeError,
                "instance exception may not have a separate value");
            goto raise_error;
        }
        /* Normalize to raise <class>, <instance> */
        Py_DECREF(value);
        value = type;
        #if PY_VERSION_HEX < 0x02050000
            if (PyInstance_Check(type)) {
                type = (PyObject*) ((PyInstanceObject*)type)->in_class;
                Py_INCREF(type);
            }
            else {
                type = 0;
                PyErr_SetString(PyExc_TypeError,
                    "raise: exception must be an old-style class or instance");
                goto raise_error;
            }
        #else
            type = (PyObject*) Py_TYPE(type);
            Py_INCREF(type);
            if (!PyType_IsSubtype((PyTypeObject *)type, (PyTypeObject *)PyExc_BaseException)) {
                PyErr_SetString(PyExc_TypeError,
                    "raise: exception class must be a subclass of BaseException");
                goto raise_error;
            }
        #endif
    }
    __Pyx_ErrRestore(type, value, tb);
    return;
raise_error:
    Py_XDECREF(value);
    Py_XDECREF(type);
    Py_XDECREF(tb);
    return;
}

static INLINE void __Pyx_ErrRestore(PyObject *type, PyObject *value, PyObject *tb) {
    PyObject *tmp_type, *tmp_value, *tmp_tb;
    PyThreadState *tstate = PyThreadState_GET();

#if PY_MAJOR_VERSION >= 3
    /* Note: this is a temporary work-around to prevent crashes in Python 3.0 */
    if ((tstate->exc_type != NULL) & (tstate->exc_type != Py_None)) {
        tmp_type = tstate->exc_type;
        tmp_value = tstate->exc_value;
        tmp_tb = tstate->exc_traceback;
        PyErr_NormalizeException(&type, &value, &tb);
        PyErr_NormalizeException(&tmp_type, &tmp_value, &tmp_tb);
        tstate->exc_type = 0;
        tstate->exc_value = 0;
        tstate->exc_traceback = 0;
        PyException_SetContext(value, tmp_value);
        Py_DECREF(tmp_type);
        Py_XDECREF(tmp_tb);
    }
#endif

    tmp_type = tstate->curexc_type;
    tmp_value = tstate->curexc_value;
    tmp_tb = tstate->curexc_traceback;
    tstate->curexc_type = type;
    tstate->curexc_value = value;
    tstate->curexc_traceback = tb;
    Py_XDECREF(tmp_type);
    Py_XDECREF(tmp_value);
    Py_XDECREF(tmp_tb);
}

static INLINE void __Pyx_ErrFetch(PyObject **type, PyObject **value, PyObject **tb) {
    PyThreadState *tstate = PyThreadState_GET();
    *type = tstate->curexc_type;
    *value = tstate->curexc_value;
    *tb = tstate->curexc_traceback;

    tstate->curexc_type = 0;
    tstate->curexc_value = 0;
    tstate->curexc_traceback = 0;
}


static INLINE void __Pyx_RaiseNeedMoreValuesError(Py_ssize_t index) {
    PyErr_Format(PyExc_ValueError,
        #if PY_VERSION_HEX < 0x02050000
                 "need more than %d value%s to unpack", (int)index,
        #else
                 "need more than %zd value%s to unpack", index,
        #endif
                 (index == 1) ? "" : "s");
}

static INLINE void __Pyx_RaiseTooManyValuesError(void) {
    PyErr_SetString(PyExc_ValueError, "too many values to unpack");
}

static PyObject *__Pyx_UnpackItem(PyObject *iter, Py_ssize_t index) {
    PyObject *item;
    if (!(item = PyIter_Next(iter))) {
        if (!PyErr_Occurred()) {
            __Pyx_RaiseNeedMoreValuesError(index);
        }
    }
    return item;
}

static int __Pyx_EndUnpack(PyObject *iter) {
    PyObject *item;
    if ((item = PyIter_Next(iter))) {
        Py_DECREF(item);
        __Pyx_RaiseTooManyValuesError();
        return -1;
    }
    else if (!PyErr_Occurred())
        return 0;
    else
        return -1;
}

static INLINE int __Pyx_StrEq(const char *s1, const char *s2) {
     while (*s1 != '\0' && *s1 == *s2) { s1++; s2++; }
     return *s1 == *s2;
}

static INLINE unsigned char __Pyx_PyInt_AsUnsignedChar(PyObject* x) {
    if (sizeof(unsigned char) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(unsigned char)val)) {
            if (unlikely(val == -1 && PyErr_Occurred()))
                return (unsigned char)-1;
            if (unlikely(val < 0)) {
                PyErr_SetString(PyExc_OverflowError,
                                "can't convert negative value to unsigned char");
                return (unsigned char)-1;
            }
            PyErr_SetString(PyExc_OverflowError,
                           "value too large to convert to unsigned char");
            return (unsigned char)-1;
        }
        return (unsigned char)val;
    }
    return (unsigned char)__Pyx_PyInt_AsUnsignedLong(x);
}

static INLINE unsigned short __Pyx_PyInt_AsUnsignedShort(PyObject* x) {
    if (sizeof(unsigned short) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(unsigned short)val)) {
            if (unlikely(val == -1 && PyErr_Occurred()))
                return (unsigned short)-1;
            if (unlikely(val < 0)) {
                PyErr_SetString(PyExc_OverflowError,
                                "can't convert negative value to unsigned short");
                return (unsigned short)-1;
            }
            PyErr_SetString(PyExc_OverflowError,
                           "value too large to convert to unsigned short");
            return (unsigned short)-1;
        }
        return (unsigned short)val;
    }
    return (unsigned short)__Pyx_PyInt_AsUnsignedLong(x);
}

static INLINE unsigned int __Pyx_PyInt_AsUnsignedInt(PyObject* x) {
    if (sizeof(unsigned int) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(unsigned int)val)) {
            if (unlikely(val == -1 && PyErr_Occurred()))
                return (unsigned int)-1;
            if (unlikely(val < 0)) {
                PyErr_SetString(PyExc_OverflowError,
                                "can't convert negative value to unsigned int");
                return (unsigned int)-1;
            }
            PyErr_SetString(PyExc_OverflowError,
                           "value too large to convert to unsigned int");
            return (unsigned int)-1;
        }
        return (unsigned int)val;
    }
    return (unsigned int)__Pyx_PyInt_AsUnsignedLong(x);
}

static INLINE char __Pyx_PyInt_AsChar(PyObject* x) {
    if (sizeof(char) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(char)val)) {
            if (unlikely(val == -1 && PyErr_Occurred()))
                return (char)-1;
            PyErr_SetString(PyExc_OverflowError,
                           "value too large to convert to char");
            return (char)-1;
        }
        return (char)val;
    }
    return (char)__Pyx_PyInt_AsLong(x);
}

static INLINE short __Pyx_PyInt_AsShort(PyObject* x) {
    if (sizeof(short) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(short)val)) {
            if (unlikely(val == -1 && PyErr_Occurred()))
                return (short)-1;
            PyErr_SetString(PyExc_OverflowError,
                           "value too large to convert to short");
            return (short)-1;
        }
        return (short)val;
    }
    return (short)__Pyx_PyInt_AsLong(x);
}

static INLINE int __Pyx_PyInt_AsInt(PyObject* x) {
    if (sizeof(int) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(int)val)) {
            if (unlikely(val == -1 && PyErr_Occurred()))
                return (int)-1;
            PyErr_SetString(PyExc_OverflowError,
                           "value too large to convert to int");
            return (int)-1;
        }
        return (int)val;
    }
    return (int)__Pyx_PyInt_AsLong(x);
}

static INLINE signed char __Pyx_PyInt_AsSignedChar(PyObject* x) {
    if (sizeof(signed char) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(signed char)val)) {
            if (unlikely(val == -1 && PyErr_Occurred()))
                return (signed char)-1;
            PyErr_SetString(PyExc_OverflowError,
                           "value too large to convert to signed char");
            return (signed char)-1;
        }
        return (signed char)val;
    }
    return (signed char)__Pyx_PyInt_AsSignedLong(x);
}

static INLINE signed short __Pyx_PyInt_AsSignedShort(PyObject* x) {
    if (sizeof(signed short) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(signed short)val)) {
            if (unlikely(val == -1 && PyErr_Occurred()))
                return (signed short)-1;
            PyErr_SetString(PyExc_OverflowError,
                           "value too large to convert to signed short");
            return (signed short)-1;
        }
        return (signed short)val;
    }
    return (signed short)__Pyx_PyInt_AsSignedLong(x);
}

static INLINE signed int __Pyx_PyInt_AsSignedInt(PyObject* x) {
    if (sizeof(signed int) < sizeof(long)) {
        long val = __Pyx_PyInt_AsLong(x);
        if (unlikely(val != (long)(signed int)val)) {
            if (unlikely(val == -1 && PyErr_Occurred()))
                return (signed int)-1;
            PyErr_SetString(PyExc_OverflowError,
                           "value too large to convert to signed int");
            return (signed int)-1;
        }
        return (signed int)val;
    }
    return (signed int)__Pyx_PyInt_AsSignedLong(x);
}

static INLINE unsigned long __Pyx_PyInt_AsUnsignedLong(PyObject* x) {
#if PY_VERSION_HEX < 0x03000000
    if (likely(PyInt_CheckExact(x) || PyInt_Check(x))) {
        long val = PyInt_AS_LONG(x);
        if (unlikely(val < 0)) {
            PyErr_SetString(PyExc_OverflowError,
                            "can't convert negative value to unsigned long");
            return (unsigned long)-1;
        }
        return (unsigned long)val;
    } else
#endif
    if (likely(PyLong_CheckExact(x) || PyLong_Check(x))) {
        if (unlikely(Py_SIZE(x) < 0)) {
            PyErr_SetString(PyExc_OverflowError,
                            "can't convert negative value to unsigned long");
            return (unsigned long)-1;
        }
        return PyLong_AsUnsignedLong(x);
    } else {
        unsigned long val;
        PyObject *tmp = __Pyx_PyNumber_Int(x);
        if (!tmp) return (unsigned long)-1;
        val = __Pyx_PyInt_AsUnsignedLong(tmp);
        Py_DECREF(tmp);
        return val;
    }
}

static INLINE unsigned PY_LONG_LONG __Pyx_PyInt_AsUnsignedLongLong(PyObject* x) {
#if PY_VERSION_HEX < 0x03000000
    if (likely(PyInt_CheckExact(x) || PyInt_Check(x))) {
        long val = PyInt_AS_LONG(x);
        if (unlikely(val < 0)) {
            PyErr_SetString(PyExc_OverflowError,
                            "can't convert negative value to unsigned PY_LONG_LONG");
            return (unsigned PY_LONG_LONG)-1;
        }
        return (unsigned PY_LONG_LONG)val;
    } else
#endif
    if (likely(PyLong_CheckExact(x) || PyLong_Check(x))) {
        if (unlikely(Py_SIZE(x) < 0)) {
            PyErr_SetString(PyExc_OverflowError,
                            "can't convert negative value to unsigned PY_LONG_LONG");
            return (unsigned PY_LONG_LONG)-1;
        }
        return PyLong_AsUnsignedLongLong(x);
    } else {
        unsigned PY_LONG_LONG val;
        PyObject *tmp = __Pyx_PyNumber_Int(x);
        if (!tmp) return (unsigned PY_LONG_LONG)-1;
        val = __Pyx_PyInt_AsUnsignedLongLong(tmp);
        Py_DECREF(tmp);
        return val;
    }
}

static INLINE long __Pyx_PyInt_AsLong(PyObject* x) {
#if PY_VERSION_HEX < 0x03000000
    if (likely(PyInt_CheckExact(x) || PyInt_Check(x))) {
        long val = PyInt_AS_LONG(x);
        return (long)val;
    } else
#endif
    if (likely(PyLong_CheckExact(x) || PyLong_Check(x))) {
        return PyLong_AsLong(x);
    } else {
        long val;
        PyObject *tmp = __Pyx_PyNumber_Int(x);
        if (!tmp) return (long)-1;
        val = __Pyx_PyInt_AsLong(tmp);
        Py_DECREF(tmp);
        return val;
    }
}

static INLINE PY_LONG_LONG __Pyx_PyInt_AsLongLong(PyObject* x) {
#if PY_VERSION_HEX < 0x03000000
    if (likely(PyInt_CheckExact(x) || PyInt_Check(x))) {
        long val = PyInt_AS_LONG(x);
        return (PY_LONG_LONG)val;
    } else
#endif
    if (likely(PyLong_CheckExact(x) || PyLong_Check(x))) {
        return PyLong_AsLongLong(x);
    } else {
        PY_LONG_LONG val;
        PyObject *tmp = __Pyx_PyNumber_Int(x);
        if (!tmp) return (PY_LONG_LONG)-1;
        val = __Pyx_PyInt_AsLongLong(tmp);
        Py_DECREF(tmp);
        return val;
    }
}

static INLINE signed long __Pyx_PyInt_AsSignedLong(PyObject* x) {
#if PY_VERSION_HEX < 0x03000000
    if (likely(PyInt_CheckExact(x) || PyInt_Check(x))) {
        long val = PyInt_AS_LONG(x);
        return (signed long)val;
    } else
#endif
    if (likely(PyLong_CheckExact(x) || PyLong_Check(x))) {
        return PyLong_AsLong(x);
    } else {
        signed long val;
        PyObject *tmp = __Pyx_PyNumber_Int(x);
        if (!tmp) return (signed long)-1;
        val = __Pyx_PyInt_AsSignedLong(tmp);
        Py_DECREF(tmp);
        return val;
    }
}

static INLINE signed PY_LONG_LONG __Pyx_PyInt_AsSignedLongLong(PyObject* x) {
#if PY_VERSION_HEX < 0x03000000
    if (likely(PyInt_CheckExact(x) || PyInt_Check(x))) {
        long val = PyInt_AS_LONG(x);
        return (signed PY_LONG_LONG)val;
    } else
#endif
    if (likely(PyLong_CheckExact(x) || PyLong_Check(x))) {
        return PyLong_AsLongLong(x);
    } else {
        signed PY_LONG_LONG val;
        PyObject *tmp = __Pyx_PyNumber_Int(x);
        if (!tmp) return (signed PY_LONG_LONG)-1;
        val = __Pyx_PyInt_AsSignedLongLong(tmp);
        Py_DECREF(tmp);
        return val;
    }
}

#include "compile.h"
#include "frameobject.h"
#include "traceback.h"

static void __Pyx_AddTraceback(const char *funcname) {
    PyObject *py_srcfile = 0;
    PyObject *py_funcname = 0;
    PyObject *py_globals = 0;
    PyObject *empty_string = 0;
    PyCodeObject *py_code = 0;
    PyFrameObject *py_frame = 0;

    #if PY_MAJOR_VERSION < 3
    py_srcfile = PyString_FromString(__pyx_filename);
    #else
    py_srcfile = PyUnicode_FromString(__pyx_filename);
    #endif
    if (!py_srcfile) goto bad;
    if (__pyx_clineno) {
        #if PY_MAJOR_VERSION < 3
        py_funcname = PyString_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, __pyx_clineno);
        #else
        py_funcname = PyUnicode_FromFormat( "%s (%s:%d)", funcname, __pyx_cfilenm, __pyx_clineno);
        #endif
    }
    else {
        #if PY_MAJOR_VERSION < 3
        py_funcname = PyString_FromString(funcname);
        #else
        py_funcname = PyUnicode_FromString(funcname);
        #endif
    }
    if (!py_funcname) goto bad;
    py_globals = PyModule_GetDict(__pyx_m);
    if (!py_globals) goto bad;
    #if PY_MAJOR_VERSION < 3
    empty_string = PyString_FromStringAndSize("", 0);
    #else
    empty_string = PyBytes_FromStringAndSize("", 0);
    #endif
    if (!empty_string) goto bad;
    py_code = PyCode_New(
        0,            /*int argcount,*/
        #if PY_MAJOR_VERSION >= 3
        0,            /*int kwonlyargcount,*/
        #endif
        0,            /*int nlocals,*/
        0,            /*int stacksize,*/
        0,            /*int flags,*/
        empty_string, /*PyObject *code,*/
        __pyx_empty_tuple,  /*PyObject *consts,*/
        __pyx_empty_tuple,  /*PyObject *names,*/
        __pyx_empty_tuple,  /*PyObject *varnames,*/
        __pyx_empty_tuple,  /*PyObject *freevars,*/
        __pyx_empty_tuple,  /*PyObject *cellvars,*/
        py_srcfile,   /*PyObject *filename,*/
        py_funcname,  /*PyObject *name,*/
        __pyx_lineno,   /*int firstlineno,*/
        empty_string  /*PyObject *lnotab*/
    );
    if (!py_code) goto bad;
    py_frame = PyFrame_New(
        PyThreadState_GET(), /*PyThreadState *tstate,*/
        py_code,             /*PyCodeObject *code,*/
        py_globals,          /*PyObject *globals,*/
        0                    /*PyObject *locals*/
    );
    if (!py_frame) goto bad;
    py_frame->f_lineno = __pyx_lineno;
    PyTraceBack_Here(py_frame);
bad:
    Py_XDECREF(py_srcfile);
    Py_XDECREF(py_funcname);
    Py_XDECREF(empty_string);
    Py_XDECREF(py_code);
    Py_XDECREF(py_frame);
}

static int __Pyx_InitStrings(__Pyx_StringTabEntry *t) {
    while (t->p) {
        #if PY_MAJOR_VERSION < 3
        if (t->is_unicode && (!t->is_identifier)) {
            *t->p = PyUnicode_DecodeUTF8(t->s, t->n - 1, NULL);
        } else if (t->intern) {
            *t->p = PyString_InternFromString(t->s);
        } else {
            *t->p = PyString_FromStringAndSize(t->s, t->n - 1);
        }
        #else  /* Python 3+ has unicode identifiers */
        if (t->is_identifier || (t->is_unicode && t->intern)) {
            *t->p = PyUnicode_InternFromString(t->s);
        } else if (t->is_unicode) {
            *t->p = PyUnicode_FromStringAndSize(t->s, t->n - 1);
        } else {
            *t->p = PyBytes_FromStringAndSize(t->s, t->n - 1);
        }
        #endif
        if (!*t->p)
            return -1;
        ++t;
    }
    return 0;
}

/* Type Conversion Functions */

static INLINE int __Pyx_PyObject_IsTrue(PyObject* x) {
   if (x == Py_True) return 1;
   else if ((x == Py_False) | (x == Py_None)) return 0;
   else return PyObject_IsTrue(x);
}

static INLINE PyObject* __Pyx_PyNumber_Int(PyObject* x) {
  PyNumberMethods *m;
  const char *name = NULL;
  PyObject *res = NULL;
#if PY_VERSION_HEX < 0x03000000
  if (PyInt_Check(x) || PyLong_Check(x))
#else
  if (PyLong_Check(x))
#endif
    return Py_INCREF(x), x;
  m = Py_TYPE(x)->tp_as_number;
#if PY_VERSION_HEX < 0x03000000
  if (m && m->nb_int) {
    name = "int";
    res = PyNumber_Int(x);
  }
  else if (m && m->nb_long) {
    name = "long";
    res = PyNumber_Long(x);
  }
#else
  if (m && m->nb_int) {
    name = "int";
    res = PyNumber_Long(x);
  }
#endif
  if (res) {
#if PY_VERSION_HEX < 0x03000000
    if (!PyInt_Check(res) && !PyLong_Check(res)) {
#else
    if (!PyLong_Check(res)) {
#endif
      PyErr_Format(PyExc_TypeError,
                   "__%s__ returned non-%s (type %.200s)",
                   name, name, Py_TYPE(res)->tp_name);
      Py_DECREF(res);
      return NULL;
    }
  }
  else if (!PyErr_Occurred()) {
    PyErr_SetString(PyExc_TypeError,
                    "an integer is required");
  }
  return res;
}

static INLINE Py_ssize_t __Pyx_PyIndex_AsSsize_t(PyObject* b) {
  Py_ssize_t ival;
  PyObject* x = PyNumber_Index(b);
  if (!x) return -1;
  ival = PyInt_AsSsize_t(x);
  Py_DECREF(x);
  return ival;
}

static INLINE PyObject * __Pyx_PyInt_FromSize_t(size_t ival) {
#if PY_VERSION_HEX < 0x02050000
   if (ival <= LONG_MAX)
       return PyInt_FromLong((long)ival);
   else {
       unsigned char *bytes = (unsigned char *) &ival;
       int one = 1; int little = (int)*(unsigned char*)&one;
       return _PyLong_FromByteArray(bytes, sizeof(size_t), little, 0);
   }
#else
   return PyInt_FromSize_t(ival);
#endif
}

static INLINE size_t __Pyx_PyInt_AsSize_t(PyObject* x) {
   unsigned PY_LONG_LONG val = __Pyx_PyInt_AsUnsignedLongLong(x);
   if (unlikely(val == (unsigned PY_LONG_LONG)-1 && PyErr_Occurred())) {
       return (size_t)-1;
   } else if (unlikely(val != (unsigned PY_LONG_LONG)(size_t)val)) {
       PyErr_SetString(PyExc_OverflowError,
                       "value too large to convert to size_t");
       return (size_t)-1;
   }
   return (size_t)val;
}


